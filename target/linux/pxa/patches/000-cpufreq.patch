diff -Nurbw linux-2.6.17/arch/arm/Kconfig linux-2.6.17-patched/arch/arm/Kconfig
--- linux-2.6.17/arch/arm/Kconfig	2006-06-17 18:49:35.000000000 -0700
+++ linux-2.6.17-patched/arch/arm/Kconfig	2006-09-21 14:57:02.000000000 -0700
@@ -656,7 +656,7 @@
 
 endmenu
 
-if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP1)
+if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP1 || ARCH_PXA)
 
 menu "CPU Frequency scaling"
 
@@ -685,6 +685,13 @@
 
 endmenu
 
+config CPU_FREQ_PXA
+	bool
+	depends on CPU_FREQ && ARCH_PXA
+	default y
+	select CPU_FREQ_DEFAULT_GOV_USERSPACE
+	select CPU_FREQ_TABLE
+
 endif
 
 menu "Floating point emulation"
diff -Nurbw linux-2.6.17/arch/arm/mach-pxa/cpu-pxa.c linux-2.6.17-patched/arch/arm/mach-pxa/cpu-pxa.c
--- linux-2.6.17/arch/arm/mach-pxa/cpu-pxa.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.17-patched/arch/arm/mach-pxa/cpu-pxa.c	2006-09-21 14:57:02.000000000 -0700
@@ -0,0 +1,324 @@
+/*
+ *  linux/arch/arm/mach-pxa/cpu-pxa.c
+ *
+ *  Copyright (C) 2002,2003 Intrinsyc Software
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * History:
+ *   31-Jul-2002 : Initial version [FB]
+ *   29-Jan-2003 : added PXA255 support [FB]
+ *   20-Apr-2003 : ported to v2.5 (Dustin McIntire, Sensoria Corp.)
+ * 
+ * Note:
+ *   This driver may change the memory bus clock rate, but will not do any
+ *   platform specific access timing changes... for example if you have flash
+ *   memory connected to CS0, you will need to register a platform specific
+ *   notifier which will adjust the memory access strobes to maintain a 
+ *   minimum strobe width.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+  static unsigned int freq_debug = DEBUG;
+  module_param(freq_debug, int, 0);
+  MODULE_PARM_DESC(freq_debug, "Set the debug messages to on=1/off=0");
+#else
+  #define freq_debug  0
+#endif  
+
+typedef struct
+{
+    unsigned int khz;
+    unsigned int membus;
+    unsigned int cccr;
+    unsigned int div2;
+} pxa_freqs_t;
+
+/* Define the refresh period in mSec for the SDRAM and the number of rows */
+#define SDRAM_TREF          64      /* standard 64ms SDRAM */
+#define SDRAM_ROWS          2048    /* 64MB=8192 32MB=4096 */ 
+#define MDREFR_DRI(x)       ((x*SDRAM_TREF)/(SDRAM_ROWS*32))
+
+#define CCLKCFG_TURBO       0x1
+#define CCLKCFG_FCS         0x2
+#define PXA25x_MIN_FREQ     99533
+#define PXA25x_MAX_FREQ     530842
+#define MDREFR_DB2_MASK     (MDREFR_K2DB2 | MDREFR_K1DB2)
+#define MDREFR_DRI_MASK     0xFFF
+
+
+/* Use the run mode frequencies for the CPUFREQ_POLICY_PERFORMANCE policy */
+static pxa_freqs_t pxa255_run_freqs[] =
+{
+    /* CPU   MEMBUS  CCCR  DIV2*/
+    { 99533,  99533, 0x121, 1}, /* run= 99, turbo= 99, PXbus=50,  SDRAM=50 */
+    {132710, 132710, 0x123, 1}, /* run=133, turbo=133, PXbus=66,  SDRAM=66 */
+    {199066,  99533, 0x141, 0}, /* run=199, turbo=199, PXbus=99,  SDRAM=99 */
+    {265421, 132710, 0x143, 0}, /* run=265, turbo=265, PXbus=133, SDRAM=133 */
+    {331776, 165888, 0x145, 1}, /* run=331, turbo=331, PXbus=166, SDRAM=83 */
+    {398131,  99533, 0x161, 0}, /* run=398, turbo=398, PXbus=99,  SDRAM=99 */
+    {398131, 132710, 0x1c3, 0}, /* run=265, turbo=398, PXbus=133, SDRAM=133 */
+    {530842, 132710, 0x163, 0}, /* run=531, turbo=531, PXbus=133, SDRAM=133 */
+    {0,}
+};
+#define NUM_RUN_FREQS (sizeof(pxa255_run_freqs)/sizeof(pxa_freqs_t))
+
+static struct cpufreq_frequency_table pxa255_run_freq_table[NUM_RUN_FREQS+1];
+
+/* Use the turbo mode frequencies for the CPUFREQ_POLICY_POWERSAVE policy */
+static pxa_freqs_t pxa255_turbo_freqs[] =
+{
+    /* CPU   MEMBUS  CCCR  DIV2*/
+    { 99533, 99533,  0x121, 1}, /* run=99,  turbo= 99, PXbus=99, SDRAM=50 */
+    {149299, 99533,  0x1a1, 0}, /* run=99,  turbo=149, PXbus=99, SDRAM=99 */
+    {199066, 99533,  0x221, 0}, /* run=99,  turbo=199, PXbus=99, SDRAM=99 */
+    {298598, 99533,  0x321, 0}, /* run=99,  turbo=299, PXbus=99, SDRAM=99 */
+    {398131, 99533,  0x241, 1}, /* run=199, turbo=398, PXbus=99, SDRAM=50 */
+    {0,}
+};
+#define NUM_TURBO_FREQS (sizeof(pxa255_turbo_freqs)/sizeof(pxa_freqs_t))
+
+static struct cpufreq_frequency_table pxa255_turbo_freq_table[NUM_TURBO_FREQS+1];
+
+extern unsigned get_clk_frequency_khz(int info);
+
+/* find a valid frequency point */
+static int pxa_verify_policy(struct cpufreq_policy *policy)
+{
+    int ret;
+    struct cpufreq_frequency_table *pxa_freqs_table;
+
+    if(policy->policy == CPUFREQ_POLICY_PERFORMANCE) {
+        pxa_freqs_table = pxa255_run_freq_table;
+    } else if (policy->policy == CPUFREQ_POLICY_POWERSAVE) {
+        pxa_freqs_table = pxa255_turbo_freq_table;
+    } else {
+        printk("CPU PXA: Unknown policy found. "
+               "Using CPUFREQ_POLICY_PERFORMANCE\n");
+        pxa_freqs_table = pxa255_run_freq_table;
+    } 
+	ret=cpufreq_frequency_table_verify(policy, pxa_freqs_table);
+    
+    if(freq_debug) {
+        printk("Verified CPU policy: %dKhz min to %dKhz max\n",
+            policy->min, policy->max);
+    }
+
+    return ret;
+}
+
+static int pxa_set_target(struct cpufreq_policy *policy,
+                 unsigned int target_freq,
+                 unsigned int relation)
+{
+    int idx;
+    cpumask_t cpus_allowed;
+    int cpu = policy->cpu;
+    struct cpufreq_freqs freqs;
+    pxa_freqs_t *pxa_freq_settings;
+    struct cpufreq_frequency_table *pxa_freqs_table;
+    unsigned long flags;
+    unsigned int unused;
+    unsigned int preset_mdrefr, postset_mdrefr;
+    void *ramstart;
+
+    /*
+     * Save this threads cpus_allowed mask.
+     */
+    cpus_allowed = current->cpus_allowed;
+
+    /*
+     * Bind to the specified CPU.  When this call returns,
+     * we should be running on the right CPU.
+     */
+    set_cpus_allowed(current, cpumask_of_cpu(cpu));
+    BUG_ON(cpu != smp_processor_id());
+
+    /* Get the current policy */
+    if(policy->policy == CPUFREQ_POLICY_PERFORMANCE) {
+        pxa_freq_settings = pxa255_run_freqs;
+        pxa_freqs_table   = pxa255_run_freq_table;
+    }else if (policy->policy == CPUFREQ_POLICY_POWERSAVE) {
+        pxa_freq_settings = pxa255_turbo_freqs;
+        pxa_freqs_table   = pxa255_turbo_freq_table;
+    }else {
+        printk("CPU PXA: Unknown policy found. "
+               "Using CPUFREQ_POLICY_PERFORMANCE\n");
+        pxa_freq_settings = pxa255_run_freqs;
+        pxa_freqs_table   = pxa255_run_freq_table;
+    } 
+
+    /* Lookup the next frequency */
+	if (cpufreq_frequency_table_target(policy, pxa_freqs_table, 
+	                                   target_freq, relation, &idx)) {
+		return -EINVAL;
+    }
+
+    freqs.old = policy->cur;
+    freqs.new = pxa_freq_settings[idx].khz;
+    freqs.cpu = policy->cpu;  
+    if(freq_debug) {
+        printk(KERN_INFO "Changing CPU frequency to %d Mhz, (SDRAM %d Mhz)\n", 
+            freqs.new/1000, (pxa_freq_settings[idx].div2) ? 
+            (pxa_freq_settings[idx].membus/2000) : 
+            (pxa_freq_settings[idx].membus/1000));
+    }
+
+    ramstart = phys_to_virt(0xa0000000);
+
+    /* 
+     * Tell everyone what we're about to do... 
+     * you should add a notify client with any platform specific 
+     * Vcc changing capability
+     */
+    cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+    /* Calculate the next MDREFR.  If we're slowing down the SDRAM clock
+     * we need to preset the smaller DRI before the change.  If we're speeding
+     * up we need to set the larger DRI value after the change.  
+     */
+    preset_mdrefr = postset_mdrefr = MDREFR;
+    if((MDREFR & MDREFR_DRI_MASK) > MDREFR_DRI(pxa_freq_settings[idx].membus)) {    
+        preset_mdrefr = (preset_mdrefr & ~MDREFR_DRI_MASK) | 
+                        MDREFR_DRI(pxa_freq_settings[idx].membus);
+    }
+    postset_mdrefr = (postset_mdrefr & ~MDREFR_DRI_MASK) | 
+                    MDREFR_DRI(pxa_freq_settings[idx].membus);
+    
+    /* If we're dividing the memory clock by two for the SDRAM clock, this
+     * must be set prior to the change.  Clearing the divide must be done
+     * after the change.
+     */
+    if(pxa_freq_settings[idx].div2) { 
+        preset_mdrefr  |= MDREFR_DB2_MASK;
+        postset_mdrefr |= MDREFR_DB2_MASK;
+    } else { 
+        postset_mdrefr &= ~MDREFR_DB2_MASK; 
+    }
+    
+    local_irq_save(flags);
+    
+    /* Set new the CCCR */
+    CCCR = pxa_freq_settings[idx].cccr;
+
+    __asm__ __volatile__("                                  \
+        ldr r4, [%1] ;  /* load MDREFR */                   \
+        b   2f ;                                            \
+        .align  5 ;                                         \
+1:                                                          \
+        str %4, [%1] ;          /* preset the MDREFR */     \
+        mcr p14, 0, %2, c6, c0, 0 ; /* set CCLKCFG[FCS] */  \
+        str %5, [%1] ;          /* postset the MDREFR */    \
+                                                            \
+        b   3f       ;                                      \
+2:      b   1b       ;                                      \
+3:      nop          ;                                      \
+        "                                                                            
+        : "=&r" (unused)                                                             
+        : "r" (&MDREFR), "r" (CCLKCFG_TURBO|CCLKCFG_FCS), "r" (ramstart), \
+          "r" (preset_mdrefr), "r" (postset_mdrefr)             
+        : "r4", "r5");
+    local_irq_restore(flags);
+
+    /*
+     * Restore the CPUs allowed mask.
+     */
+    set_cpus_allowed(current, cpus_allowed);
+
+    /* 
+     * Tell everyone what we've just done... 
+     * you should add a notify client with any platform specific 
+     * SDRAM refresh timer adjustments
+     */
+    cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+    return 0;
+}
+
+static int pxa_cpufreq_init(struct cpufreq_policy *policy)
+{
+    cpumask_t cpus_allowed;
+    unsigned int cpu = policy->cpu;
+    int i;
+
+	cpus_allowed = current->cpus_allowed;
+
+	set_cpus_allowed(current, cpumask_of_cpu(cpu));
+	BUG_ON(cpu != smp_processor_id());
+
+    /* set default policy and cpuinfo */
+    policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+    policy->policy = CPUFREQ_POLICY_PERFORMANCE;
+    policy->cpuinfo.max_freq = PXA25x_MAX_FREQ;
+    policy->cpuinfo.min_freq = PXA25x_MIN_FREQ;
+    policy->cpuinfo.transition_latency = 1000; /* FIXME: 1 ms, assumed */
+    policy->cur = get_clk_frequency_khz(0); /* current freq */
+    policy->min = policy->max = policy->cur;
+
+    /* Generate the run cpufreq_frequency_table struct */
+    for(i=0;i<NUM_RUN_FREQS;i++) {
+        pxa255_run_freq_table[i].frequency = pxa255_run_freqs[i].khz;
+        pxa255_run_freq_table[i].index = i;    
+    }
+    pxa255_run_freq_table[i].frequency = CPUFREQ_TABLE_END;
+    /* Generate the turbo cpufreq_frequency_table struct */
+    for(i=0;i<NUM_TURBO_FREQS;i++) {
+        pxa255_turbo_freq_table[i].frequency = pxa255_turbo_freqs[i].khz;
+        pxa255_turbo_freq_table[i].index = i;    
+    }
+    pxa255_turbo_freq_table[i].frequency = CPUFREQ_TABLE_END;
+    
+    set_cpus_allowed(current, cpus_allowed);
+    printk(KERN_INFO "PXA CPU frequency change support initialized\n");
+
+    return 0;
+}
+
+static struct cpufreq_driver pxa_cpufreq_driver = {
+    .verify     = pxa_verify_policy,
+    .target     = pxa_set_target,
+    .init       = pxa_cpufreq_init,
+    .name       = "PXA25x",
+};
+
+static int __init pxa_cpu_init(void)
+{
+    return cpufreq_register_driver(&pxa_cpufreq_driver);
+}
+
+static void __exit pxa_cpu_exit(void)
+{
+    cpufreq_unregister_driver(&pxa_cpufreq_driver);
+}
+
+
+MODULE_AUTHOR ("Intrinsyc Software Inc.");
+MODULE_DESCRIPTION ("CPU frequency changing driver for the PXA architecture");
+MODULE_LICENSE("GPL");
+module_init(pxa_cpu_init);
+module_exit(pxa_cpu_exit);
+
diff -Nurbw linux-2.6.17/arch/arm/mach-pxa/Makefile linux-2.6.17-patched/arch/arm/mach-pxa/Makefile
--- linux-2.6.17/arch/arm/mach-pxa/Makefile	2006-09-21 15:11:33.000000000 -0700
+++ linux-2.6.17-patched/arch/arm/mach-pxa/Makefile	2006-09-21 14:57:02.000000000 -0700
@@ -30,5 +30,6 @@
 obj-$(CONFIG_PM) += pm.o sleep.o
 obj-$(CONFIG_PXA_SSP) += ssp.o
+obj-$(CONFIG_CPU_FREQ) += cpu-pxa.o
 
 ifeq ($(CONFIG_PXA27x),y)
 obj-$(CONFIG_PM) += standby.o
diff -Nurbw linux-2.6.17/Documentation/cpu-freq/user-guide.txt linux-2.6.17-patched/Documentation/cpu-freq/user-guide.txt
--- linux-2.6.17/Documentation/cpu-freq/user-guide.txt	2006-06-17 18:49:35.000000000 -0700
+++ linux-2.6.17-patched/Documentation/cpu-freq/user-guide.txt	2006-09-21 14:57:02.000000000 -0700
@@ -18,7 +18,7 @@
 Contents:
 ---------
 1. Supported Architectures and Processors
-1.1 ARM
+1.1 ARM, PXA
 1.2 x86
 1.3 sparc64
 1.4 ppc
@@ -37,14 +37,15 @@
 1. Supported Architectures and Processors
 =========================================
 
-1.1 ARM
--------
+1.1 ARM, PXA
+------------
 
 The following ARM processors are supported by cpufreq:
 
 ARM Integrator
 ARM-SA1100
 ARM-SA1110
+Intel PXA
 
 
 1.2 x86
diff -Nurbw linux-2.6.17/drivers/cpufreq/Kconfig linux-2.6.17-patched/drivers/cpufreq/Kconfig
--- linux-2.6.17/drivers/cpufreq/Kconfig	2006-06-17 18:49:35.000000000 -0700
+++ linux-2.6.17-patched/drivers/cpufreq/Kconfig	2006-09-21 15:06:12.000000000 -0700
@@ -46,13 +46,9 @@
          This will show detail CPU frequency translation table in sysfs file
          system
 
-# Note that it is not currently possible to set the other governors (such as ondemand)
-# as the default, since if they fail to initialise, cpufreq will be
-# left in an undefined state.
-
 choice
 	prompt "Default CPUFreq governor"
-	default CPU_FREQ_DEFAULT_GOV_USERSPACE if CPU_FREQ_SA1100 || CPU_FREQ_SA1110
+	default CPU_FREQ_DEFAULT_GOV_USERSPACE if CPU_FREQ_SA1100 || CPU_FREQ_SA1110 || CPU_FREQ_PXA
 	default CPU_FREQ_DEFAULT_GOV_PERFORMANCE
 	help
 	  This option sets which CPUFreq governor shall be loaded at
@@ -66,6 +62,14 @@
 	  the frequency statically to the highest frequency supported by
 	  the CPU.
 
+config CPU_FREQ_DEFAULT_GOV_POWERSAVE
+	bool "powersave"
+	select CPU_FREQ_GOV_POWERSAVE
+	help
+	  Use the CPUFreq governor 'powersave' as default. This sets
+	  the frequency statically to the lowest frequency supported by
+	  the CPU.
+
 config CPU_FREQ_DEFAULT_GOV_USERSPACE
 	bool "userspace"
 	select CPU_FREQ_GOV_USERSPACE
@@ -75,6 +79,23 @@
 	  program shall be able to set the CPU dynamically without having
 	  to enable the userspace governor manually.
 
+config CPU_FREQ_DEFAULT_GOV_ONDEMAND
+	bool "ondemand"
+	select CPU_FREQ_GOV_ONDEMAND
+	help
+	  Use the CPUFreq governor 'ondemand' as default.  This sets
+	  the frequency dynamically based on CPU load, throttling up
+	  and down as necessary.
+
+config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
+	bool "conservative"
+	select CPU_FREQ_GOV_CONSERVATIVE
+	help
+	  Use the CPUFreq governor 'conservative' as default. This sets
+	  the frequency dynamically based on CPU load, throttling up
+	  and down as necessary. The frequency is gracefully increased
+	  and decreased rather than jumping to 100% when speed is required.
+
 endchoice
 
 config CPU_FREQ_GOV_PERFORMANCE
diff -Nurbw linux-2.6.17/include/linux/cpufreq.h linux-2.6.17-patched/include/linux/cpufreq.h
--- linux-2.6.17/include/linux/cpufreq.h	2006-06-17 18:49:35.000000000 -0700
+++ linux-2.6.17-patched/include/linux/cpufreq.h	2006-09-21 15:08:35.000000000 -0700
@@ -276,9 +276,18 @@
 #ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
 extern struct cpufreq_governor cpufreq_gov_performance;
 #define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_performance
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE)
+extern struct cpufreq_governor cpufreq_gov_powersave;
+#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_powersave
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
 extern struct cpufreq_governor cpufreq_gov_userspace;
 #define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_userspace
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND)
+extern struct cpufreq_governor cpufreq_gov_ondemand;
+#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_ondemand;
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE)
+extern struct cpufreq_governor cpufreq_gov_conservative;
+#define CPUFREQ_DEFAULT_GOVERNOR        &cpufreq_gov_conservative;
 #endif
 
 
diff -Nubrw --exclude='.*.o.cmd' linux-2.6.17/drivers/cpufreq/cpufreq_conservative.c linux-2.6.17-patched/drivers/cpufreq/cpufreq_conservative.c
--- linux-2.6.17/drivers/cpufreq/cpufreq_conservative.c	2006-09-21 15:26:46.000000000 -0700
+++ linux-2.6.17-patched/drivers/cpufreq/cpufreq_conservative.c	2006-06-17 18:49:35.000000000 -0700
@@ -529,7 +529,7 @@
 	return 0;
 }
 
-static struct cpufreq_governor cpufreq_gov_dbs = {
+struct cpufreq_governor cpufreq_gov_conservative = {
 	.name		= "conservative",
 	.governor	= cpufreq_governor_dbs,
 	.owner		= THIS_MODULE,
@@ -537,7 +537,7 @@
 
 static int __init cpufreq_gov_dbs_init(void)
 {
-	return cpufreq_register_governor(&cpufreq_gov_dbs);
+	return cpufreq_register_governor(&cpufreq_gov_conservative);
 }
 
 static void __exit cpufreq_gov_dbs_exit(void)
@@ -545,7 +545,7 @@
 	/* Make sure that the scheduled work is indeed not running */
 	flush_scheduled_work();
 
-	cpufreq_unregister_governor(&cpufreq_gov_dbs);
+	cpufreq_unregister_governor(&cpufreq_gov_conservative);
 }
 
 
diff -Nubrw --exclude='.*.o.cmd' linux-2.6.17/drivers/cpufreq/cpufreq_ondemand.c linux-2.6.17-patched/drivers/cpufreq/cpufreq_ondemand.c
--- linux-2.6.17/drivers/cpufreq/cpufreq_ondemand.c	2006-06-17 18:49:35.000000000 -0700
+++ linux-2.6.17-patched/drivers/cpufreq/cpufreq_ondemand.c	2006-09-27 14:00:15.000000000 -0700
@@ -484,7 +484,7 @@
 	return 0;
 }
 
-static struct cpufreq_governor cpufreq_gov_dbs = {
+struct cpufreq_governor cpufreq_gov_ondemand = {
 	.name		= "ondemand",
 	.governor	= cpufreq_governor_dbs,
 	.owner		= THIS_MODULE,
@@ -492,7 +492,7 @@
 
 static int __init cpufreq_gov_dbs_init(void)
 {
-	return cpufreq_register_governor(&cpufreq_gov_dbs);
+	return cpufreq_register_governor(&cpufreq_gov_ondemand);
 }
 
 static void __exit cpufreq_gov_dbs_exit(void)
@@ -504,7 +504,7 @@
 		destroy_workqueue(dbs_workq);
 	}
 
-	cpufreq_unregister_governor(&cpufreq_gov_dbs);
+	cpufreq_unregister_governor(&cpufreq_gov_ondemand);
 }
 
 

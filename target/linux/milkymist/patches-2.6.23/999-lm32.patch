diff --git a/arch/lm32/Kconfig b/arch/lm32/Kconfig
new file mode 100644
index 0000000..48c2fc2
--- /dev/null
+++ b/arch/lm32/Kconfig
@@ -0,0 +1,125 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+mainmenu "uClinux/lattice mico32 Kernel Configuration"
+
+# this setting fixes all other settings we want to have fixed
+config LM32
+	bool
+	default y
+	select CPU_MICO32
+
+config MMU
+	bool
+	default n
+
+config VGA_CONSOLE
+	bool
+	default n
+
+config ZONE_DMA_FLAG
+	int
+	default 0
+
+config GENERIC_IOMAP
+	bool
+	default y
+
+config RWSEM_GENERIC_SPINLOCK
+	bool
+	default y
+
+config GENERIC_FIND_NEXT_BIT
+	bool
+	default y
+
+config GENERIC_HWEIGHT
+	bool
+	default y
+
+config GENERIC_CALIBRATE_DELAY
+	bool
+	default y
+
+config GENERIC_ALLOCATOR
+	bool
+	default y
+
+config GENERIC_BUG
+	bool
+	default y
+
+config GENERIC_HARDIRQS
+	bool
+	default y
+
+config GENERIC_CLOCKEVENTS
+	bool
+	default n
+
+config SELECT_MEMORY_MODEL
+	bool
+	default y
+
+config FLATMEM_MANUAL
+	bool
+	default y
+
+config FLATMEM
+	bool
+	default y
+
+config FLAT_NODE_MEM_MAP
+	bool
+	default y
+
+config FLAT_NODE_MEM_MAP
+	bool
+	default y
+
+config NO_IOPORT
+	bool
+	default y
+
+config GENERIC_HARDIRQS_NO__DO_IRQ
+	bool
+	default y
+
+config APM_EMULATION
+	bool
+	default n
+
+source "init/Kconfig"
+
+source "arch/lm32/Kconfig.cpu"
+
+menu "Executable file formats"
+
+source "fs/Kconfig.binfmt"
+
+endmenu
+
+menu "Power management options"
+
+config PM
+	bool "Power Management support"
+	help
+	  Support processor power management modes
+
+endmenu
+
+source "net/Kconfig"
+
+source "drivers/Kconfig"
+
+source "fs/Kconfig"
+
+source "arch/lm32/Kconfig.debug"
+
+source "security/Kconfig"
+
+source "crypto/Kconfig"
+
+source "lib/Kconfig"
diff --git a/arch/lm32/Kconfig.cpu b/arch/lm32/Kconfig.cpu
new file mode 100644
index 0000000..07b3e4f
--- /dev/null
+++ b/arch/lm32/Kconfig.cpu
@@ -0,0 +1,84 @@
+menu "Processor, Board and Features"
+
+choice
+	prompt "LM32 platform"
+	default PLAT_MILKYMIST
+
+config PLAT_MILKYMIST
+	bool "milkymist"
+	help
+	  Milkymist board.
+
+
+endchoice
+
+if (PLAT_MILKYMIST)
+choice
+	prompt "CPU"
+	default CPU_MICO32
+
+config CPU_MICO32
+	bool "mico32"
+	help
+	  Lattice mico32 processor.
+endchoice
+
+choice
+	prompt "Board Selection"
+	default BOARD_XILINX_ML401
+
+config	BOARD_XILINX_ML401
+	bool "Xilinx ML401"
+
+config	BOARD_MILKYMIST_ONE
+	bool "Milkymist One"
+endchoice
+endif
+
+config CPU_CLOCK
+	int "CPU Clock [Hz] (integer)"
+	default "100000000" if BOARD_XILINX_ML401
+	default "100000000" if BOARD_MILKYMIST_ONE
+
+config MEMORY_START
+	hex "Physical memory start address (hex)"
+	default "0x40000000"  if BOARD_XILINX_ML401
+	default "0x40000000"  if BOARD_MILKYMIST_ONE
+
+config MEMORY_SIZE
+	hex "Physical memory size (hex)"
+	default "0x04000000"  if BOARD_XILINX_ML401
+	default "0x04000000"  if BOARD_MILKYMIST_ONE
+
+config TEXT_OFFSET
+	hex "Set the text offset in memory"
+	default "0x40000000"  if BOARD_XILINX_ML401
+	default "0x40000000"  if BOARD_MILKYMIST_ONE
+	help
+	  Define where the kernel will be loaded to and executed from.
+
+config HZ
+	int
+	default 100
+
+config EARLY_PRINTK
+	bool "Early printk"
+	default y
+	help
+	  This option enables special console drivers which allow the kernel
+	  to print messages very early in the bootup process.
+
+	  This is useful for kernel debugging when your machine crashes very
+	  early before the console code is initialized. You should normally
+	        say N here, unless you want to debug.
+
+config LM32_HW_JTAG
+bool "Disable kernel exception handling (enable JTAG debugging)"
+	default n
+	help
+	  This option disables the exception handling within the kernel. It is
+	  required to allow access with the JTAG debugger for kernel-level
+	  debug access.
+
+	  Your should normally say N here, unless you want to debug.
+endmenu
diff --git a/arch/lm32/Kconfig.debug b/arch/lm32/Kconfig.debug
new file mode 100644
index 0000000..cde44a8
--- /dev/null
+++ b/arch/lm32/Kconfig.debug
@@ -0,0 +1,13 @@
+menu "Kernel hacking"
+
+source "lib/Kconfig.debug"
+
+config BOOTPARAM
+	bool 'Compiled-in Kernel Boot Parameter'
+
+config BOOTPARAM_STRING
+	string 'Kernel Boot Parameter'
+	default 'console=ttyS0,19200'
+	depends on BOOTPARAM
+
+endmenu
diff --git a/arch/lm32/Makefile b/arch/lm32/Makefile
new file mode 100644
index 0000000..5e5243a
--- /dev/null
+++ b/arch/lm32/Makefile
@@ -0,0 +1,51 @@
+#
+# arch/lm32/Makefile
+#
+# (C) Copyright 2007, Theobroma Systems <www.theobroma-systems.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+board-$(CONFIG_BOARD_XILINX_ML401)	:= ml401
+board-$(CONFIG_BOARD_MILKYMIST_ONE)	:= milkymist-one
+BOARD := $(board-y)
+
+export BOARD
+
+cflags-y := -mmultiply-enabled -mdivide-enabled \
+	-mbarrel-shift-enabled -msign-extend-enabled
+
+AFLAGS += $(cflags-y)
+
+OBJCOPYFLAGS	:=-O binary -R .note -R .comment -S
+
+CFLAGS += $(cflags-y)
+CFLAGS += -D__linux__
+CFLAGS += -DUTS_SYSNAME=\"uClinux\"
+
+head-y := arch/lm32/kernel/head.o arch/lm32/kernel/init_task.o
+
+core-y	+= arch/lm32/kernel/ arch/lm32/mm/
+libs-y	+= arch/lm32/lib/
+
+vmlinux.bin: vmlinux
+	$(OBJCOPY) $(OBJCOPYFLAGS) $< $@
+
+vmlinux.gz: vmlinux.bin
+	cat $< |gzip >$@
diff --git a/arch/lm32/defconfig b/arch/lm32/defconfig
new file mode 100644
index 0000000..a40784f
--- /dev/null
+++ b/arch/lm32/defconfig
@@ -0,0 +1,677 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.23
+# Wed Jan 13 19:50:35 2010
+#
+CONFIG_LM32=y
+# CONFIG_MMU is not set
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_GENERIC_IOMAP=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HARDIRQS=y
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_NO_IOPORT=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=12
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+# CONFIG_BASE_FULL is not set
+CONFIG_FUTEX=y
+# CONFIG_EPOLL is not set
+# CONFIG_SIGNALFD is not set
+# CONFIG_EVENTFD is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=1
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Processor, Board and Features
+#
+CONFIG_PLAT_MILKYMIST=y
+CONFIG_CPU_MICO32=y
+CONFIG_BOARD_XILINX_ML401=y
+# CONFIG_BOARD_MILKYMIST_ONE is not set
+CONFIG_CPU_CLOCK=100000000
+CONFIG_MEMORY_START=0x40000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_TEXT_OFFSET=0x40000000
+CONFIG_HZ=100
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_LM32_HW_JTAG is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_XILINX_SYSACE=y
+# CONFIG_MISC_DEVICES is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_OPEN_ETH=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLHC=y
+# CONFIG_SLIP_SMART is not set
+# CONFIG_SLIP_MODE_SLIP6 is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_MILKBD=y
+CONFIG_SERIO_MILKMOUSE=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_MILKYMIST=y
+# CONFIG_SERIAL_MILKYMIST_CONSOLE is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_MILKYMIST=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_RTC_CLASS is not set
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_BOOTPARAM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
diff --git a/arch/lm32/kernel/Makefile b/arch/lm32/kernel/Makefile
new file mode 100644
index 0000000..e3c124f
--- /dev/null
+++ b/arch/lm32/kernel/Makefile
@@ -0,0 +1,11 @@
+#
+# arch/lm32/kernel/Makefile
+#
+
+extra-y		:= head.o init_task.o vmlinux.lds
+
+obj-y 		+= semaphore.o sys_lm32.o setup.o traps.o signal.o \
+		   time.o ptrace.o irq.o process.o entry.o 
+obj-$(CONFIG_EARLY_PRINTK) += early_printk.o 
+
+obj-$(CONFIG_MODULES)	+= module.o
diff --git a/arch/lm32/kernel/asm-offsets.c b/arch/lm32/kernel/asm-offsets.c
new file mode 100644
index 0000000..b7f0262
--- /dev/null
+++ b/arch/lm32/kernel/asm-offsets.c
@@ -0,0 +1,138 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on
+ *
+ * arch/m68knommu/kernel/asm-offsets.c
+ */
+
+/*
+ * This program is used to generate definitions needed by
+ * assembly language modules.
+ *
+ * We use the technique used in the OSF Mach kernel code:
+ * generate asm statements containing #defines,
+ * compile this file to assembler, and then extract the
+ * #defines from the assembly-language output.
+ */
+
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <linux/ptrace.h>
+#include <linux/hardirq.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/irqnode.h>
+#include <asm/thread_info.h>
+
+#define DEFINE(sym, val) \
+        asm volatile("\n->" #sym " %0 " #val : : "i" (val))
+
+#define BLANK() asm volatile("\n->" : : )
+
+int main(void)
+{
+	/* offsets into the task struct */
+	DEFINE(TASK_STATE, offsetof(struct task_struct, state));
+	DEFINE(TASK_FLAGS, offsetof(struct task_struct, flags));
+	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
+	DEFINE(TASK_BLOCKED, offsetof(struct task_struct, blocked));
+	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
+	DEFINE(TASK_THREAD_INFO, offsetof(struct task_struct, stack));
+	DEFINE(TASK_MM, offsetof(struct task_struct, mm));
+	DEFINE(TASK_ACTIVE_MM, offsetof(struct task_struct, active_mm));
+
+	/* offsets into the thread struct in the task struct*/
+	DEFINE(TASK_KSP, offsetof(struct task_struct, thread.ksp));
+	DEFINE(TASK_USP, offsetof(struct task_struct, thread.usp));
+	DEFINE(TASK_WHICH_STACK, offsetof(struct task_struct, thread.which_stack));
+
+	/* offsets into the kernel_stat struct */
+	DEFINE(STAT_IRQ, offsetof(struct kernel_stat, irqs));
+
+	/* offsets into the irq_cpustat_t struct */
+	DEFINE(CPUSTAT_SOFTIRQ_PENDING, offsetof(irq_cpustat_t, __softirq_pending));
+
+	/* offsets into the thread struct */
+	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
+	DEFINE(THREAD_USP, offsetof(struct thread_struct, usp));
+	DEFINE(THREAD_WHICH_STACK, offsetof(struct thread_struct, which_stack));
+
+	/* offsets into the pt_regs */
+	DEFINE(PT_R0, offsetof(struct pt_regs, r0));
+	DEFINE(PT_R1, offsetof(struct pt_regs, r1));
+	DEFINE(PT_R2, offsetof(struct pt_regs, r2));
+	DEFINE(PT_R3, offsetof(struct pt_regs, r3));
+	DEFINE(PT_R4, offsetof(struct pt_regs, r4));
+	DEFINE(PT_R5, offsetof(struct pt_regs, r5));
+	DEFINE(PT_R6, offsetof(struct pt_regs, r6));
+	DEFINE(PT_R7, offsetof(struct pt_regs, r7));
+	DEFINE(PT_R8, offsetof(struct pt_regs, r8));
+	DEFINE(PT_R9, offsetof(struct pt_regs, r9));
+	DEFINE(PT_R10, offsetof(struct pt_regs, r10));
+	DEFINE(PT_R11, offsetof(struct pt_regs, r11));
+	DEFINE(PT_R12, offsetof(struct pt_regs, r12));
+	DEFINE(PT_R13, offsetof(struct pt_regs, r13));
+	DEFINE(PT_R14, offsetof(struct pt_regs, r14));
+	DEFINE(PT_R15, offsetof(struct pt_regs, r15));
+	DEFINE(PT_R16, offsetof(struct pt_regs, r16));
+	DEFINE(PT_R17, offsetof(struct pt_regs, r17));
+	DEFINE(PT_R18, offsetof(struct pt_regs, r18));
+	DEFINE(PT_R19, offsetof(struct pt_regs, r19));
+	DEFINE(PT_R20, offsetof(struct pt_regs, r20));
+	DEFINE(PT_R21, offsetof(struct pt_regs, r21));
+	DEFINE(PT_R22, offsetof(struct pt_regs, r22));
+	DEFINE(PT_R23, offsetof(struct pt_regs, r23));
+	DEFINE(PT_R24, offsetof(struct pt_regs, r24));
+	DEFINE(PT_R25, offsetof(struct pt_regs, r25));
+	DEFINE(PT_GP, offsetof(struct pt_regs, gp));
+	DEFINE(PT_FP, offsetof(struct pt_regs, fp));
+	DEFINE(PT_SP, offsetof(struct pt_regs, sp));
+	DEFINE(PT_RA, offsetof(struct pt_regs, ra));
+	DEFINE(PT_EA, offsetof(struct pt_regs, ea));
+	DEFINE(PT_BA, offsetof(struct pt_regs, ba));
+
+	/* offsets into the kernel_stat struct */
+	DEFINE(STAT_IRQ, offsetof(struct kernel_stat, irqs));
+
+	/* signal defines */
+	DEFINE(SIGSEGV, SIGSEGV);
+	DEFINE(SEGV_MAPERR, SEGV_MAPERR);
+	DEFINE(SIGTRAP, SIGTRAP);
+	DEFINE(TRAP_TRACE, TRAP_TRACE);
+
+	DEFINE(PT_PTRACED, PT_PTRACED);
+	DEFINE(PT_DTRACE, PT_DTRACE);
+
+	DEFINE(THREAD_SIZE, THREAD_SIZE);
+
+	/* Offsets in thread_info structure */
+	DEFINE(TI_TASK, offsetof(struct thread_info, task));
+	DEFINE(TI_EXECDOMAIN, offsetof(struct thread_info, exec_domain));
+	DEFINE(TI_FLAGS, offsetof(struct thread_info, flags));
+	DEFINE(TI_CPU, offsetof(struct thread_info, cpu));
+
+	return 0;
+}
diff --git a/arch/lm32/kernel/early_printk.c b/arch/lm32/kernel/early_printk.c
new file mode 100644
index 0000000..47c4306
--- /dev/null
+++ b/arch/lm32/kernel/early_printk.c
@@ -0,0 +1,88 @@
+/*
+ * (C) Copyright 2009
+ *     Sebastien Bourdeauducq
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on
+ *
+ * arch/mips/kernel/early_printk.c
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2003, 06, 07 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2007 MIPS Technologies, Inc.
+ *   written by Ralf Baechle (ralf@linux-mips.org)
+ */
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <asm/setup.h>
+#include <asm/irq.h>
+
+#define MMPTR(x) (*((volatile unsigned int *)(x)))
+#define CSR_UART_RXTX 		MMPTR(0x80000000)
+#define CSR_UART_DIVISOR	MMPTR(0x80000004)
+
+static void early_console_putc (char c)
+{
+	CSR_UART_RXTX = c;
+	while(!(lm32_irq_pending() & (1 << IRQ_UARTTX)));
+	lm32_irq_ack(IRQ_UARTTX);
+}
+
+// write string to console
+static void
+early_console_write(struct console *con, const char *s, unsigned n)
+{
+	while (n-- && *s) {
+		early_console_putc(*s);
+		s++;
+	}
+}
+
+// setup console
+static int
+early_console_setup(struct console *con, char *s)
+{
+	if( s )
+		early_console_write(con, s, strlen(s));
+
+	return 0;
+}
+
+static struct console early_console = {
+	.name	= "early",
+	.write	= early_console_write,
+	.setup = early_console_setup,
+	.flags	= CON_PRINTBUFFER | CON_BOOT,
+	.index	= -1
+};
+
+static int early_console_initialized;
+
+void setup_early_printk(void)
+{
+	if (early_console_initialized)
+		return;
+	early_console_initialized = 1;
+
+	register_console(&early_console);
+}
diff --git a/arch/lm32/kernel/entry.S b/arch/lm32/kernel/entry.S
new file mode 100644
index 0000000..5be1db0
--- /dev/null
+++ b/arch/lm32/kernel/entry.S
@@ -0,0 +1,965 @@
+#include <linux/sys.h>
+#include <linux/linkage.h>
+#include <asm/traps.h>
+#include <asm/unistd.h>
+#include <asm/thread_info.h>
+#include <asm/errno.h>
+#include <asm/setup.h>
+#include <asm/segment.h>
+#include <asm/asm-offsets.h>
+
+/* 
+ * Exception vector table (see "LatticeMico32 Processor Reference Manual")
+ */
+
+#undef LM32_DEBUG_SYSCALL_CALL
+#undef LM32_DEBUG_SYSCALL_RET
+/* #undef LM32_BREAK_ON_SYSCALL /**/
+/* #define LM32_BREAK_ON_SYSCALL 190 /**/
+
+#define HW_JTAG_EXCEPTION_VECTOR(offset) \
+	rcsr  r7, DEBA; \
+	addi  r7, r7, offset; \
+	b     r7 ; \
+	nop ; \
+	nop ; \
+	nop ; \
+	nop ; \
+	nop
+
+/* exception vector for os-aware gdb and kernel signals */
+#define KERNEL_EXCEPTION_VECTOR(offset) \
+	addi	sp,sp,-128; \
+	sw		(sp+120), ra; \
+	calli	_save_syscall_frame; \
+	mvi		r1, offset; \
+	addi	r2, sp, 4; \
+	calli	asm_do_sig; \
+	bi		_return_from_exception; \
+	nop
+
+.section ".exception.text"	
+
+ENTRY(reset_handler)
+	KERNEL_EXCEPTION_VECTOR(0)
+
+ENTRY(breakpoint_handler)
+#ifdef LM32_HW_JTAG
+	HW_JTAG_EXCEPTION_VECTOR(32)
+#else
+	bi _long_breakpoint_handler
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+#endif
+
+ENTRY(instruction_bus_error_handler)
+#ifdef LM32_HW_JTAG
+	HW_JTAG_EXCEPTION_VECTOR(64)
+#else
+	KERNEL_EXCEPTION_VECTOR(64)
+#endif
+
+ENTRY(watchpoint_handler)
+	HW_JTAG_EXCEPTION_VECTOR(96)
+
+ENTRY(data_bus_error_handler)
+#ifdef LM32_HW_JTAG
+	HW_JTAG_EXCEPTION_VECTOR(128)
+#else
+	KERNEL_EXCEPTION_VECTOR(128)
+#endif
+
+ENTRY(divide_by_zero_handler)
+	KERNEL_EXCEPTION_VECTOR(160)
+
+ENTRY(interrupt_handler)
+	addi    sp, sp, -128
+	sw      (sp+120), ra
+	calli   _save_irq_frame
+	rcsr    r1, IP
+
+	addi    r2, sp, 4
+	calli   asm_do_IRQ
+	bi      _restore_irq_frame_and_return
+	nop
+
+ENTRY(system_call)
+	/* break */
+	/* store away r9,r10 so that we can use it here TODO: use clobbered ones*/
+	sw (sp+0), r9 /* needed for various */
+	sw (sp+-4), r10 /* needed for current = current_thread_info()->task */
+	sw (sp+-8), r11 /* needed for user stack pointer, if switching */
+
+#ifdef LM32_BREAK_ON_SYSCALL
+	mvi r9, LM32_BREAK_ON_SYSCALL /* only break in this syscall no */
+	bne r8, r9, 7f
+	break
+7:
+#endif
+
+	/* test if already on kernel stack: test current_thread_info->task->which_stack */
+	mvhi r9, hi(lm32_current_thread)
+	ori r9, r9, lo(lm32_current_thread)
+	lw r9, (r9+0) /* dereference lm32_current_thread */
+	lw r10, (r9+TI_TASK) /* load pointer to task */
+	lw r9, (r10+TASK_WHICH_STACK)
+	be r9, r0, 1f
+
+	/* we are on user stack, have to switch */
+	mv r11, sp /* remember sp for restoring r9, r10, r11 */
+	sw (r10+TASK_USP), sp /* store usp */
+	lw sp, (r10+TASK_KSP) /* load ksp */
+	sw (r10+TASK_WHICH_STACK), r0 /* set which_stack to 0 */
+
+	/* restore r9, r10, r11 */
+	lw r9, (r11+0)
+	lw r10, (r11+-4)
+	lw r11, (r11+-8)
+	bi 2f
+
+1:/* already on kernel stack */
+
+	/* restore r9, r10 */
+	lw r9, (sp+0)
+	lw r10, (sp+-4)
+	/* no need to restore r11 as we did not use it */
+
+2:/* we now are on kernel stack and registers are untainted */
+
+  /* save registers */
+	addi  sp, sp, -128
+	sw    (sp + 120), ra
+	calli _save_syscall_frame
+
+	/* r7 always holds the pointer to struct pt_regs */
+	addi  r7, sp, 4
+
+#ifdef LM32_DEBUG_SYSCALL_CALL
+	/* call debug */
+	calli lm32_debug_syscall
+	/* restore caller saved registers */
+	lw    r1, (sp+8) 
+	lw    r2, (sp+12) 
+	lw    r3, (sp+16) 
+	lw    r4, (sp+20) 
+	lw    r5, (sp+24) 
+	lw    r6, (sp+28) 
+	addi  r7, sp, 4
+	lw    r8, (sp+36) 
+	lw    r9, (sp+40) 
+	lw    r10,(sp+44)
+	lw    ra, (sp+120)
+	/* end debug */
+#endif
+
+	/* r8 always holds the syscall number */
+	/* check if syscall number is valid */
+	mvi r9, __NR_syscall
+	bgeu r8, r9, .badsyscall
+	mvhi r9, hi(_sys_call_table) /* load address of syscall table */
+	ori r9, r9, lo(_sys_call_table)
+	sli r10, r8, 2 /* TODO: only works with shifter enabled */
+	add r9, r9, r10 /* add offset of syscall no to address */
+	lw r9, (r9+0) /* fetch address of syscall function */
+	call r9 /* execute syscall */
+
+.syscallTail:
+	/* store pt_regs* in r2 */
+	addi      r2,  sp, 4
+	calli manage_signals
+	sw (sp+8), r1 /* store return value into pt_regs */
+
+#ifdef LM32_DEBUG_SYSCALL_RET
+	/* debug syscall return value */
+	lw r2,  (sp+36) /* get saved syscall no from sp+36 for debug */
+	addi  r3, sp, 4
+	calli lm32_debug_syscall_ret /* debug */
+#endif
+
+	bi      _restore_and_return_exception
+
+.badsyscall:
+#ifdef LM32_DEBUG_SYSCALL_RET
+	mvi r1, -ENOSYS
+	mv r2, r8
+	addi  r3, sp, 4
+	calli lm32_debug_syscall_ret
+#endif
+	mvi r1, -ENOSYS
+
+	bi      _restore_and_return_exception
+
+/* end of exception handlers */
+
+
+/********************************/
+/* ensure to be on kernel stack */
+/********************************/
+#define ENSURE_TO_BE_ON_KERNEL_STACK \
+	/* store away r9,r10 so that we can use it here TODO: use clobbered ones*/ \
+	sw (sp+-4), r9; /* needed for various */ \
+	sw (sp+-8), r10; /* needed for current = current_thread_info()->task */ \
+	sw (sp+-12), r11; /* needed for user stack pointer, if switching */ \
+	/* test if already on kernel stack: test current_thread_info->task->which_stack */ \
+	mvhi r9, hi(lm32_current_thread); \
+	ori r9, r9, lo(lm32_current_thread); \
+	lw r9, (r9+0); /* dereference lm32_current_thread */ \
+	lw r10, (r9+TI_TASK); /* load pointer to task */ \
+	lw r9, (r10+TASK_WHICH_STACK); \
+	be r9, r0, 1f; \
+	/* we are on user stack, have to switch */ \
+	mv r11, sp; /* remember sp for restoring r9, r10, r11 */ \
+	sw (r10+TASK_USP), sp; /* store usp */ \
+	lw sp, (r10+TASK_KSP); /* load ksp */ \
+	sw (r10+TASK_WHICH_STACK), r0; /* set which_stack to 0 */ \
+	/* restore r9, r10, r11 */ \
+	lw r9, (r11+-4); \
+	lw r10, (r11+-8); \
+	lw r11, (r11+-12); \
+	bi 2f; \
+1:/* already on kernel stack */ \
+	/* restore r9, r10 */ \
+	lw r9, (sp+0); \
+	lw r10, (sp+-4); \
+	/* no need to restore r11 as we did not use it */ \
+2:/* now for sure on kernel stack */
+
+_long_breakpoint_handler:
+	ENSURE_TO_BE_ON_KERNEL_STACK; \
+	addi	sp,sp,-128; \
+	calli	_save_syscall_frame; \
+	mvi		r1, 32; /* 32 = breakpoint magic offset */ \
+	addi	r2, sp, 4; \
+	calli	asm_do_sig; \
+	bi		_return_from_debug_exception
+
+/**************************/
+/* exception return paths */
+/**************************/
+
+#ifdef LM32_DEBUG_SYSCALL_RET
+#define EXCEPTION_RETURN_PATH_DEBUG \
+	/* debug syscall return value */ \
+	mvi r2, 0; \
+	addi  r3, sp, 4; \
+	calli lm32_debug_syscall_ret; /* debug */
+#else
+#define EXCEPTION_RETURN_PATH_DEBUG
+#endif
+
+/* return path for debug or non-debug exceptions */
+#define EXCEPTION_RETURN_PATH(label, branch_to) \
+label: \
+	/* store pt_regs* in r2 */ \
+	addi      r2,  sp, 4; \
+	/* store 0 into r8 (syscall no) in pt_regs */ \
+	sw (sp+36), r0; \
+	calli manage_signals; \
+	sw (sp+8), r1; /* store return value into pt_regs */ \
+	EXCEPTION_RETURN_PATH_DEBUG \
+	bi branch_to
+
+EXCEPTION_RETURN_PATH(_return_from_exception, _restore_and_return_exception)
+
+EXCEPTION_RETURN_PATH(_return_from_debug_exception, _restore_and_return_debug_exception)
+
+/* ret_from_fork(unused, arg2, arg3, arg1, continuation) */
+/* calls schedule_tail and then manage_signals */
+/* returns to continuation(arg1, arg2, arg3) */
+ENTRY(ret_from_fork)
+	addi	sp, sp, -16
+	sw	(sp + 4), r2
+	sw	(sp + 8), r3
+	sw	(sp + 12), r4
+	sw	(sp + 16), r5
+	calli	schedule_tail
+	lw	r1, (sp + 12)
+	mv	r2, r0
+	/* calli manage_signals TODO reactivate */
+	lw	r2, (sp + 4)
+	lw	r3, (sp + 8)
+	lw	ra, (sp + 16)
+	addi	sp, sp, 16
+	ret
+
+ENTRY(sys_fork)
+	mvi r0, -EINVAL
+	ret
+
+ENTRY(sys_execve_wrapper)
+	/* save ra to stack */
+	addi sp,sp,-4
+	sw (sp+4), ra
+	/* store regs into 4th argument */
+	mv r4, r7
+	calli sys_execve
+	/* load ra from stack */
+	lw ra, (sp+4)
+	addi sp,sp,4
+	ret
+
+ENTRY(sys_rt_sigsuspend_wrapper)
+	/* save ra to kernel stack */
+	addi sp,sp,-4
+	sw (sp+4), ra
+	/* store regs into 3rd argument */
+	mv r3, r7
+	calli sys_rt_sigsuspend
+	/* load ra from kernel stack */
+	lw ra, (sp+4)
+	addi sp,sp,4
+	ret
+
+ENTRY(sys_vfork_wrapper)
+	/* save ra to kernel stack */
+	addi sp,sp,-4
+	sw (sp+4), ra
+	/* store regs into 1st argument */
+	mv r1, r7
+	/* store ra into 2nd argument */
+	mv r2, ra
+	calli sys_lm32_vfork
+	/* load ra from kernel stack */
+	lw ra, (sp+4)
+	addi sp,sp,4
+	ret
+
+/* purpose of this wrapper: put struct pt_regs* into first argument */
+ENTRY(sys_sigreturn_wrapper)
+	/* save ra to stack */
+	addi sp,sp,-4
+	sw (sp+4), ra
+	/* fix first argument */
+	mv r1, r7
+	calli sys_sigreturn
+	/* load ra from stack */
+	lw ra, (sp+4)
+	addi sp,sp,4
+	ret
+
+ENTRY(sys_clone_wrapper)
+	/* save ra to stack */
+	addi sp,sp,-4
+	sw (sp+4), ra
+	/* store ra into 5th argument */
+	mv r5, ra
+	calli sys_lm32_clone
+	/* load ra from stack */
+	lw ra, (sp+4)
+	addi sp,sp,4
+	ret
+
+/* in IRQ we call a function between save and restore */
+/* we therefore only save and restore the caller saved registers */
+/* (r1-r10, ra, ea because an interrupt could interrupt another one) */
+_save_irq_frame:
+	sw      (sp+8),   r1
+	sw      (sp+12),  r2
+	sw      (sp+16),  r3
+	sw      (sp+20),  r4
+	sw      (sp+24),  r5
+	sw      (sp+28),  r6
+	sw      (sp+32),  r7
+	sw      (sp+36),  r8
+	sw      (sp+40),  r9
+	sw      (sp+44),  r10
+	/* ra (sp + 120) has already been written */
+	sw      (sp+124), ea
+	ret
+
+/* restore all caller saved registers saved in _save_irq_frame and return from exception */
+_restore_irq_frame_and_return:
+	lw      r1,  (sp+8);
+	lw      r2,  (sp+12);
+	lw      r3,  (sp+16);
+	lw      r4,  (sp+20);
+	lw      r5,  (sp+24);
+	lw      r6,  (sp+28);
+	lw      r7,  (sp+32);
+	lw      r8,  (sp+36);
+	lw      r9,  (sp+40);
+	lw      r10, (sp+44);
+	lw      ra,  (sp+120)
+	lw      ea,  (sp+124)
+	addi    sp, sp, 128
+	eret
+
+_save_syscall_frame:
+	sw      (sp+4),   r0
+	sw      (sp+8),   r1
+	sw      (sp+12),  r2
+	sw      (sp+16),  r3
+	sw      (sp+20),  r4
+	sw      (sp+24),  r5
+	sw      (sp+28),  r6
+	sw      (sp+32),  r7
+	sw      (sp+36),  r8
+	sw      (sp+40),  r9
+	sw      (sp+44),  r10
+	sw      (sp+48),  r11
+	sw      (sp+52),  r12
+	sw      (sp+56),  r13
+	sw      (sp+60),  r14
+	sw      (sp+64),  r15
+	sw      (sp+68),  r16
+	sw      (sp+72),  r17
+	sw      (sp+76),  r18
+	sw      (sp+80),  r19
+	sw      (sp+84),  r20
+	sw      (sp+88),  r21
+	sw      (sp+92),  r22
+	sw      (sp+96),  r23
+	sw      (sp+100), r24
+	sw      (sp+104), r25
+	sw      (sp+108), r26
+	sw      (sp+112), r27
+	addi     r7, sp, 128 /* we could store usp here */
+	sw      (sp+116), r7
+	/* ra (sp + 120) has already been written */
+	sw      (sp+124), ea
+	sw      (sp+128), ba
+	ret
+
+/************************/
+/* syscall return paths */
+/************************/
+
+
+#ifdef LM32_BREAK_ON_SYSCALL
+#define RETURN_FROM_SYSCALL_OR_EXCEPTION_BREAK \
+	mvi ra, LM32_BREAK_ON_SYSCALL; /* only break in this syscall no */ \
+	bne ra, r8, 1f; \
+	break; \
+1:
+#else
+#define RETURN_FROM_SYSCALL_OR_EXCEPTION_BREAK
+#endif
+
+/* Restore all registers from syscall */
+/* all interrupts are disabled upon entry */
+/* we are on the kernel stack upon entry */
+
+#define RETURN_FROM_SYSCALL_OR_EXCEPTION(label, addr_register, return_instr) \
+label: \
+	/* prepare switch to user stack but keep kernel stack pointer in r11 */ \
+	/* r9: scratch register */ \
+	/* r10: current = current_thread_info()->task */ \
+	/* r11: ksp backup */ \
+	/* setup r10 = current */ \
+	mvhi r9, hi(lm32_current_thread); \
+	ori r9, r9, lo(lm32_current_thread); \
+	lw r9, (r9+0); /* dereference lm32_current_thread */ \
+	lw r10, (r9+TI_TASK); /* load pointer to task */ \
+	/* set task->thread.which_stack to 1 (user stack) */ \
+	mvi r9, 1; \
+	sw (r10+TASK_WHICH_STACK), r9; \
+	/* store ksp (after restore of frame) into task->thread.ksp */ \
+	addi r9, sp, 128; \
+	sw (r10+TASK_KSP), r9; \
+	/* save sp into r11 */ \
+	mv r11, sp; \
+	/* get usp into sp*/ \
+	lw  sp, (r10+TASK_USP); \
+	/* restore frame from original kernel stack */ \
+	/* restore r1 as the return value is stored onto the stack */ \
+	lw      r1,  (r11+8); \
+	lw      r2,  (r11+12); \
+	lw      r3,  (r11+16); \
+	lw      r4,  (r11+20); \
+	lw      r5,  (r11+24); \
+	lw      r6,  (r11+28); \
+	lw      r7,  (r11+32); \
+	lw      r8,  (r11+36); \
+	lw      r9,  (r11+40); \
+	lw      r10, (r11+44); \
+	/* skip r11 */; \
+	lw      r12, (r11+52); \
+	lw      r13, (r11+56); \
+	lw      r14, (r11+60); \
+	lw      r15, (r11+64); \
+	lw      r16, (r11+68); \
+	lw      r17, (r11+72); \
+	lw      r18, (r11+76); \
+	lw      r19, (r11+80); \
+	lw      r20, (r11+84); \
+	lw      r21, (r11+88); \
+	lw      r22, (r11+92); \
+	lw      r23, (r11+96); \
+	lw      r24, (r11+100); \
+	lw      r25, (r11+104); \
+	lw      r26, (r11+108); \
+	lw      r27, (r11+112); \
+	/* skip sp as it was retrieved from TASK_USP */ \
+	RETURN_FROM_SYSCALL_OR_EXCEPTION_BREAK \
+	lw      ra,  (r11+120); \
+	lw      ea,  (r11+124); \
+	lw      ba,  (r11+128); \
+	/* r11 must be restored last */ \
+	lw      r11,  (r11+48); \
+	/* scall stores pc into ea/ba register, not pc+4, so we have to add 4 */ \
+	addi	addr_register, addr_register, 4; \
+	return_instr
+
+RETURN_FROM_SYSCALL_OR_EXCEPTION(_restore_and_return_exception,ea,eret)
+
+/* also use "ea" here because "ba" should not be changed! */
+RETURN_FROM_SYSCALL_OR_EXCEPTION(_restore_and_return_debug_exception,ea,bret)
+
+/*
+ * struct task_struct* resume(struct task_struct* prev, struct task_struct* next)
+ * Returns the previous task
+ */
+ENTRY(resume)
+	/* store whole state to current stack (may be usp or ksp) */
+	addi sp, sp, -128
+	sw  (sp+4),   r0
+	sw  (sp+8),   r1
+	sw  (sp+12),  r2
+	sw  (sp+16),  r3
+	sw  (sp+20),  r4
+	sw  (sp+24),  r5
+	sw  (sp+28),  r6
+	sw  (sp+32),  r7
+	sw  (sp+36),  r8
+	sw  (sp+40),  r9
+	sw  (sp+44),  r10
+	sw  (sp+48),  r11
+	sw  (sp+52),  r12
+	sw  (sp+56),  r13
+	sw  (sp+60),  r14
+	sw  (sp+64),  r15
+	sw  (sp+68),  r16
+	sw  (sp+72),  r17
+	sw  (sp+76),  r18
+	sw  (sp+80),  r19
+	sw  (sp+84),  r20
+	sw  (sp+88),  r21
+	sw  (sp+92),  r22
+	sw  (sp+96),  r23
+	sw  (sp+100), r24
+	sw  (sp+104), r25
+	sw  (sp+108), r26
+	sw  (sp+112), r27
+	addi r3, sp, 128 /* special case for stack pointer */
+	sw  (sp+116), r3 /* special case for stack pointer */
+	sw	(sp+120), ra
+//	sw  (sp+124), ea
+//	sw  (sp+128), ba
+
+	/* find out whether we are on kernel or user stack */
+	lw  r3, (r1 + TASK_WHICH_STACK)
+	be  r3, r0, 1f
+
+	/* we are on user stack */
+	sw  (r1 + TASK_USP), sp
+	bi 2f
+
+1:/* we are on kernel stack */
+	sw  (r1 + TASK_KSP), sp
+
+2:/* we have stored stack pointer of prev */
+
+  /* restore next */
+
+	/* find out whether we will be on kernel or user stack */
+	lw  r3, (r2 + TASK_WHICH_STACK)
+	be  r3, r0, 3f
+
+	/* we need user stack */
+	lw  sp, (r2 + TASK_USP)
+	bi 4f
+
+3:/* we need kernel stack */
+	lw  sp, (r2 + TASK_KSP)
+
+4:/* we have restored sp of next */
+
+	/* setup return value */
+	mv	r1, r2
+
+	lw  r2,  (sp+12)
+	lw  r3,  (sp+16)
+	lw  r4,  (sp+20)
+	lw  r5,  (sp+24)
+	lw  r6,  (sp+28)
+	lw  r7,  (sp+32)
+	lw  r8,  (sp+36)
+	lw  r9,  (sp+40)
+	lw  r10, (sp+44)
+	lw  r11, (sp+48)
+	lw  r12, (sp+52)
+	lw  r13, (sp+56)
+	lw  r14, (sp+60)
+	lw  r15, (sp+64)
+	lw  r16, (sp+68)
+	lw  r17, (sp+72)
+	lw  r18, (sp+76)
+	lw  r19, (sp+80)
+	lw  r20, (sp+84)
+	lw  r21, (sp+88)
+	lw  r22, (sp+92)
+	lw  r23, (sp+96)
+	lw  r24, (sp+100)
+	lw  r25, (sp+104)
+	lw  r26, (sp+108)
+	lw  r27, (sp+112)
+	/* skip sp for now */
+	lw  ra,  (sp+120)
+//	lw  ea,  (sp+124)
+//	lw  ba,  (sp+128)
+	/* Stack pointer must be restored last --- it will be updated */
+	lw  sp,  (sp+116)
+
+	ret
+
+/* extern asmlinkage void break_label(void); */
+ENTRY(break_label)
+	break
+
+.align 4
+ENTRY(_sys_call_table)
+	.long sys_ni_syscall	/* 0  -  old "setup()" system call*/
+	.long sys_exit
+	.long sys_fork
+	.long sys_read
+	.long sys_write
+	.long sys_open		/* 5 */
+	.long sys_close
+	.long sys_ni_syscall	/* old waitpid */
+	.long sys_creat
+	.long sys_link
+	.long sys_unlink	/* 10 */
+	.long sys_execve_wrapper
+	.long sys_chdir
+	.long sys_time
+	.long sys_mknod
+	.long sys_chmod		/* 15 */
+	.long sys_chown	/* chown16 */
+	.long sys_ni_syscall	/* old break syscall holder */
+	.long sys_ni_syscall	/* old stat */
+	.long sys_lseek
+	.long sys_getpid	/* 20 */
+	.long sys_mount
+	.long sys_ni_syscall	/* old umount */
+	.long sys_setuid
+	.long sys_getuid
+	.long sys_stime		/* 25 */
+	.long sys_ptrace
+	.long sys_alarm
+	.long sys_ni_syscall	/* old fstat */
+	.long sys_pause
+	.long sys_ni_syscall	/* old utime */ /* 30 */
+	.long sys_ni_syscall	/* old stty syscall holder */
+	.long sys_ni_syscall	/* old gtty syscall holder */
+	.long sys_access
+	.long sys_nice
+	.long sys_ni_syscall	/* 35 */ /* old ftime syscall holder */
+	.long sys_sync
+	.long sys_kill
+	.long sys_rename
+	.long sys_mkdir
+	.long sys_rmdir		/* 40 */
+	.long sys_dup
+	.long sys_pipe
+	.long sys_times
+	.long sys_ni_syscall	/* old prof syscall holder */
+	.long sys_brk		/* 45 */
+	.long sys_setgid
+	.long sys_getgid
+	.long sys_signal
+	.long sys_geteuid	/* geteuid16 */
+	.long sys_getegid	/* getegid16 */	/* 50 */
+	.long sys_ni_syscall /* sys_acct */
+	.long sys_umount	/* recycled never used phys() */
+	.long sys_ni_syscall	/* old lock syscall holder */
+	.long sys_ioctl
+	.long sys_fcntl		/* 55 */
+	.long sys_ni_syscall	/* old mpx syscall holder */
+	.long sys_setpgid
+	.long sys_ni_syscall	/* old ulimit syscall holder */
+	.long sys_ni_syscall	/* old old uname */
+	.long sys_umask		/* 60 */
+	.long sys_chroot
+	.long sys_ustat
+	.long sys_dup2
+	.long sys_getppid
+	.long sys_getpgrp	/* 65 */
+	.long sys_setsid
+	.long sys_sigaction
+	.long sys_sgetmask
+	.long sys_ssetmask
+	.long sys_setreuid	/* setreuid16 */	/* 70 */
+	.long sys_setregid	/* setregid16 */
+	.long sys_ni_syscall /* old sys_sigsuspend */
+	.long sys_sigpending
+	.long sys_sethostname
+	.long sys_setrlimit	/* 75 */
+	.long sys_ni_syscall	/* old getrlimit */
+	.long sys_getrusage
+	.long sys_gettimeofday
+	.long sys_settimeofday
+	.long sys_getgroups	/* getgroups16 */	/* 80 */
+	.long sys_setgroups	/* setgroups16 */
+	.long sys_select	/* backwards compatibility */
+	.long sys_symlink
+	.long sys_ni_syscall	/* old lstat */
+	.long sys_readlink	/* 85 */
+	.long sys_uselib
+	.long sys_ni_syscall	/* sys_swapon */
+	.long sys_reboot
+	.long sys_ni_syscall	/* old_readdir */
+	.long sys_ni_syscall	/* sys_mmap */	/* 90 */
+	.long sys_munmap
+	.long sys_truncate
+	.long sys_ftruncate
+	.long sys_fchmod
+	.long sys_fchown	/* fchown16 */	/* 95 */
+	.long sys_getpriority
+	.long sys_setpriority
+	.long sys_ni_syscall	/* old profil syscall holder */
+	.long sys_statfs
+	.long sys_fstatfs	/* 100 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* old sys_socketcall */
+	.long sys_syslog
+	.long sys_setitimer
+	.long sys_getitimer	/* 105 */
+	.long sys_newstat
+	.long sys_newlstat
+	.long sys_newfstat
+	.long sys_ni_syscall	/* old uname */
+	.long sys_ni_syscall	/* iopl for i386 */ /* 110 */
+	.long sys_vhangup
+	.long sys_ni_syscall	/* obsolete idle() syscall */
+	.long sys_ni_syscall	/* vm86old for i386 */
+	.long sys_wait4
+	.long sys_ni_syscall	/* 115 */ /* sys_swapoff */
+	.long sys_sysinfo
+	.long sys_ni_syscall	/* old sys_ipc */
+	.long sys_fsync
+	.long sys_sigreturn_wrapper
+	.long sys_clone_wrapper		/* 120 */
+	.long sys_setdomainname
+	.long sys_newuname
+	.long sys_ni_syscall	/* old sys_modify_ldt */
+	.long sys_adjtimex
+	.long sys_ni_syscall	/* 125 */ /* sys_mprotect */
+	.long sys_ni_syscall	/* old sys_sigprocmask */
+	.long sys_ni_syscall	/* old "creat_module" */
+	.long sys_init_module
+	.long sys_delete_module
+	.long sys_ni_syscall	/* 130: old "get_kernel_syms" */
+	.long sys_ni_syscall /* sys_quotactl */
+	.long sys_getpgid
+	.long sys_fchdir
+	.long sys_bdflush
+	.long sys_ni_syscall	/* 135 */ /* sys_sysfs */
+	.long sys_personality
+	.long sys_ni_syscall	/* for afs_syscall */
+	.long sys_setfsuid	/* setfsuid16 */
+	.long sys_setfsgid	/* setfsgid16 */
+	.long sys_llseek	/* 140 */
+	.long sys_getdents
+	.long sys_select	/* backwards compatibility */
+	.long sys_flock
+	.long sys_ni_syscall	/* sys_msync */
+	.long sys_readv		/* 145 */
+	.long sys_writev
+	.long sys_getsid
+	.long sys_fdatasync
+	.long sys_sysctl
+	.long sys_ni_syscall	/* 150 */ /* sys_mlock */
+	.long sys_ni_syscall	/* sys_munlock */
+	.long sys_ni_syscall	/* sys_mlockall */
+	.long sys_ni_syscall	/* sys_munlockall */
+	.long sys_sched_setparam
+	.long sys_sched_getparam /* 155 */
+	.long sys_sched_setscheduler
+	.long sys_sched_getscheduler
+	.long sys_sched_yield
+	.long sys_sched_get_priority_max
+	.long sys_sched_get_priority_min  /* 160 */
+	.long sys_sched_rr_get_interval
+	.long sys_nanosleep
+	.long sys_ni_syscall	/* sys_mremap */
+	.long sys_setresuid	/* setresuid16 */
+	.long sys_getresuid	/* getresuid16 */	/* 165 */
+	.long sys_ni_syscall	/* for vm86 */
+	.long sys_ni_syscall	/* old "query_module" */
+	.long sys_ni_syscall	/* sys_poll */
+	.long sys_ni_syscall	/* sys_nfsservctl */
+	.long sys_setresgid	/* setresgid16 */	/* 170 */
+	.long sys_getresgid	/* getresgid16 */
+	.long sys_prctl
+	.long sys_ni_syscall /* sys_rt_sigreturn */
+	.long sys_rt_sigaction
+	.long sys_rt_sigprocmask /* 175 */
+	.long sys_rt_sigpending
+	.long sys_rt_sigtimedwait
+	.long sys_rt_sigqueueinfo
+	.long sys_rt_sigsuspend_wrapper
+	.long sys_pread64	/* 180 */
+	.long sys_pwrite64
+	.long sys_lchown	/* lchown16 */
+	.long sys_getcwd
+	.long sys_capget
+	.long sys_capset	/* 185 */
+	.long sys_sigaltstack
+	.long sys_sendfile
+	.long sys_ni_syscall	/* streams1 */
+	.long sys_ni_syscall	/* streams2 */
+	.long sys_vfork_wrapper		/* 190 */
+	.long sys_getrlimit
+  .long sys_mmap2
+	.long sys_truncate64
+	.long sys_ftruncate64
+	.long sys_stat64	/* 195 */
+	.long sys_lstat64
+	.long sys_fstat64
+	.long sys_chown
+	.long sys_getuid
+	.long sys_getgid	/* 200 */
+	.long sys_geteuid
+	.long sys_getegid
+	.long sys_setreuid
+	.long sys_setregid
+	.long sys_getgroups	/* 205 */
+	.long sys_setgroups
+	.long sys_fchown
+	.long sys_setresuid
+	.long sys_getresuid
+	.long sys_setresgid	/* 210 */
+	.long sys_getresgid
+	.long sys_lchown
+	.long sys_setuid
+	.long sys_setgid
+	.long sys_setfsuid	/* 215 */
+	.long sys_setfsgid
+	.long sys_pivot_root
+	.long sys_ni_syscall	/* sys_mincore */
+	.long sys_ni_syscall	/* sys_madvise */
+	.long sys_getdents64	/* 220 */
+	.long sys_fcntl64
+	.long sys_ni_syscall	/* reserved for TUX */
+	.long sys_ni_syscall
+	.long sys_gettid
+	.long sys_ni_syscall	/* 225 */ /* sys_readahead */
+	.long sys_setxattr
+	.long sys_lsetxattr
+	.long sys_fsetxattr
+	.long sys_getxattr
+	.long sys_lgetxattr	/* 230 */
+	.long sys_fgetxattr
+	.long sys_listxattr
+	.long sys_llistxattr
+	.long sys_flistxattr
+	.long sys_removexattr	/* 235 */
+	.long sys_lremovexattr
+	.long sys_fremovexattr
+	.long sys_tkill
+	.long sys_sendfile64
+	.long sys_futex		/* 240 */
+	.long sys_sched_setaffinity
+	.long sys_sched_getaffinity
+	.long sys_ni_syscall	/* sys_set_thread_area */
+	.long sys_ni_syscall	/* sys_get_thread_area */
+	.long sys_io_setup	/* 245 */
+	.long sys_io_destroy
+	.long sys_io_getevents
+	.long sys_io_submit
+	.long sys_io_cancel
+	.long sys_ni_syscall	/* 250 */ /* sys_alloc_hugepages */
+	.long sys_ni_syscall	/* sys_freec_hugepages */
+	.long sys_exit_group
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall /* 255 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall /* remap_file_pages */
+	.long sys_set_tid_address
+	.long sys_timer_create	/* 260 */
+	.long sys_timer_settime
+	.long sys_timer_gettime
+	.long sys_timer_getoverrun
+	.long sys_timer_delete
+	.long sys_clock_settime /* 265 */
+	.long sys_clock_gettime
+	.long sys_clock_getres
+	.long sys_clock_nanosleep
+	.long sys_statfs64
+	.long sys_fstatfs64	/* 270 */
+	.long sys_tgkill
+	.long sys_utimes
+	.long sys_fadvise64_64
+	.long sys_ni_syscall /* vserver */
+	.long sys_ni_syscall /* 275, mbind */
+	.long sys_ni_syscall /* get_mempolicy */
+	.long sys_ni_syscall /* set_mempolicy */
+	.long sys_ni_syscall /* mq */
+	.long sys_ni_syscall /* mq */
+	.long sys_ni_syscall /* 280 */ /* mq */
+	.long sys_ni_syscall /* mq */
+	.long sys_ni_syscall /* mq */
+	.long sys_ni_syscall /* mq */
+	.long sys_ni_syscall /* kexec_load */
+	.long sys_waitid	/* 285 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ioprio_set
+	.long sys_ioprio_get	/* 290 */
+	.long sys_ni_syscall /* inotify */
+	.long sys_ni_syscall /* inotify */
+	.long sys_ni_syscall /* inotify */
+	.long sys_ni_syscall /* migrate_pages */
+	.long sys_openat	/* 295 */
+	.long sys_mkdirat
+	.long sys_mknodat
+	.long sys_fchownat
+	.long sys_futimesat
+	.long sys_fstatat64	/* 300 */
+	.long sys_unlinkat
+	.long sys_renameat
+	.long sys_linkat
+	.long sys_symlinkat
+	.long sys_readlinkat	/* 305 */
+	.long sys_fchmodat
+	.long sys_faccessat
+	.long sys_ni_syscall /* sys_pselect6 */
+	.long sys_ni_syscall /* sys_ppoll */
+	.long sys_unshare	/* 310 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_accept
+	.long sys_bind		/* 315 */
+	.long sys_connect
+	.long sys_getpeername
+	.long sys_getsockname
+	.long sys_getsockopt
+	.long sys_listen	/* 320 */
+	.long sys_recv
+	.long sys_recvfrom
+	.long sys_recvmsg
+	.long sys_send
+	.long sys_sendmsg	/* 325 */
+	.long sys_sendto
+	.long sys_setsockopt
+	.long sys_shutdown
+	.long sys_socket
+	.long sys_socketpair	/* 330 */
+	.long sys_splice
+	.long sys_sync_file_range2
+	.long sys_tee
+	.long sys_vmsplice
+	.long sys_getcpu  /* 335 */
+	.rept NR_syscalls-(.-_sys_call_table)/4
+	.long sys_ni_syscall
+	.endr
diff --git a/arch/lm32/kernel/head.S b/arch/lm32/kernel/head.S
new file mode 100644
index 0000000..e461e68
--- /dev/null
+++ b/arch/lm32/kernel/head.S
@@ -0,0 +1,111 @@
+/*
+ *  linux/arch/arm/kernel/head.S
+ *
+ *  Copyright (c) 2007 Theobroma Systems.
+ *  All Rights Reserved
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  Kernel startup code for the Lattice Mico 32 architecture
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <linux/threads.h>
+
+#include <asm/ptrace.h>
+#include <asm/asm-offsets.h>
+#include <asm/thread_info.h>
+#include <asm/system.h>
+
+/*
+ * Kernel startup entry point.
+ * ---------------------------
+ *
+ * This is normally called from the decompressor code or boot-loader.
+ * The requirements are: 
+ *   r1 = hardware parameters (list of structs from hwsetup_kernel.h)
+ *   r2 = kernel commandline (zero terminated)
+ *   r3 = initrd start
+ *   r4 = initrd end
+ *
+ * We currently clobber r23, r24 and r25
+ *
+ * Note: This code is not (yet) position-independent (position
+ * 	 independence will require some additional magic to
+ *       correct the __bss_start, _end and _init_thread_union
+ *       addresses).
+ */
+
+	.section ".text.head"
+	.type stext, %function
+ENTRY(stext)
+	xor	r0, r0, r0	/* make sure that r0 is set to 0. */
+	wcsr IE, r0 /* disable interrupts */
+	wcsr IM, r0 /* disable each maskable interrupt */
+	calli	setup_stack
+	calli	clear_bss
+	calli save_args
+	calli	setup_exception_vectors
+	calli	start_kernel
+	/* should never get here */
+hang:
+	be	r0, r0, hang		/* how did we get here? */
+
+save_args:
+	/* TODO: make this PIC */
+	mvhi	r23, hi(_kernel_arg_cmdline)
+	ori	r23, r23, lo(_kernel_arg_cmdline)
+	sw (r23+0), r1 /* store commandline parameter into _kernel_arg_cmdline */
+	/* store initrd parameters */
+	mvhi	r23, hi(_kernel_arg_initrd_start)
+	ori	r23, r23, lo(_kernel_arg_initrd_start)
+	sw (r23+0), r2
+	mvhi	r23, hi(_kernel_arg_initrd_end)
+	ori	r23, r23, lo(_kernel_arg_initrd_end)
+	sw (r23+0), r3
+	ret
+	
+setup_exception_vectors:
+	/* TODO: implement me */
+	/* TODO: irq handler has to call asm_do_IRQ */
+	/* activate watchpoint on write to address 0 */
+	wcsr WP0, r0
+	rcsr r23, DC
+	ori r23, r23, 0x8
+	/*wcsr DC, r23*/
+	/*mvhi r23, 0x1000*/
+	/*wcsr DEBA, r23*/
+	ret
+
+clear_bss:
+	addi	sp, sp, -8
+	mv	r25, ra
+	calli	clear_bss_1
+
+	.global	__bss_start
+	.word	__bss_start
+	.global	_end
+	.word	_end
+clear_bss_1:
+	lw	r23, (ra + 0)   	/* load _bss_start */
+	lw	r24, (ra + 4)		/* load _end */
+	/* TODO: correct the BSS addresses for position independence */
+clear_bss_2:					
+	sw	(r23 + 0), r0
+	addi	r23, r23, 4
+	bgu	r24, r23, clear_bss_2
+
+	mv	ra, r25
+	ret
+
+setup_stack:
+	/* TODO: make this PIC */
+	mvhi	r23, hi(init_thread_union)
+	ori	r23, r23, lo(init_thread_union)
+	mvi	sp, THREAD_SIZE - 32
+	add	sp, sp, r23
+	/* init the stack pointer */
+	addi	sp, sp, -32 /* SZREGS */
+	ret
diff --git a/arch/lm32/kernel/init_task.c b/arch/lm32/kernel/init_task.c
new file mode 100644
index 0000000..90f68ca
--- /dev/null
+++ b/arch/lm32/kernel/init_task.c
@@ -0,0 +1,69 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on
+ *
+ * linux/arch/arm/kernel/init_task.c
+ */
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/init_task.h>
+#include <linux/mqueue.h>
+
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+
+static struct fs_struct init_fs = INIT_FS;
+static struct files_struct init_files = INIT_FILES;
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
+struct mm_struct init_mm = INIT_MM(init_mm);
+
+EXPORT_SYMBOL(init_mm);
+
+/*
+ * Initial thread structure.
+ *
+ * We need to make sure that this is 8192-byte aligned due to the
+ * way process stacks are handled. This is done by making sure
+ * the linker maps this in the .text segment right after head.S,
+ * and making head.S ensure the proper alignment.
+ *
+ * The things we do for performance..
+ */
+union thread_union init_thread_union
+	__attribute__((__section__(".data.init_task"))) =
+		{ INIT_THREAD_INFO(init_task) };
+
+/*
+ * Initial task structure.
+ *
+ * All other task structs will be allocated on slabs in fork.c
+ */
+struct task_struct init_task = INIT_TASK(init_task);
+
+EXPORT_SYMBOL(init_task);
diff --git a/arch/lm32/kernel/irq.c b/arch/lm32/kernel/irq.c
new file mode 100644
index 0000000..5ec793f
--- /dev/null
+++ b/arch/lm32/kernel/irq.c
@@ -0,0 +1,219 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/errno.h>
+#include <linux/seq_file.h>
+
+unsigned long irq_err_count;
+/* this is the current mask in IM */
+static unsigned long lm32_current_irq_mask = 0;
+
+/*
+ * NOP IRQ functions
+ */
+static void noop(unsigned int irq)
+{
+}
+
+static unsigned int noop_ret(unsigned int irq)
+{
+	return 0;
+}
+
+void lm32_irq_mask(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned long mask = ~(1 << irq);
+
+	local_irq_save(flags);
+
+	mask &= lm32_current_irq_mask;
+	lm32_current_irq_mask = mask;
+
+	/*
+	 * set mask
+	 */
+	asm volatile ("wcsr IM, %0" : : "r"(mask));
+
+	local_irq_restore(flags);
+}
+
+void lm32_irq_unmask(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned long mask = (1 << irq);
+
+	if( !(lm32_current_irq_mask & mask) ) {
+		local_irq_save(flags);
+
+		mask |= lm32_current_irq_mask;
+		lm32_current_irq_mask = mask;
+
+		/*
+		 * set mask
+		 */
+		asm volatile ("wcsr IM, %0" : : "r"(mask));
+
+		local_irq_restore(flags);
+	}
+}
+
+void lm32_irq_ack(unsigned int irq)
+{
+	unsigned long mask = 1 << irq;
+
+	/*
+	 * confirm irq
+	 */
+	asm volatile ("wcsr IP, %0" : : "r"(mask));
+}
+
+void lm32_irq_mask_ack(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned long mask = ~(1 << irq);
+	unsigned long ack = 1 << irq;
+
+	local_irq_save(flags);
+
+	mask &= lm32_current_irq_mask;
+	lm32_current_irq_mask = mask;
+
+	/*
+	 * set mask
+	 */
+	asm volatile ("wcsr IM, %0" : : "r"(mask));
+
+	/*
+	 * confirm irq
+	 */
+	asm volatile ("wcsr IP, %0" : : "r"(ack));
+
+	local_irq_restore(flags);
+}
+
+unsigned long lm32_irq_pending()
+{
+	unsigned long ret;
+
+	/*
+	 * read interrupt pending register
+	 */
+	asm volatile ("rcsr %0, IP" : "=r"(ret) : );
+
+	return ret;
+}
+
+/*
+ * LM32 IRQs implementation
+ */
+struct irq_chip lm32_internal_irq_chip = {
+	.name		= "LM32",
+	.startup	= noop_ret,
+	.shutdown	= noop,
+	.enable		= noop,
+	.disable	= lm32_irq_mask,
+	.ack		= lm32_irq_ack,
+	.mask		= lm32_irq_mask,
+	.unmask		= lm32_irq_unmask,
+	.mask_ack		= lm32_irq_mask_ack,
+	.end		= noop,
+};
+
+void __init init_IRQ(void)
+{
+	int irq;
+
+	local_irq_disable();
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &lm32_internal_irq_chip);
+		set_irq_handler(irq, handle_simple_irq);
+	}
+}
+
+int show_interrupts(struct seq_file *p, void *v)
+{
+	int i = *(loff_t *) v;
+	struct irqaction * action;
+	unsigned long flags;
+
+	if (i < NR_IRQS)
+	{
+		spin_lock_irqsave(&irq_desc[i].lock, flags);
+		action = irq_desc[i].action;
+		if( action )
+		{
+			seq_printf(p, "%3d: ", i);
+			seq_printf(p, "%10s ", irq_desc[i].chip->name ? : "-");
+			seq_printf(p, " %s", action->name);
+			for (action = action->next; action; action = action->next)
+				seq_printf(p, ", %s", action->name);
+			seq_putc(p, '\n');
+		}
+		spin_unlock_irqrestore(&irq_desc[i].lock, flags);
+	} else if (i == NR_IRQS) {
+		seq_printf(p, "Errors: %lu\n", irq_err_count);
+	}
+
+	return 0;
+}
+
+asmlinkage void manage_signals_irq(struct pt_regs* regs);
+
+/*
+ * do_IRQ handles all hardware IRQ's.  Decoded IRQs should not
+ * come via this function.  Instead, they should provide their
+ * own 'handler'
+ */
+asmlinkage void asm_do_IRQ(unsigned long vec, struct pt_regs *regs)
+{
+	struct pt_regs *old_regs;
+	unsigned int irq;
+	
+	old_regs = set_irq_regs(regs);
+
+	irq_enter();
+
+	/* decode irq */
+	for (irq=0 ; irq<32; ++irq ) {
+		if ( vec & (1 << irq) ) {
+			/* acknowledge */
+			lm32_irq_ack(irq);
+			generic_handle_irq(irq);
+		}
+	}
+
+	irq_exit();
+
+	set_irq_regs(old_regs);
+
+	manage_signals_irq(regs);
+}
diff --git a/arch/lm32/kernel/module.c b/arch/lm32/kernel/module.c
new file mode 100644
index 0000000..33b497d
--- /dev/null
+++ b/arch/lm32/kernel/module.c
@@ -0,0 +1,176 @@
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(fmt...)
+#endif
+
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+	/* FIXME: If module_region == mod->init_region, trim exception
+           table entries. */
+}
+
+/* We don't need anything special. */
+int module_frob_arch_sections(Elf_Ehdr *hdr,
+			      Elf_Shdr *sechdrs,
+			      char *secstrings,
+			      struct module *mod)
+{
+	return 0;
+}
+
+static 
+int relocate_at(int rtype, unsigned* insn_addr, unsigned target_addr);
+
+int apply_relocate(Elf32_Shdr *sechdrs,
+		   const char *strtab,
+		   unsigned int symindex,
+		   unsigned int relsec,
+		   struct module *me)
+{
+	unsigned int i;
+	Elf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location;
+
+	DEBUGP("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to.  Note that all
+		   undefined symbols have been resolved.  */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+			+ ELF32_R_SYM(rel[i].r_info);
+
+		if( -1 == relocate_at(
+					ELF32_R_TYPE(rel[i].r_info),
+					location,
+					sym->st_value) )
+			return -ENOEXEC;
+	}
+	return 0;
+}
+
+int apply_relocate_add(Elf32_Shdr *sechdrs,
+		       const char *strtab,
+		       unsigned int symindex,
+		       unsigned int relsec,
+		       struct module *me)
+{
+	unsigned int i;
+	Elf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location;
+
+	DEBUGP("Applying relocate_add section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to.  Note that all
+		   undefined symbols have been resolved.  */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+			+ ELF32_R_SYM(rel[i].r_info);
+		DEBUGP("relocation at offset %lx: symbol %lx value %lx addend %lx\n",
+				rel[i].r_offset, ELF32_R_SYM(rel[i].r_info),
+				sym->st_value, rel[i].r_addend);
+
+		if( -1 == relocate_at(
+					ELF32_R_TYPE(rel[i].r_info),
+					location,
+					sym->st_value + rel[i].r_addend) )
+			return -ENOEXEC;
+	}
+	return 0;
+}
+
+int module_finalize(const Elf_Ehdr *hdr,
+		    const Elf_Shdr *sechdrs,
+		    struct module *me)
+{
+	return 0;
+}
+
+void module_arch_cleanup(struct module *mod)
+{
+}
+
+static 
+int relocate_at(int rtype, unsigned* insn_addr, unsigned target_addr)
+{
+  unsigned insn;
+  unsigned opcode;
+
+  switch (rtype) {
+  case R_LM32_32:
+    /* we can't really test whether the original data is an instruction
+       that could be relocated, so we simply overwrite the data that's
+       there */
+    //printk("R_LM32_32: overwriting 0x%08x with 0x%08x @ 0x%08x.\n", *insn_addr, target_addr, (unsigned)insn_addr);
+    *insn_addr = target_addr;
+    return 0; /* never fails */
+
+  case R_LM32_HI16:
+    /* the HI16 case is permitted on mvhi (orhi) instructions only! */
+    insn = *insn_addr;
+    if ((insn >> 26) == 0x1e) { /* the opcode for orhi is 6b'011110 (0x1e) */
+      insn &= 0xffff0000;
+      insn |= (target_addr >> 16);
+      *insn_addr = insn;
+      return 0;
+    }
+    //printk("insn word 0x%08x\n", insn);
+    break;
+
+  case R_LM32_LO16:
+    insn = *insn_addr;
+    if ((insn >> 26) == 0x0e) { /* the opcode for ori is 6b'001110 (0x0e) */
+      insn &= 0xffff0000;
+      insn |= (target_addr & 0xffff);
+      *insn_addr = insn;
+      return 0;
+    }
+    break;
+
+  case R_LM32_CALL:
+    insn = *insn_addr;
+    opcode = insn >> 26;
+    if( (opcode == 0x3e /* calli */) )
+		{
+			/* install a calli to the given target_addr relative from the instruction
+			 * address */
+			long imm26 = (target_addr - (long)insn_addr);
+			imm26 = (imm26 >> 2) & 0x03FFFFFF;
+			insn = 0xF8000000 + imm26;
+			*insn_addr = insn;
+      return 0;
+    }
+    break;
+
+  default:
+    printk("ignoring relocation type %d @ 0x%08x\n", rtype, *insn_addr);
+  }
+
+  return -1;
+}
+
diff --git a/arch/lm32/kernel/process.c b/arch/lm32/kernel/process.c
new file mode 100644
index 0000000..97a519c
--- /dev/null
+++ b/arch/lm32/kernel/process.c
@@ -0,0 +1,307 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file handles the architecture-dependent parts of process handling..
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/fs.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/traps.h>
+#include <asm/setup.h>
+#include <asm/pgtable.h>
+
+asmlinkage void ret_from_fork(void);
+
+
+struct thread_info* lm32_current_thread;
+
+/*
+ * The following aren't currently used.
+ */
+void (*pm_idle)(void);
+EXPORT_SYMBOL(pm_idle);
+
+void (*pm_power_off)(void);
+EXPORT_SYMBOL(pm_power_off);
+
+/*
+ * The idle loop on an LM32
+ */
+static void default_idle(void)
+{
+ 	while(!need_resched());
+}
+
+void (*idle)(void) = default_idle;
+
+/*
+ * The idle thread. There's no useful work to be
+ * done, so just try to conserve power and have a
+ * low exit latency (ie sit in a loop waiting for
+ * somebody to say that they'd like to reschedule)
+ */
+void cpu_idle(void)
+{
+	/* endless idle loop with no priority at all */
+	while (1) {
+		idle();
+		preempt_enable_no_resched();
+		schedule();
+		preempt_disable();
+	}
+}
+
+#define MMPTR(x) (*((volatile unsigned int *)(x)))
+#define CSR_SYSTEM_ID MMPTR(0x8000103c)
+
+void machine_restart(char * __unused)
+{
+	/* Writing to CSR_SYSTEM_ID causes a system reset */
+	CSR_SYSTEM_ID = 1;
+	while(1);
+}
+
+void machine_halt(void)
+{
+	printk("%s:%d: machine_halt() is not possible on lm32\n", __FILE__, __LINE__);
+	for (;;)
+		cpu_relax();
+}
+
+void machine_power_off(void)
+{
+	printk("%s:%d: machine_poweroff() is not possible on lm32\n", __FILE__, __LINE__);
+	for (;;)
+		cpu_relax();
+}
+
+void show_regs(struct pt_regs * regs)
+{
+	printk("Registers:\n");
+	#define LM32REG(name) printk("%3s : 0x%lx\n", #name, regs->name)
+	LM32REG(r0);  LM32REG(r1);  LM32REG(r2);  LM32REG(r3);  LM32REG(r4);
+	LM32REG(r5);  LM32REG(r6);  LM32REG(r7);  LM32REG(r8);  LM32REG(r9);
+	LM32REG(r10); LM32REG(r11); LM32REG(r12); LM32REG(r13); LM32REG(r14);
+	LM32REG(r15); LM32REG(r16); LM32REG(r17); LM32REG(r18); LM32REG(r19);
+	LM32REG(r20); LM32REG(r21); LM32REG(r22); LM32REG(r23); LM32REG(r24);
+	LM32REG(r25); LM32REG(gp);  LM32REG(fp);  LM32REG(sp);  LM32REG(ra);
+	LM32REG(ea);  LM32REG(ba);
+	#undef LM32REG
+}
+
+
+void kernel_thread_helper(int reserved, int (*fn)(void*), void* arg)
+{
+  /* Note: read copy_thread, kernel_thread and ret_from_fork to fully appreciate why the first argument is "reserved" */
+
+	do_exit(fn(arg));
+}
+
+/*
+ * Create a kernel thread
+ */
+int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
+{
+	/* prepare registers from which a child task switch frame will be copied */
+	struct pt_regs regs;
+
+	set_fs(KERNEL_DS);
+
+	memset(&regs, 0, sizeof(regs));
+
+	//printk("kernel_thread fn=%x arg=%x regs=%x\n", fn, arg, &regs);
+
+	regs.r2 = (unsigned long)fn;
+	regs.r3 = (unsigned long)arg;
+	regs.r5 = (unsigned long)kernel_thread_helper;
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+}
+
+void flush_thread(void)
+{
+	set_fs(USER_DS);
+}
+
+
+/*
+ * sys_execve() executes a new program.
+ */
+asmlinkage int sys_execve(char *name, char **argv, char **envp, struct pt_regs* regs)
+{
+	int error;
+	char * filename;
+
+	lock_kernel();
+	filename = getname(name);
+	error = PTR_ERR(filename);
+	if (IS_ERR(filename))
+		goto out;
+	error = do_execve(filename, argv, envp, regs);
+	putname(filename);
+out:
+	unlock_kernel();
+	return error;
+}
+
+/* no stack unwinding */
+unsigned long get_wchan(struct task_struct *p)
+{
+	return 0;
+}
+
+unsigned long thread_saved_pc(struct task_struct *tsk)
+{
+	return 0;
+}
+
+
+
+int copy_thread(int nr, unsigned long clone_flags,
+		unsigned long usp, unsigned long stk_size,
+		struct task_struct * p, struct pt_regs * regs)
+{
+	unsigned long child_tos = KSTK_TOS(p);
+	struct pt_regs *childregs;
+
+	if (regs->r5 == (unsigned long)kernel_thread_helper) {
+		/* kernel thread */
+
+		if( usp != 0 )
+			panic("trying to start kernel thread with usp != 0");
+
+		/* childregs = full task switch frame on kernel stack of child */
+		childregs = (struct pt_regs *)(child_tos) - 1;
+
+		*childregs = *regs;
+
+		childregs->r4 = 0; /* child gets zero as return value */
+		regs->r4 = p->pid; /* parent gets child pid as return value */ 
+
+		/* return via ret_from_fork */
+		childregs->ra = (unsigned long)ret_from_fork;
+
+		/* setup ksp/usp */
+		p->thread.ksp = (unsigned long)childregs - 4; /* perhaps not necessary */
+		childregs->sp = p->thread.ksp;
+		p->thread.usp = 0;
+		p->thread.which_stack = 0; /* kernel stack */
+
+		//printk("copy_thread1: ->pid=%d tsp=%lx r5=%lx p->thread.ksp=%lx p->thread.usp=%lx\n",
+		//		p->pid, task_stack_page(p), childregs->r5, p->thread.ksp, p->thread.usp);
+	} else {
+		/* userspace thread (vfork, clone) */
+
+		unsigned long ra_in_syscall;
+		struct pt_regs* childsyscallregs;
+
+		//asm volatile("break");
+
+		/* this was brought to us by sys_lm32_vfork */
+		ra_in_syscall = regs->r1;
+
+		/* childsyscallregs = full syscall frame on kernel stack of child */
+		childsyscallregs = (struct pt_regs *)(child_tos) - 1; /* 32 = safety */
+
+		/* childregs = full task switch frame on kernel stack of child below * childsyscallregs */
+		childregs = childsyscallregs - 1;
+
+		/* child shall have same syscall context to restore as parent has ... */
+		*childsyscallregs = *regs;
+		/* no need to set return value here, it will be set by task switch frame */
+
+		/* copy task switch frame, child shall return with the same registers as parent
+		 * entered the syscall except for return value of syscall */
+		*childregs = *regs;
+
+		regs->r4 = p->pid; /* parent gets child pid as return value */ 
+
+		/* user stack pointer is shared with the parent per definition of vfork */
+		p->thread.usp = usp;
+
+		/* kernel stack pointer is not shared with parent, it is the beginning of
+		 * the just created new task switch segment on the kernel stack */
+		p->thread.ksp = (unsigned long)childregs - 4;
+		p->thread.which_stack = 0; /* resume from ksp */
+
+		/* child returns via ret_from_fork */
+		childregs->ra = (unsigned long)ret_from_fork;
+		/* child shall return to where sys_vfork_wrapper has been called */
+		childregs->r5 =	ra_in_syscall;
+		/* child gets zero as return value from syscall */
+		childregs->r4 = 0;
+		/* after task switch segment return the stack pointer shall point to the
+		 * syscall frame */
+		childregs->sp = (unsigned long)childsyscallregs - 4;
+
+		put_task_struct(p);
+
+		/*printk("copy_thread2: ->pid=%d p=%lx regs=%lx childregs=%lx r5=%lx ra=%lx "
+				"dsf=%lx p->thread.ksp=%lx p->thread.usp=%lx\n",
+				p->pid, p, regs, childregs, childregs->r5, childregs->ra,
+				dup_syscallframe, p->thread.ksp, p->thread.usp);*/
+	}
+
+	return 0;
+}
+
+/* start userspace thread */
+void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long usp)
+{
+	unsigned long *stack;
+
+	set_fs(USER_DS);
+
+	memset(regs, 0, sizeof(regs));
+
+	stack = (unsigned long *)usp;
+	/* -4 because we will add 4 later in ret_from_syscall */
+	regs->ea = pc - 4;
+	regs->r1 = stack[0];
+	regs->r2 = stack[1];
+	regs->r3 = stack[2];
+	regs->r7 = current->mm->context.exec_fdpic_loadmap;
+	regs->sp = usp;
+	current->thread.usp = usp;
+	regs->fp = current->mm->start_data;
+
+	//printk("start_thread: current=%lx usp=%lx\n", current, usp);
+}
+
diff --git a/arch/lm32/kernel/ptrace.c b/arch/lm32/kernel/ptrace.c
new file mode 100644
index 0000000..9ab3d18
--- /dev/null
+++ b/arch/lm32/kernel/ptrace.c
@@ -0,0 +1,247 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* struct task_struct */
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/sched.h>
+#include <linux/security.h>
+#include <linux/user.h>
+#include <linux/signal.h>
+
+#include <asm/registers.h>
+#include <asm/uaccess.h>
+
+void ptrace_disable(struct task_struct *child)
+{
+	/* nothing todo - we have no single step */
+}
+
+/*
+ * Read a register set.
+ */
+int ptrace_getregs (struct task_struct *child, unsigned long __user *data)
+{
+	struct pt_regs *regs;
+	int i;
+
+	if (!access_ok(VERIFY_WRITE, data, (32) * 4))
+		return -EIO;
+
+	regs = task_pt_regs(child);
+
+	for (i = 0; i < 32; i++)
+		__put_user (*((unsigned long*)regs + i), data + i);
+	/* special case: sp: we always want to get the USP! */
+	__put_user (current->thread.usp, data + i);
+
+	return 0;
+}
+
+/*
+ * Write a register set.
+ */
+int ptrace_setregs (struct task_struct *child, unsigned long __user *data)
+{
+	struct pt_regs *regs;
+	int i;
+	unsigned long tmp;
+
+	if (!access_ok(VERIFY_READ, data, 32 * 4))
+		return -EIO;
+
+	regs = task_pt_regs(child);
+
+	for (i = 0; i < 32; i++)
+		__get_user (*((unsigned long*)regs + i), data + i);
+	/* special case: sp: we always want to set the USP! */
+	__get_user (tmp, data + 28);
+	child->thread.usp = tmp;
+
+	return 0;
+}
+
+long arch_ptrace(struct task_struct *child, long request, long addr, long data)
+{
+	int ret;
+
+	//printk("arch_ptrace: %lx %lx %lx %lx\n", child, request, addr, data);
+	switch (request) {
+	/* when I and D space are separate, these will need to be fixed. */
+	case PTRACE_PEEKTEXT: /* read word at location addr. */
+	case PTRACE_PEEKDATA: {
+		unsigned long tmp;
+		int copied;
+
+		copied = access_process_vm(child, addr, &tmp, sizeof(tmp), 0);
+		ret = -EIO;
+		if (copied != sizeof(tmp))
+			break;
+		ret = put_user(tmp,(unsigned long __user *) data);
+		//printk("PTRACE_PEEK* [%lx] @%lx = %lx\n", child, addr, tmp);
+		break;
+	}
+
+	/* Read the word at location addr in the USER area. */
+	case PTRACE_PEEKUSR: {
+		struct pt_regs *regs;
+		unsigned long tmp = 0;
+
+		regs = task_pt_regs(child);
+		ret = 0;  /* Default return value. */
+
+		switch (addr) {
+		case 0 ... 27:
+		case 29 ... 31: {
+			unsigned long* pregs = (unsigned long*) regs;
+			pregs += addr;
+			tmp = *pregs; }
+			break;
+		case 28: { /* sp */
+			/* special case: sp: we always want to get the USP! */
+			tmp = child->thread.usp; }
+			break;
+		case PT_TEXT_ADDR:
+			tmp = child->mm->start_code;
+			break;
+		case PT_TEXT_END_ADDR:
+			tmp = child->mm->end_code;
+			break;
+		case PT_DATA_ADDR:
+			tmp = child->mm->start_data;
+			break;
+		default:
+			tmp = 0;
+			ret = -EIO;
+			printk("ptrace attempted to PEEKUSR at %lx\n", addr);
+			goto out;
+		}
+		ret = put_user(tmp, (unsigned long __user *) data);
+		//printk("PTRACE_PEEKUSR [%s] 0x%lx+%d = %lx\n", child->comm, regs, addr, tmp);
+		break;
+	}
+
+	/* when I and D space are separate, this will have to be fixed. */
+	case PTRACE_POKETEXT: /* write the word at location addr. */
+	case PTRACE_POKEDATA:
+		ret = 0;
+		//printk("PTRACE_POKE* [%s] *0x%lx = 0x%lx\n", child->comm, addr, data);
+		if (access_process_vm(child, addr, &data, sizeof(data), 1)
+		    == sizeof(data)) {
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("wcsr ICC, r0");
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("wcsr DCC, r0");
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("nop");
+			asm volatile("nop");
+			break;
+		}
+		ret = -EIO;
+		break;
+
+	case PTRACE_POKEUSR: {
+		struct pt_regs *regs;
+		ret = 0;
+		regs = task_pt_regs(child);
+
+		switch (addr) {
+		case 0 ... 27:
+		case 29 ... 31: {
+			unsigned long* pregs = (unsigned long*) regs;
+			pregs += addr;
+			*pregs = data; }
+			break;
+		case 28: { /* sp */
+			/* special case: sp: we always want to set the USP! */
+			child->thread.usp = data; }
+			break;
+		default:
+			/* The rest are not allowed. */
+			ret = -EIO;
+			printk("ptrace attempted to POKEUSR at %lx\n", addr);
+			break;
+		}
+		break;
+		}
+
+	case PTRACE_GETREGS:
+		ret = ptrace_getregs (child, (unsigned long __user *) data);
+		break;
+
+	case PTRACE_SETREGS:
+		ret = ptrace_setregs (child, (unsigned long __user *) data);
+		break;
+
+	case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
+	case PTRACE_SINGLESTEP: /* Execute a single instruction. */
+	case PTRACE_CONT: { /* restart after signal. */
+		ret = -EIO;
+		if (!valid_signal(data))
+			break;
+		if (request == PTRACE_SYSCALL) {
+			set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		}
+		else {
+			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		}
+		child->exit_code = data;
+		wake_up_process(child);
+		ret = 0;
+		break;
+	}
+
+	/*
+	 * make the child exit.  Best I can do is send it a sigkill.
+	 * perhaps it should be put in the status that it wants to
+	 * exit.
+	 */
+	case PTRACE_KILL:
+		ret = 0;
+		if (child->exit_state == EXIT_ZOMBIE)	/* already dead */
+			break;
+		child->exit_code = SIGKILL;
+		wake_up_process(child);
+		break;
+
+	case PTRACE_DETACH: /* detach a process that was attached. */
+		ret = ptrace_detach(child, data);
+		break;
+
+	/* PTRACE_GET_THREAD_AREA */
+	default:
+		printk("warning: ptrace default request %lx %lx %lx %lx\n", (unsigned long)child, request, addr, data);
+		ret = ptrace_request(child, request, addr, data);
+		break;
+	}
+ out:
+	return ret;
+}
+
diff --git a/arch/lm32/kernel/semaphore.c b/arch/lm32/kernel/semaphore.c
new file mode 100644
index 0000000..6250ac5
--- /dev/null
+++ b/arch/lm32/kernel/semaphore.c
@@ -0,0 +1,159 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on
+ *
+ * arch/m68knommu/kernel/semaphore.c
+ *
+ * Generic semaphore code. Buyer beware. Do your own
+ * specific changes in <asm/semaphore-helper.h>
+ */
+
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <asm/semaphore-helper.h>
+
+#ifndef CONFIG_RMW_INSNS
+spinlock_t semaphore_wake_lock;
+#endif
+
+/*
+ * Semaphores are implemented using a two-way counter:
+ * The "count" variable is decremented for each process
+ * that tries to sleep, while the "waking" variable is
+ * incremented when the "up()" code goes to wake up waiting
+ * processes.
+ *
+ * Notably, the inline "up()" and "down()" functions can
+ * efficiently test if they need to do any extra work (up
+ * needs to do something only if count was negative before
+ * the increment operation.
+ *
+ * waking_non_zero() (from asm/semaphore.h) must execute
+ * atomically.
+ *
+ * When __up() is called, the count was negative before
+ * incrementing it, and we need to wake up somebody.
+ *
+ * This routine adds one to the count of processes that need to
+ * wake up and exit.  ALL waiting processes actually wake up but
+ * only the one that gets to the "waking" field first will gate
+ * through and acquire the semaphore.  The others will go back
+ * to sleep.
+ *
+ * Note that these functions are only called when there is
+ * contention on the lock, and as such all this is the
+ * "non-critical" part of the whole semaphore business. The
+ * critical part is the inline stuff in <asm/semaphore.h>
+ * where we want to avoid any extra jumps and calls.
+ */
+void __up(struct semaphore *sem)
+{
+	wake_one_more(sem);
+	wake_up(&sem->wait);
+}
+
+/*
+ * Perform the "down" function.  Return zero for semaphore acquired,
+ * return negative for signalled out of the function.
+ *
+ * If called from __down, the return is ignored and the wait loop is
+ * not interruptible.  This means that a task waiting on a semaphore
+ * using "down()" cannot be killed until someone does an "up()" on
+ * the semaphore.
+ *
+ * If called from __down_interruptible, the return value gets checked
+ * upon return.  If the return value is negative then the task continues
+ * with the negative value in the return register (it can be tested by
+ * the caller).
+ *
+ * Either form may be used in conjunction with "up()".
+ *
+ */
+
+
+#define DOWN_HEAD(task_state)						\
+									\
+									\
+	current->state = (task_state);					\
+	add_wait_queue(&sem->wait, &wait);				\
+									\
+	/*								\
+	 * Ok, we're set up.  sem->count is known to be less than zero	\
+	 * so we must wait.						\
+	 *								\
+	 * We can let go the lock for purposes of waiting.		\
+	 * We re-acquire it after awaking so as to protect		\
+	 * all semaphore operations.					\
+	 *								\
+	 * If "up()" is called before we call waking_non_zero() then	\
+	 * we will catch it right away.  If it is called later then	\
+	 * we will have to go through a wakeup cycle to catch it.	\
+	 *								\
+	 * Multiple waiters contend for the semaphore lock to see	\
+	 * who gets to gate through and who has to wait some more.	\
+	 */								\
+	for (;;) {
+
+#define DOWN_TAIL(task_state)			\
+		current->state = (task_state);	\
+	}					\
+	current->state = TASK_RUNNING;		\
+	remove_wait_queue(&sem->wait, &wait);
+
+void __sched __down(struct semaphore * sem)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	DOWN_HEAD(TASK_UNINTERRUPTIBLE)
+	if (waking_non_zero(sem))
+		break;
+	schedule();
+	DOWN_TAIL(TASK_UNINTERRUPTIBLE)
+}
+
+int __sched __down_interruptible(struct semaphore * sem)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+
+	DOWN_HEAD(TASK_INTERRUPTIBLE)
+
+	ret = waking_non_zero_interruptible(sem, current);
+	if (ret)
+	{
+		if (ret == 1)
+			/* ret != 0 only if we get interrupted -arca */
+			ret = 0;
+		break;
+	}
+	schedule();
+	DOWN_TAIL(TASK_INTERRUPTIBLE)
+	return ret;
+}
+
+int __down_trylock(struct semaphore * sem)
+{
+	return waking_non_zero_trylock(sem);
+}
diff --git a/arch/lm32/kernel/setup.c b/arch/lm32/kernel/setup.c
new file mode 100644
index 0000000..bc52218
--- /dev/null
+++ b/arch/lm32/kernel/setup.c
@@ -0,0 +1,299 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Partially based on
+ *
+ * linux/arch/m68knommu/kernel/setup.c
+ */
+
+/*
+ * This file handles the architecture-dependent parts of system setup
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/genhd.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/major.h>
+#include <linux/initrd.h>
+#include <linux/bootmem.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+
+#include <asm/setup.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/thread_info.h>
+
+/* this is set first thing as the kernel is started
+ * from the arguments to the kernel. */
+unsigned long asmlinkage _kernel_arg_cmdline; /* address of the commandline parameters */
+unsigned long asmlinkage _kernel_arg_initrd_start;
+unsigned long asmlinkage _kernel_arg_initrd_end;
+
+char __initdata command_line[COMMAND_LINE_SIZE];
+
+
+/* from mm/init.c */
+extern void bootmem_init(void);
+extern void paging_init(void);
+
+unsigned int cpu_frequency;
+unsigned int sdram_start;
+unsigned int sdram_size;
+
+unsigned int lm32tag_num_uart = 1;
+
+void __init setup_arch(char **cmdline_p)
+{
+	/*
+	 * init "current thread structure" pointer
+	 */
+	lm32_current_thread = (struct thread_info*)&init_thread_union;
+
+	cpu_frequency = (unsigned long)CONFIG_CPU_CLOCK;
+	sdram_start = (unsigned long)CONFIG_MEMORY_START;
+	sdram_size = (unsigned long)CONFIG_MEMORY_SIZE;
+
+	/* Keep a copy of command line */
+	*cmdline_p = (char*)_kernel_arg_cmdline;
+
+
+#if defined(CONFIG_BOOTPARAM)
+	/* CONFIG_CMDLINE should override all */
+	strncpy(*cmdline_p, CONFIG_BOOTPARAM_STRING, COMMAND_LINE_SIZE);
+#endif
+
+	memcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);
+	boot_command_line[COMMAND_LINE_SIZE-1] = 0;
+
+#ifdef CONFIG_DUMMY_CONSOLE
+        conswitchp = &dummy_con;
+#endif
+
+#ifdef CONFIG_EARLY_PRINTK
+	{
+		extern void setup_early_printk(void);
+
+		setup_early_printk();
+	}
+#endif
+
+	/*
+	 * Init boot memory
+	 */
+	bootmem_init();
+
+	/*
+	 * Get kmalloc into gear.
+	 */
+	paging_init();
+}
+
+/*
+ *	Get CPU information for use by the procfs.
+ */
+
+static int show_cpuinfo(struct seq_file *m, void *v)
+{
+    char *cpu, *mmu, *fpu;
+    u_long clockfreq;
+
+    cpu = "lm32";
+    mmu = "none";
+    fpu = "none";
+
+    clockfreq = (loops_per_jiffy*HZ)*5/4;
+
+    seq_printf(m, "CPU:\t\t%s\n"
+		   "MMU:\t\t%s\n"
+		   "FPU:\t\t%s\n"
+		   "Clocking:\t%lu.%1luMHz\n"
+		   "BogoMips:\t%lu.%02lu\n"
+		   "Calibration:\t%lu loops\n",
+		   cpu, mmu, fpu,
+		   clockfreq/1000000,(clockfreq/100000)%10,
+		   (loops_per_jiffy*HZ)/500000,((loops_per_jiffy*HZ)/5000)%100,
+		   (loops_per_jiffy*HZ));
+
+	return 0;
+}
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < NR_CPUS ? ((void *) 0x12345678) : NULL;
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return c_start(m, pos);
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+struct seq_operations cpuinfo_op = {
+	.start	= c_start,
+	.next	= c_next,
+	.stop	= c_stop,
+	.show	= show_cpuinfo,
+};
+
+static struct resource milkymistuart_resources[] = {
+	[0] = {
+		.start = 0x80000000,
+		.end = 0x8000000f,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_UARTRX,
+		.end = IRQ_UARTTX,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device milkymistuart_device = {
+	.name = "milkymist_uart",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(milkymistuart_resources),
+	.resource = milkymistuart_resources,
+};
+
+#ifdef CONFIG_BOARD_XILINX_ML401
+static struct resource lm32sysace_resources[] = {
+	[0] = {
+		.start = 0xa0000000,
+		.end = 0xa00000ff,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device lm32sysace_device = {
+	.name = "xsysace",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(lm32sysace_resources),
+	.resource = lm32sysace_resources,
+};
+#endif
+
+#if defined(CONFIG_BOARD_XILINX_ML401) && defined(CONFIG_SERIO_MILKBD)
+static struct resource lm32milkbd_resources[] = {
+	[0] = {
+		.start = 0x80007000,
+		.end = 0x80007000,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_KEYBOARD,
+		.end = IRQ_KEYBOARD,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device lm32milkbd_device = {
+	.name = "milkbd",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(lm32milkbd_resources),
+	.resource = lm32milkbd_resources,
+};
+#endif
+
+#if defined(CONFIG_BOARD_XILINX_ML401) && defined(CONFIG_SERIO_MILKMOUSE)
+static struct resource lm32milkmouse_resources[] = {
+	[0] = {
+		.start = 0x80008000,
+		.end = 0x80008000,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_MOUSE,
+		.end = IRQ_MOUSE,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device lm32milkmouse_device = {
+	.name = "milkmouse",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(lm32milkmouse_resources),
+	.resource = lm32milkmouse_resources,
+};
+#endif
+
+/* setup all devices we find in the hardware setup information */
+/* setup all devices we find in the hardware setup information */
+static int __init setup_devices(void) {
+	int ret = 0;
+	int err;
+
+	err = platform_device_register(&milkymistuart_device);
+	if( err ) {
+		printk(KERN_ERR "could not register 'milkymist_uart'error:%d\n", err);
+		ret = err;
+	}
+
+#ifdef CONFIG_BOARD_XILINX_ML401
+	err = platform_device_register(&lm32sysace_device);
+	if( err ) {
+		printk(KERN_ERR "could not register 'milkymist_sysace'error:%d\n", err);
+		ret = err;
+	}
+#endif
+
+#if defined(CONFIG_BOARD_XILINX_ML401) && defined(CONFIG_SERIO_MILKBD)
+	err = platform_device_register(&lm32milkbd_device);
+	if( err ) {
+		printk(KERN_ERR "could not register 'milkymist_ps2kbd'error:%d\n", err);
+		ret = err;
+	}
+#endif
+
+#if defined(CONFIG_BOARD_XILINX_ML401) && defined(CONFIG_SERIO_MILKMOUSE)
+	err = platform_device_register(&lm32milkmouse_device);
+	if( err ) {
+		printk(KERN_ERR "could not register 'milkymist_ps2mouse'error:%d\n", err);
+		ret = err;
+	}
+#endif
+
+	return ret;
+}
+/* default console - interface to milkymistuart.c serial + console driver */
+struct platform_device* milkymistuart_default_console_device = &milkymistuart_device;
+
+arch_initcall(setup_devices);
+
diff --git a/arch/lm32/kernel/signal.c b/arch/lm32/kernel/signal.c
new file mode 100644
index 0000000..2e1fb84
--- /dev/null
+++ b/arch/lm32/kernel/signal.c
@@ -0,0 +1,493 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on
+ *
+ *  arch/v850/kernel/signal.c
+ *  Copyright (C) 2001,02,03  NEC Electronics Corporation
+ *  Copyright (C) 2001,02,03  Miles Bader <miles@gnu.org>
+ *  Copyright (C) 1999,2000,2002  Niibe Yutaka & Kaz Kojima
+ *  Copyright (C) 1991,1992  Linus Torvalds
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file COPYING in the main directory of this
+ * archive for more details.
+ *
+ * 1997-11-28  Modified for POSIX.1b signals by Richard Henderson
+ */
+
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/ptrace.h>
+#include <linux/unistd.h>
+#include <linux/stddef.h>
+#include <linux/personality.h>
+#include <linux/tty.h>
+#include <linux/hardirq.h>
+
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/thread_info.h>
+#include <asm/cacheflush.h>
+
+#define DEBUG_SIG 0
+
+#define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
+
+asmlinkage int manage_signals(int retval, struct pt_regs* regs);
+
+int do_signal(int retval, struct pt_regs *regs, int* handled);
+
+/*
+ * Atomically swap in the new signal mask, and wait for a signal.
+ */
+
+asmlinkage int
+sys_rt_sigsuspend(sigset_t *unewset, size_t sigsetsize, struct pt_regs *regs)
+{
+	sigset_t saveset, newset;
+
+	if (sigsetsize != sizeof(sigset_t))
+		return -EINVAL;
+
+	if (copy_from_user(&newset, unewset, sizeof(newset)))
+		return -EFAULT;
+	sigdelsetmask(&newset, ~_BLOCKABLE);
+	spin_lock_irq(&current->sighand->siglock);
+	saveset = current->blocked;
+	current->blocked = newset;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	while (1) {
+		int handled = 0;
+		current->state = TASK_INTERRUPTIBLE;
+		schedule();
+		do_signal(-ERESTARTNOHAND, regs, &handled);
+		if( handled )
+			return -EINTR;
+	}
+}
+
+asmlinkage int 
+sys_sigaction(int sig, const struct old_sigaction *act,
+	      struct old_sigaction *oact)
+{
+	struct k_sigaction new_ka, old_ka;
+	int ret;
+
+	if (act) {
+		old_sigset_t mask;
+		if (!access_ok(VERIFY_READ, act, sizeof(*act)) ||
+		    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||
+		    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer))
+			return -EFAULT;
+		__get_user(new_ka.sa.sa_flags, &act->sa_flags);
+		__get_user(mask, &act->sa_mask);
+		siginitset(&new_ka.sa.sa_mask, mask);
+	}
+
+	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
+
+	if (!ret && oact) {
+		if (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||
+		    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||
+		    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer))
+			return -EFAULT;
+		__put_user(old_ka.sa.sa_flags, &oact->sa_flags);
+		__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
+	}
+
+	return ret;
+}
+
+asmlinkage int
+sys_sigaltstack(const stack_t *uss, stack_t *uoss,
+		struct pt_regs *regs)
+{
+	return do_sigaltstack(uss, uoss, current->thread.usp);
+}
+
+/*
+ * Do a signal return; undo the signal stack.
+ */
+
+struct sigframe
+{
+	struct sigcontext sc;
+	unsigned long extramask[_NSIG_WORDS-1];
+	unsigned long tramp[2];	/* signal trampoline */
+};
+
+static int
+restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc, int *rval_p)
+{
+	unsigned int err = 0;
+
+#define COPY(x)		err |= __get_user(regs->x, &sc->regs.x)
+	COPY(r0);	COPY(r1);	COPY(r2);	COPY(r3);
+	COPY(r4);	COPY(r5);	COPY(r6);	COPY(r7);
+	COPY(r8);	COPY(r9);	COPY(r10);	COPY(r11);
+	COPY(r12);	COPY(r13);	COPY(r14);	COPY(r15);
+	COPY(r16);	COPY(r17);	COPY(r18);	COPY(r19);
+	COPY(r20);	COPY(r21);	COPY(r22);	COPY(r23);
+	COPY(r24);	COPY(r25);	COPY(gp);	COPY(fp);
+	COPY(sp);	COPY(ra);	COPY(ea);	COPY(ba);
+#undef COPY
+
+	*rval_p = regs->r1;
+
+	return err;
+}
+
+asmlinkage int sys_sigreturn(struct pt_regs *regs)
+{
+	struct sigframe *frame = (struct sigframe *)(current->thread.usp+4);
+	sigset_t set;
+	int rval = 0;
+
+#if DEBUG_SIG
+	printk("SIGRETURN\n");
+#endif
+
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+
+	if (__get_user(set.sig[0], &frame->sc.oldmask)
+	    || (_NSIG_WORDS > 1
+		&& __copy_from_user(&set.sig[1], &frame->extramask,
+				    sizeof(frame->extramask))))
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sighand->siglock);
+	current->blocked = set;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	if (restore_sigcontext(regs, &frame->sc, &rval))
+		goto badframe;
+	current->thread.usp = regs->sp;
+	return rval;
+
+badframe:
+	force_sig(SIGSEGV, current);
+	return 0;
+}
+
+/*
+ * Set up a signal frame.
+ */
+static int
+setup_sigcontext(struct sigcontext *sc, struct pt_regs *regs,
+		 unsigned long mask)
+{
+	int err = 0;
+
+#define COPY(x)		err |= __put_user(regs->x, &sc->regs.x)
+	COPY(r0);	COPY(r1);	COPY(r2);	COPY(r3);
+	COPY(r4);	COPY(r5);	COPY(r6);	COPY(r7);
+	COPY(r8);	COPY(r9);	COPY(r10);	COPY(r11);
+	COPY(r12);	COPY(r13);	COPY(r14);	COPY(r15);
+	COPY(r16);	COPY(r17);	COPY(r18);	COPY(r19);
+	COPY(r20);	COPY(r21);	COPY(r22);	COPY(r23);
+	COPY(r24);	COPY(r25);	COPY(gp);	COPY(fp);
+	COPY(sp);	COPY(ra);	COPY(ea);	COPY(ba);
+#undef COPY
+
+	err |= __put_user(mask, &sc->oldmask);
+
+	return err;
+}
+
+/*
+ * Determine which stack to use..
+ */
+static inline void *
+get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size)
+{
+	/* Per default use user stack of userspace process */
+	unsigned long sp = current->thread.usp;
+
+	if ((ka->sa.sa_flags & SA_ONSTACK) != 0 && ! sas_ss_flags(sp))
+		/* use stack set by sigaltstack */
+		sp = current->sas_ss_sp + current->sas_ss_size;
+
+	return (void *)((sp - frame_size) & -8UL);
+}
+
+static int setup_frame(int sig, struct k_sigaction *ka,
+			sigset_t *set, struct pt_regs *regs)
+{
+	struct sigframe *frame;
+	int err = 0;
+	int signal;
+
+	frame = get_sigframe(ka, regs, sizeof(*frame));
+
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
+		goto give_sigsegv;
+
+	signal = current_thread_info()->exec_domain
+		&& current_thread_info()->exec_domain->signal_invmap
+		&& sig < 32
+		? current_thread_info()->exec_domain->signal_invmap[sig]
+		: sig;
+
+	regs->sp = current->thread.usp;
+	err |= setup_sigcontext(&frame->sc, regs, set->sig[0]);
+
+	if (_NSIG_WORDS > 1) {
+		err |= __copy_to_user(frame->extramask, &set->sig[1],
+				      sizeof(frame->extramask));
+	}
+
+	/* Set up to return from userspace. */
+
+	/* mvi  r8, __NR_sigreturn = addi  r8, r0, __NR_sigreturn */
+	err |= __put_user(0x34080000 | __NR_sigreturn, &frame->tramp[0]);
+
+	/* scall */
+	err |= __put_user(0xac000007, &frame->tramp[1]);
+
+	if (err)
+		goto give_sigsegv;
+	
+	/* flush instruction cache */
+	asm volatile("nop");
+	asm volatile("nop");
+	asm volatile("nop");
+	asm volatile("nop");
+	asm volatile("wcsr ICC, r0");
+	asm volatile("nop");
+	asm volatile("nop");
+	asm volatile("nop");
+	asm volatile("nop");
+
+	/* set return address for signal handler to trampoline */
+	regs->ra = (unsigned long)(&frame->tramp[0]);
+
+	/* Set up registers for returning to signal handler */
+	/* entry point */
+	regs->ea = (unsigned long)ka->sa.sa_handler - 4;
+	/* stack pointer */
+	regs->sp = (unsigned long)frame - 4;
+	current->thread.usp = regs->sp;
+	/* Signal handler arguments */
+	regs->r1 = signal;     /* first argument = signum */
+	regs->r2 = (unsigned long)&frame->sc; /* second argument = sigcontext */
+
+	set_fs(USER_DS);
+
+#if DEBUG_SIG
+	printk("SIG deliver (%s:%d): frame=%p, sp=%p ra=%08lx ea=%08lx, signal(r1)=%d\n",
+	       current->comm, current->pid, frame, regs->sp, regs->ra, regs->ea, signal);
+#endif
+
+	return regs->r1;
+
+give_sigsegv:
+	force_sigsegv(sig, current);
+
+	return -1;
+}
+
+/*
+ * OK, we're invoking a handler
+ */	
+
+static int
+handle_signal(int retval, unsigned long sig, siginfo_t *info, struct k_sigaction *ka,
+	      sigset_t *oldset,	struct pt_regs * regs)
+{
+	/* Are we from a system call? */
+	if (regs->r8) {
+		/* return from signal with no error per default */
+		regs->r1 = 0;
+
+		/* If so, check system call restarting.. */
+		switch (retval) {
+		case -ERESTART_RESTARTBLOCK:
+			current_thread_info()->restart_block.fn =
+				do_no_restart_syscall;
+			/* fall through */
+		case -ERESTARTNOHAND:
+			regs->r1 = -EINTR;
+			break;
+
+		case -ERESTARTSYS:
+			if (!(ka->sa.sa_flags & SA_RESTART)) {
+				regs->r1 = -EINTR;
+				break;
+			}
+			/* fallthrough */
+		case -ERESTARTNOINTR:
+			regs->ea -= 4; /* Size of scall insn.  */
+		}
+	}
+
+	/* Set up the stack frame */
+	if (ka->sa.sa_flags & SA_SIGINFO)
+		printk(KERN_ERR "SA_SIGINFO not supported!");
+	else
+		retval = setup_frame(sig, ka, oldset, regs);
+
+	spin_lock_irq(&current->sighand->siglock);
+	sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
+	if (!(ka->sa.sa_flags & SA_NODEFER))
+		sigaddset(&current->blocked,sig);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	return retval;
+}
+
+/*
+ * Note that 'init' is a special process: it doesn't get signals it doesn't
+ * want to handle. Thus you cannot kill init even with a SIGKILL even by
+ * mistake.
+ *
+ * Note that we go through the signals twice: once to check the signals that
+ * the kernel can handle, and then we build all the user-level signal handling
+ * stack-frames in one go after that.
+ */
+int do_signal(int retval, struct pt_regs *regs, int* handled)
+{
+	siginfo_t info;
+	int signr;
+	struct k_sigaction ka;
+	sigset_t *oldset;
+
+	if( handled )
+		*handled = 1;
+
+	/*
+	 * We want the common case to go fast, which
+	 * is why we may in certain cases get here from
+	 * kernel mode. Just return without doing anything
+	 * if so.
+	 */
+	if (!user_mode(regs))
+		return retval;
+
+	if (test_thread_flag(TIF_RESTORE_SIGMASK))
+		oldset = &current->saved_sigmask;
+	else
+		oldset = &current->blocked;
+
+	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
+	if (signr > 0) {
+		/* Whee!  Actually deliver the signal.  */
+		return handle_signal(retval, signr, &info, &ka, oldset, regs);
+	}
+
+	/* Did we come from a system call? */
+	if (regs->r8) {
+		/* Restart the system call - no handlers present */
+		if (retval == -ERESTARTNOHAND
+		    || retval == -ERESTARTSYS
+		    || retval == -ERESTARTNOINTR)
+		{
+			regs->ea -= 4; /* Size of scall insn.  */
+		}
+		else if (retval == -ERESTART_RESTARTBLOCK) {
+			printk("555 restarting scall\n"); /* todo remove after testing */
+			regs->ea -= 4; /* Size of scall insn.  */
+		}
+	}
+
+	if( handled )
+		*handled = 0;
+
+	return retval;
+}
+
+asmlinkage int manage_signals(int retval, struct pt_regs* regs) {
+	unsigned long flags;
+
+	/* disable interrupts for sampling current_thread_info()->flags */
+	local_irq_save(flags);
+	while( current_thread_info()->flags & (_TIF_NEED_RESCHED | _TIF_SIGPENDING) ) {
+		if( current_thread_info()->flags & _TIF_NEED_RESCHED ) {
+			/* schedule -> enables interrupts */
+			schedule();
+
+			/* disable interrupts for sampling current_thread_info()->flags */
+			local_irq_disable();
+		}
+
+		if( current_thread_info()->flags & _TIF_SIGPENDING ) {
+#if DEBUG_SIG
+			/* debugging code */
+			{
+				register unsigned long sp asm("sp");
+				printk("WILL process signal for %s with regs=%lx, ea=%lx, ba=%lx ra=%lx\n",
+						current->comm, regs, regs->ea, regs->ba, *((unsigned long*)(sp+4)));
+			}
+#endif
+			retval = do_signal(retval, regs, NULL);
+
+			/* signal handling enables interrupts */
+
+			/* disable irqs for sampling current_thread_info()->flags */
+			local_irq_disable();
+#if DEBUG_SIG
+			/* debugging code */
+			{
+				register unsigned long sp asm("sp");
+				printk("Processed Signal for %s with regs=%lx, ea=%lx, ba=%lx ra=%lx\n",
+						current->comm, regs, regs->ea, regs->ba, *((unsigned long*)(sp+4)));
+			}
+#endif
+		}
+	}
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+asmlinkage void manage_signals_irq(struct pt_regs* regs) {
+	unsigned long flags;
+	/* do not handle in atomic mode */
+	if (unlikely(in_atomic_preempt_off()) && unlikely(!current->exit_state))
+		return;
+
+	/* disable interrupts for sampling current_thread_info()->flags */
+	local_irq_save(flags);
+
+	if( current_thread_info()->flags & _TIF_NEED_RESCHED ) {
+		/* schedule -> enables interrupts */
+		schedule();
+		
+		/* disable interrupts for sampling current_thread_info()->flags */
+		local_irq_disable();
+	}
+
+	local_irq_restore(flags);
+}
diff --git a/arch/lm32/kernel/sys_lm32.c b/arch/lm32/kernel/sys_lm32.c
new file mode 100644
index 0000000..aa6affc
--- /dev/null
+++ b/arch/lm32/kernel/sys_lm32.c
@@ -0,0 +1,211 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/sem.h>
+#include <linux/msg.h>
+#include <linux/shm.h>
+#include <linux/stat.h>
+#include <linux/syscalls.h>
+#include <linux/mman.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/utsname.h>
+
+#include <asm-lm32/uaccess.h>
+#include <asm-lm32/unistd.h>
+
+/*
+ * sys_pipe() is the normal C calling standard for creating
+ * a pipe. It's not the way unix traditionally does this, though.
+ */
+asmlinkage int sys_pipe(unsigned long __user *fildes)
+{
+	int fd[2];
+	int error;
+
+	error = do_pipe(fd);
+	if (!error) {
+		if (copy_to_user(fildes, fd, 2*sizeof(int)))
+			error = -EFAULT;
+	}
+	return error;
+}
+
+
+
+int kernel_execve(const char *filename, char *const argv[], char *const envp[])
+{
+    register unsigned int  r_syscall	asm("r8") = __NR_execve; 
+    register long          r_a          asm("r1") = (unsigned long)filename; 
+    register long          r_b          asm("r2") = (unsigned long)argv; 
+    register long          r_c          asm("r3") = (unsigned long)envp; 
+             long          __res; 
+
+    asm volatile ( "scall\n" 
+		   "mv %0, r1\n" 
+		   : "=r"(__res) 
+		   : "r"(r_syscall), 
+		     "r"(r_a), "r"(r_b), "r"(r_c) );
+
+    if(__res >=(unsigned long) -4095) {
+      __res = (unsigned long) -1;
+    }
+    return (long) __res;
+}
+EXPORT_SYMBOL(kernel_execve);
+
+
+extern asmlinkage int sys_execve(char *name, char **argv, char **envp, struct pt_regs* regs);
+
+asmlinkage int sys_lm32_vfork(struct pt_regs *regs, unsigned long ra_in_syscall)
+{
+	int ret;
+
+	//printk("do_fork regs=%lx ra=%lx usp=%lx\n", regs, ra_to_syscall_entry, usp);
+
+	/* save ra_in_syscall to r1, this register will not be restored or overwritten (TODO find out)*/
+	regs->r1 = ra_in_syscall;
+	ret = do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, current->thread.usp, regs, 0, NULL, NULL);
+	//printk("do_fork returned %d\n", ret);
+	return ret;
+}
+
+/* the args to sys_lm32_clone try to match the libc call to avoid register
+ * reshuffling:
+ *   int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
+asmlinkage int sys_lm32_clone(
+		int _unused_fn,
+		unsigned long newsp,
+		unsigned long clone_flags,
+		int _unused_arg,
+		unsigned long ra_in_syscall,
+		int _unused_r6,
+		struct pt_regs *regs)
+{
+	register unsigned long r_sp asm("sp");
+	int ret;
+
+	/* -12 because the function and the argument to the child is stored on
+		 the stack, see clone.S in uClibc */
+	if( !newsp ) {
+	  newsp = r_sp - 12;
+	}
+	/* ret_from_fork will return to this address (in child), see copy_thread */
+	regs->r1 = ra_in_syscall;
+	ret = do_fork(clone_flags, newsp, regs, 0, NULL, NULL);
+	return ret;
+}
+
+static inline unsigned long
+do_mmap2 (unsigned long addr, size_t len,
+	 unsigned long prot, unsigned long flags,
+	 unsigned long fd, unsigned long pgoff)
+{
+	struct file * file = NULL;
+	int ret = -EBADF;
+
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+	if (! (flags & MAP_ANONYMOUS)) {
+		if (!(file = fget (fd)))
+			goto out;
+	}
+	
+	down_write (&current->mm->mmap_sem);
+	ret = do_mmap_pgoff (file, addr, len, prot, flags, pgoff);
+	up_write (&current->mm->mmap_sem);
+	if (file)
+		fput (file);
+out:
+	return ret;
+}
+
+unsigned long sys_mmap2 (unsigned long addr, size_t len,
+			unsigned long prot, unsigned long flags,
+			unsigned long fd, unsigned long pgoff)
+{
+	return do_mmap2 (addr, len, prot, flags, fd, pgoff);
+}
+
+asmlinkage void lm32_debug_syscall(
+		unsigned long p1,
+		unsigned long p2,
+		unsigned long p3,
+		unsigned long p4,
+		unsigned long p5,
+		unsigned long p6,
+		struct pt_regs* regs,
+		unsigned long syscallno)
+{
+	switch( syscallno ) {
+		case __NR_write:
+		case __NR_read:
+		case __NR_nanosleep:
+		case __NR_close:
+		case __NR_access:
+			/* do not debug those syscalls */
+			break;
+
+		default:
+			printk("Syscall: %lu (%lx, %lx, %lx, %lx, %lx, %lx) [regs = %lx]\n",
+					syscallno, p1, p2, p3, p4, p5, p6, (unsigned long)regs);
+			break;
+	}
+}
+
+asmlinkage void lm32_debug_syscall_ret(int retval, unsigned long syscallno, struct pt_regs* regs)
+{
+	switch( syscallno ) {
+		case __NR_write:
+		case __NR_read:
+		case __NR_nanosleep:
+		case __NR_access:
+		default:
+			/* do not debug those syscalls except for errors */
+
+			/* do not debug ECHILD for wait() */
+			if( syscallno == __NR_wait4 && retval == -10 )
+				break;
+			if( retval < 0 )
+				printk("ERROR: syscall %lu returned %d\n", syscallno, retval);
+			break;
+
+		case __NR_close:
+			/* do not even debug those syscalls for errors because busybox often
+			 * "cleanups" by closing several hundred never opened fd's */
+			break;
+
+		case __NR_pause:
+			printk("syscall %lu returned %d and ea=%lx\n", syscallno, retval, regs->ea);
+			break;
+			/*
+		default:
+			printk("syscall %lu returned %d\n", syscallno, retval);
+			break;
+			*/
+	}
+}
diff --git a/arch/lm32/kernel/time.c b/arch/lm32/kernel/time.c
new file mode 100644
index 0000000..3d93f82
--- /dev/null
+++ b/arch/lm32/kernel/time.c
@@ -0,0 +1,193 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on
+ *
+ * linux/arch/m68knommu/kernel/time.c
+ *
+ *  Copyright (C) 1991, 1992, 1995  Linus Torvalds
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/profile.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+#include <linux/interrupt.h>
+
+//#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/irq_regs.h>
+#include <asm/setup.h>
+#include <asm/uaccess.h>
+
+#define MMPTR(x) (*((volatile unsigned int *)(x)))
+
+#define CSR_TIMER0_CONTROL	MMPTR(0x80001010)
+#define CSR_TIMER0_COMPARE	MMPTR(0x80001014)
+#define CSR_TIMER0_COUNTER	MMPTR(0x80001018)
+
+#define TIMER_ENABLE		(0x01)
+#define TIMER_AUTORESTART	(0x02)
+
+cycles_t lm32_cycles = 0;
+
+static irqreturn_t timer_interrupt(int irq, void *timer_idx);
+
+/* irq action description */
+static struct irqaction lm32_core_timer_irqaction = {
+	.name = "LM32 Timer Tick",
+	.flags = IRQF_DISABLED,
+	.handler = timer_interrupt,
+};
+
+void lm32_systimer_ack(void)
+{
+	//printk("i%d\n", CSR_TIMER0_COUNTER);
+	lm32_cycles += CSR_TIMER0_COMPARE;
+	/* ack interrupt */
+	CSR_TIMER0_CONTROL = CSR_TIMER0_CONTROL;
+}
+
+/*
+ * timer_interrupt() needs to call the "do_timer()"
+ * routine every clocktick
+ */
+static irqreturn_t timer_interrupt(int irq, void *arg)
+{
+	lm32_systimer_ack();
+	write_seqlock(&xtime_lock);
+
+	do_timer(1);
+#ifndef CONFIG_SMP
+	update_process_times(user_mode(0));
+#endif
+
+	if (current->pid)
+		profile_tick(CPU_PROFILING);
+
+	write_sequnlock(&xtime_lock);
+	return(IRQ_HANDLED);
+}
+
+void time_init(void)
+{
+	xtime.tv_sec = 0;
+	xtime.tv_nsec = 0;
+
+	wall_to_monotonic.tv_sec = -xtime.tv_sec;
+
+	lm32_systimer_program(1, cpu_frequency / HZ);
+
+	if( setup_irq(IRQ_SYSTMR, &lm32_core_timer_irqaction) )
+		panic("could not attach timer interrupt!");
+
+	lm32_irq_unmask(IRQ_SYSTMR);
+}
+
+static unsigned long get_time_offset(void)
+{
+	return CSR_TIMER0_COUNTER/(cpu_frequency / HZ);
+}
+
+cycles_t get_cycles(void)
+{
+	return lm32_cycles +
+		CSR_TIMER0_COUNTER;
+}
+
+void lm32_systimer_program(int periodic, cycles_t cyc)
+{
+	/* stop timer */
+	CSR_TIMER0_CONTROL = 0;
+	/* reset/configure timer */
+	CSR_TIMER0_COUNTER = 0;
+	CSR_TIMER0_COMPARE = cyc;
+	/* start timer */
+	CSR_TIMER0_CONTROL = periodic ? TIMER_ENABLE|TIMER_AUTORESTART : TIMER_ENABLE;
+}
+
+/*
+ * This version of gettimeofday has near microsecond resolution.
+ */
+void do_gettimeofday(struct timeval *tv)
+{
+	unsigned long flags;
+	unsigned long seq;
+	unsigned long usec, sec;
+
+	do {
+		seq = read_seqbegin_irqsave(&xtime_lock, flags);
+		usec = get_time_offset();
+		sec = xtime.tv_sec;
+		usec += (xtime.tv_nsec / 1000);
+	} while (read_seqretry_irqrestore(&xtime_lock, seq, flags));
+
+	while (usec >= 1000000) {
+		usec -= 1000000;
+		sec++;
+	}
+
+	tv->tv_sec = sec;
+	tv->tv_usec = usec;
+}
+EXPORT_SYMBOL(do_gettimeofday);
+
+int do_settimeofday(struct timespec *tv)
+{
+	time_t wtm_sec, sec = tv->tv_sec;
+	long wtm_nsec, nsec = tv->tv_nsec;
+
+	if ((unsigned long)tv->tv_nsec >= NSEC_PER_SEC)
+		return -EINVAL;
+
+	write_seqlock_irq(&xtime_lock);
+	/*
+	 * This is revolting. We need to set the xtime.tv_usec
+	 * correctly. However, the value in this location is
+	 * is value at the last tick.
+	 * Discover what correction gettimeofday
+	 * would have done, and then undo it!
+	 */
+	nsec -= (get_time_offset() * 1000);
+
+	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
+	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);
+
+	set_normalized_timespec(&xtime, sec, nsec);
+	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
+
+	ntp_clear();
+	write_sequnlock_irq(&xtime_lock);
+	clock_was_set();
+
+	return 0;
+}
+EXPORT_SYMBOL(do_settimeofday);
diff --git a/arch/lm32/kernel/traps.c b/arch/lm32/kernel/traps.c
new file mode 100644
index 0000000..56cbb4c
--- /dev/null
+++ b/arch/lm32/kernel/traps.c
@@ -0,0 +1,206 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sets up all exception vectors
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h> /* struct task_struct */
+#include <linux/kallsyms.h>
+#include <linux/signal.h>
+#include <linux/mm.h>
+#include <linux/hardirq.h>
+#include <linux/ptrace.h>
+#include <linux/module.h>
+
+#include <asm/system.h>
+#include <asm/registers.h>
+#include <asm/traps.h>
+
+extern unsigned long  reset_handler;
+
+void __init trap_init(void)
+{
+  void*  exception_vectors = &reset_handler;
+
+	if( ((unsigned long)&reset_handler % 256) != 0 )
+		printk(KERN_ERR "exception vectors are not aligned to 256 bytes!\n");
+  asm volatile ( "wcsr EBA, %0" : : "r"(exception_vectors) );
+#ifndef LM32_HW_JTAG
+	// set DEBA so that we can catch breakpoints in linux
+  asm volatile ( "wcsr DEBA, %0" : : "r"(exception_vectors) );
+#endif
+}
+
+int kstack_depth_to_print = 48;
+
+static void show_trace(struct task_struct *tsk, unsigned long *sp)
+{
+	unsigned long addr;
+
+	asm volatile ("break");
+
+	printk("\nCall Trace:");
+#ifdef CONFIG_KALLSYMS
+	printk("\n");
+#endif
+
+	while (!kstack_end(sp)) {
+		addr = *sp++;
+		/*
+		 * If the address is either in the text segment of the
+		 * kernel, or in the region which contains vmalloc'ed
+		 * memory, it *may* be the address of a calling
+		 * routine; if so, print it so that someone tracing
+		 * down the cause of the crash will be able to figure
+		 * out the call path that was taken.
+		 */
+		if (kernel_text_address(addr))
+			print_ip_sym(addr);
+	}
+
+	printk("\n");
+}
+
+void dump_stack(void)
+{
+	unsigned long dummy;
+	show_trace(NULL, &dummy);
+}
+EXPORT_SYMBOL(dump_stack);
+
+void show_stack(struct task_struct *task, unsigned long *stack)
+{
+	unsigned long *endstack, addr;
+	int i;
+
+	if (!stack) {
+		if (task)
+			stack = (unsigned long *)task->thread.ksp;
+		else
+			stack = (unsigned long *)&stack;
+	}
+
+	addr = (unsigned long)stack;
+	endstack = (unsigned long *)PAGE_ALIGN(addr);
+
+	printk(KERN_EMERG "Stack from %08lx:", (unsigned long)stack);
+	for (i = 0; i < kstack_depth_to_print; i++) {
+		if (stack + 1 > endstack)
+			break;
+		if (i % 8 == 0)
+			printk("\n" KERN_EMERG "       ");
+		printk(" %08lx", *stack++);
+	}
+
+	show_trace(task, stack);
+}
+
+asmlinkage unsigned long asm_do_sig(unsigned long vec, struct pt_regs *regs)
+{
+	struct siginfo info;
+	struct task_struct *tsk;
+	struct mm_struct *mm;
+	int sig;
+ 	int trapidx = 0;
+	unsigned long addr;
+	//register unsigned long sp asm("sp");
+
+	switch(vec)
+	{
+		case 32: /* breakpoint */
+			addr = regs->ba;
+			//printk("Breakpoint @ %lx (%lx)\n", addr, regs->ea);
+			//printk("  regs=%lx ksp=%lx usp=%lx sp=%lx\n", regs, current->thread.ksp, current->thread.usp, sp);
+			/* keep gdb happy */
+			regs->ea = addr;
+			sig = SIGTRAP;
+ 			trapidx = 1;
+			break;
+
+		case 96: /* watchpoint */
+			addr = regs->ba;
+			printk("Watchpoint @ %lx\n", addr);
+			sig = SIGTRAP;
+ 			trapidx = 3;
+			break;
+
+		case 64: /* instruction bus error */
+			addr = regs->ea;
+			printk("Illegal Instruction Error @ %lx\n", addr);
+			sig = SIGILL;
+ 			trapidx = 2;
+			break;
+
+		case 128: /* data bus error */
+			addr = regs->ea;
+			printk("Data Bus Error @ %lx\n", addr);
+			sig = SIGSEGV;
+ 			trapidx = 4;
+			break;
+
+		case 160: /* div by zero */
+			addr = regs->ea;
+			printk("Divide By Zero Error @ %lx\n", addr);
+			sig = SIGFPE;
+ 			trapidx = 5;
+			break;
+
+		default: /* unspecified -> segfault */
+			addr = regs->ea;
+			printk("Unspecified Exception @ %lx/%lx (defaulting to SIGSEGV)\n", addr, regs->ba);
+			sig = SIGSEGV;
+ 			trapidx = 4;
+			break;
+	}
+
+	memset(&info, 0, sizeof(info));
+	info.si_signo = sig;
+	info.si_addr = (void*)addr;
+
+	tsk = current;
+	mm = tsk->mm;
+
+	/*
+	 * If we're on the kernel stack or during disabled interrupts
+	 * or in an atomic section or if we have no user context, the kernel gets the fault.
+	 */
+	if( !mm || in_atomic())
+	{
+		/* the kernel gets the fault */
+		bust_spinlocks(1);
+		printk(KERN_ALERT "%s: unhandled kernel space fault (%d) @ %lx\n", tsk->comm, sig, addr);
+		bust_spinlocks(0);
+		local_irq_enable();
+		do_exit(SIGKILL);
+		return 0;
+	} else {
+		/* the user space gets the fault */
+		if( sig != SIGTRAP )
+			printk(KERN_ERR "%s: unhandled user space fault (%d) @ %lx\n", tsk->comm, sig, addr);
+		force_sig_info(sig, &info, tsk);
+		return regs->r1;
+	}
+}
+
diff --git a/arch/lm32/kernel/vmlinux.lds.S b/arch/lm32/kernel/vmlinux.lds.S
new file mode 100644
index 0000000..9491d52
--- /dev/null
+++ b/arch/lm32/kernel/vmlinux.lds.S
@@ -0,0 +1,179 @@
+/* ld script to make lm32 Linux kernel
+ * taken from the arm version by Martin Mares
+ */
+
+#include <asm/asm-offsets.h>
+#include <asm-generic/vmlinux.lds.h>
+#include <asm/thread_info.h>
+	
+OUTPUT_ARCH(lm32)
+ENTRY(stext)
+
+#define TEXT_OFFSET CONFIG_TEXT_OFFSET
+
+jiffies = jiffies_64 + 4;
+
+SECTIONS
+{
+#ifdef CONFIG_XIP_KERNEL
+	. = XIP_VIRT_ADDR(CONFIG_XIP_PHYS_ADDR);
+#else
+	. = TEXT_OFFSET;
+#endif
+	_stext = .; /* save begin of text section */
+	.text.head : {
+		_sinittext = .;
+		*(.text.head)
+	}
+
+	.init : {			/* Init code and data		*/
+			*(.init.text)
+		_einittext = .;
+		__proc_info_begin = .;
+			*(.proc.info.init)
+		__proc_info_end = .;
+		__arch_info_begin = .;
+			*(.arch.info.init)
+		__arch_info_end = .;
+		__tagtable_begin = .;
+			*(.taglist.init)
+		__tagtable_end = .;
+		. = ALIGN(16);
+		__setup_start = .;
+			*(.init.setup)
+		__setup_end = .;
+		__early_begin = .;
+			*(.early_param.init)
+		__early_end = .;
+		__initcall_start = .;
+			INITCALLS
+		__initcall_end = .;
+		__con_initcall_start = .;
+			*(.con_initcall.init)
+		__con_initcall_end = .;
+		__security_initcall_start = .;
+			*(.security_initcall.init)
+		__security_initcall_end = .;
+#ifdef CONFIG_BLK_DEV_INITRD
+		. = ALIGN(32);
+		__initramfs_start = .;
+			usr/built-in.o(.init.ramfs)
+		__initramfs_end = .;
+#endif
+		. = ALIGN(4096);
+		__per_cpu_start = .;
+			*(.data.percpu)
+		__per_cpu_end = .;
+#ifndef CONFIG_XIP_KERNEL
+		__init_begin = _stext;
+		*(.init.data)
+		. = ALIGN(4096);
+		__init_end = .;
+#endif
+	}
+
+	/DISCARD/ : {			/* Exit code and data		*/
+		*(.exit.text)
+		*(.exit.data)
+		*(.exitcall.exit)
+#ifndef CONFIG_MMU
+		*(.fixup)
+		*(__ex_table)
+#endif
+	}
+
+	.text : {			/* Real text segment		*/
+		_text = .;		/* Text and read-only data	*/
+			. = ALIGN(256);
+			__exception_text_start = .;
+			*(.exception.text)
+			__exception_text_end = .;
+			TEXT_TEXT
+			SCHED_TEXT
+			LOCK_TEXT
+#ifdef CONFIG_MMU
+			*(.fixup)
+#endif
+			*(.gnu.warning)
+			*(.glue_7)
+			*(.glue_7t)
+		*(.got)			/* Global offset table		*/
+	}
+
+	RODATA
+
+	_etext = .; /* save end of text section */
+
+#ifdef CONFIG_XIP_KERNEL
+	__data_loc = ALIGN(4);		/* location in binary */
+	. = PAGE_OFFSET + TEXT_OFFSET;
+#else
+	. = ALIGN(THREAD_SIZE);
+	__data_loc = .;
+#endif
+
+	.data : AT(__data_loc) {
+		_sdata = .;			/* save start of data section */
+
+		/*
+		 * first, the init task union, aligned
+		 * to an 8192 byte boundary.
+		 */
+		*(.data.init_task)
+
+#ifdef CONFIG_XIP_KERNEL
+		. = ALIGN(4096);
+		__init_begin = .;
+		*(.init.data)
+		. = ALIGN(4096);
+		__init_end = .;
+#endif
+
+		. = ALIGN(4096);
+		__nosave_begin = .;
+		*(.data.nosave)
+		. = ALIGN(4096);
+		__nosave_end = .;
+
+		/*
+		 * then the cacheline aligned data
+		 */
+		. = ALIGN(32);
+		*(.data.cacheline_aligned)
+
+		/*
+		 * The exception fixup table (might need resorting at runtime)
+		 */
+		. = ALIGN(32);
+		__start___ex_table = .;
+		__stop___ex_table = .;
+
+		/*
+		 * and the usual data section
+		 */
+		DATA_DATA
+		CONSTRUCTORS
+
+		_edata = .;			/* save end of data section */
+	}
+	_edata_loc = __data_loc + SIZEOF(.data);
+
+	.bss : {
+		__bss_start = .;	/* BSS				*/
+		*(.bss)
+		*(COMMON)
+		__bss_stop = .;		/* save end of bss section */
+	}
+
+	_end = .;
+
+					/* Stabs debugging sections.	*/
+	.stab 0 : { *(.stab) }
+	.stabstr 0 : { *(.stabstr) }
+	.stab.excl 0 : { *(.stab.excl) }
+	.stab.exclstr 0 : { *(.stab.exclstr) }
+	.stab.index 0 : { *(.stab.index) }
+	.stab.indexstr 0 : { *(.stab.indexstr) }
+	.comment 0 : { *(.comment) }
+}
+
diff --git a/arch/lm32/lib/Makefile b/arch/lm32/lib/Makefile
new file mode 100644
index 0000000..2819859
--- /dev/null
+++ b/arch/lm32/lib/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for lm32 specific library files..
+#
+
+lib-y	:= memset.o memcpy.o checksum.o arithmetic.o libgcc2.o
+
diff --git a/arch/lm32/lib/arithmetic.c b/arch/lm32/lib/arithmetic.c
new file mode 100644
index 0000000..2c48197
--- /dev/null
+++ b/arch/lm32/lib/arithmetic.c
@@ -0,0 +1,223 @@
+/* Arithmetic functions taken from libgcc2 for lm32 */
+
+/* Fixed-point arithmetic. */
+
+typedef unsigned long UQItype __attribute__ ((mode (QI)));
+typedef	long SItype __attribute__ ((mode (SI)));
+typedef unsigned long USItype __attribute__ ((mode (SI)));
+
+/* Prototypes */
+
+USItype __mulsi3 (USItype a, USItype b);
+
+USItype __udivmodsi4 (USItype num, USItype den, int modwanted);
+SItype __divsi3 (SItype a, SItype b);
+SItype __modsi3 (SItype a, SItype b);
+USItype __udivsi3 (USItype a, USItype b);
+USItype __umodsi3 (USItype a, USItype b);
+
+SItype __ashlsi3 (SItype a, SItype b);
+SItype __ashrsi3 (SItype a, SItype b);
+USItype __lshrsi3 (USItype a, USItype b);
+
+/* Multiplication */
+
+USItype 
+__mulsi3 (USItype a, USItype b)
+{
+  USItype result;
+    
+  result = 0;
+
+  if (a==0)
+    return 0;
+
+  while (b!=0)
+    {
+      if (b & 1)
+        result += a;
+      a <<= 1;
+      b >>= 1;
+    }
+       
+  return result;    
+}
+
+/* Division */
+
+USItype
+__udivmodsi4 (USItype num, USItype den, int modwanted)
+{
+  USItype bit = 1;
+  USItype res = 0;
+
+  while (den < num && bit && !(den & (1L<<31)))
+    {
+      den <<=1;
+      bit <<=1;
+    }
+  while (bit)
+    {
+      if (num >= den)
+	{
+	  num -= den;
+	  res |= bit;
+	}
+      bit >>=1;
+      den >>=1;
+    }
+  if (modwanted) 
+    return num;
+  return res;
+}
+
+static const UQItype __divsi3_table[] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 4, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 5, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 6, 3, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 7, 3, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 8, 4, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
+  0, 9, 4, 3, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
+  0, 10, 5, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
+  0, 11, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
+  0, 12, 6, 4, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0,
+  0, 13, 6, 4, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0,
+  0, 14, 7, 4, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0,
+  0, 15, 7, 5, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+
+SItype
+__divsi3 (SItype a, SItype b)
+{
+  int neg = 0;
+  SItype res;
+  int cfg;
+
+  if (b == 0) 
+    {
+      /* Raise divide by zero exception */
+      int eba;
+      __asm__ __volatile__ ("rcsr %0, EBA" : "=r" (eba));
+      eba += 32 * 5;
+      __asm__ __volatile__ ("mv ea, ra");
+      __asm__ __volatile__ ("b %0" : : "r" (eba)); 
+    }
+
+  if ((a | b) < 16)
+    {
+      res = __divsi3_table[(a << 4) + b];
+    } 
+  else
+    {
+
+      if (a < 0)
+        {
+          a = -a;
+          neg = !neg;
+        }
+    
+      if (b < 0)
+        {
+          b = -b;
+          neg = !neg;
+        }
+    
+      __asm__ ("rcsr %0, CFG" : "=r" (cfg));
+      if (cfg & 2)
+        __asm__ ("divu %0, %1, %2" : "=r" (res) : "r" (a), "r" (b));
+      else 
+        res = __udivmodsi4 (a, b, 0);
+    
+      if (neg)
+        res = -res;
+    }
+
+  return res;
+}
+
+	
+SItype
+__modsi3 (SItype a, SItype b)
+{
+  int neg = 0;
+  SItype res;
+  int cfg;
+  
+  if (b == 0) 
+    {
+      /* Raise divide by zero exception */
+      int eba;
+      __asm__ __volatile__ ("rcsr %0, EBA" : "=r" (eba));
+      eba += 32 * 5;
+      __asm__ __volatile__ ("mv ea, ra");
+      __asm__ __volatile__ ("b %0" : : "r" (eba)); 
+    }
+  
+  if (a < 0)
+    {
+      a = -a;
+      neg = 1;
+    }
+
+  if (b < 0)
+    b = -b;
+
+  __asm__ ("rcsr %0, CFG" : "=r" (cfg));
+  if (cfg & 2)
+    __asm__ ("modu %0, %1, %2" : "=r" (res) : "r" (a), "r" (b));
+  else 
+    res = __udivmodsi4 (a, b, 1);
+
+  if (neg)
+    res = -res;
+
+  return res;
+}
+
+USItype
+__udivsi3 (USItype a, USItype b)
+{
+  return __udivmodsi4 (a, b, 0);
+}
+
+USItype
+__umodsi3 (USItype a, USItype b)
+{
+  return __udivmodsi4 (a, b, 1);
+}
+
+
+/* Shifts - Optimized versions implemented in assembly. Use these if code space is preferred to performance.  */
+SItype 
+__ashlsi3 (SItype a, SItype b)
+{
+  int i;
+  
+  for (i = (b & 0x1f); i > 0; --i)
+    a += a;
+  return a;
+}
+
+SItype
+__ashrsi3 (SItype a, SItype b)
+{
+  int i;
+  
+  for (i = (b & 0x1f); i > 0; --i)
+    __asm__ ("sri      %0, %0, 1" : "=r" (a) : "0" (a));
+  return a;
+}
+
+USItype
+__lshrsi3 (USItype a, USItype b)
+{
+  int i;
+  
+  for (i = (b & 0x1f); i > 0; --i)
+    __asm__ ("srui     %0, %0, 1" : "=r" (a) : "0" (a));
+  return a;
+}
diff --git a/arch/lm32/lib/checksum.c b/arch/lm32/lib/checksum.c
new file mode 100644
index 0000000..fbd3dad
--- /dev/null
+++ b/arch/lm32/lib/checksum.c
@@ -0,0 +1,168 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		IP/TCP/UDP checksumming routines
+ *
+ * Authors:	Jorge Cwik, <jorge@laser.satlink.net>
+ *		Arnt Gulbrandsen, <agulbra@nvg.unit.no>
+ *		Tom May, <ftom@netcom.com>
+ *		Andreas Schwab, <schwab@issan.informatik.uni-dortmund.de>
+ *		Lots of code moved from tcp.c and ip.c; see those files
+ *		for more names.
+ *
+ * 03/02/96	Jes Sorensen, Andreas Schwab, Roman Hodek:
+ *		Fixed some nasty bugs, causing some horrible crashes.
+ *		A: At some points, the sum (%0) was used as
+ *		length-counter instead of the length counter
+ *		(%1). Thanks to Roman Hodek for pointing this out.
+ *		B: GCC seems to mess up if one uses too many
+ *		data-registers to hold input values and one tries to
+ *		specify d0 and d1 as scratch registers. Letting gcc choose these
+ *      registers itself solves the problem.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+ 
+/* Revised by Kenneth Albanowski for m68knommu. Basic problem: unaligned access kills, so most
+   of the assembly has to go. */
+
+/* copied for lm32 TODO add more info */
+
+#include <linux/module.h>
+#include <net/checksum.h>
+
+static inline unsigned short from32to16(unsigned long x)
+{
+	/* add up 16-bit and 16-bit for 16+c bit */
+	x = (x & 0xffff) + (x >> 16);
+	/* add up carry.. */
+	x = (x & 0xffff) + (x >> 16);
+	return x;
+}
+
+static unsigned long do_csum(const unsigned char * buff, int len)
+{
+	int odd, count;
+	unsigned int result = 0;
+
+	if (len <= 0)
+		goto out;
+	odd = 1 & (unsigned long) buff;
+	if (odd) {
+		result = be16_to_cpu(*buff);
+		len--;
+		buff++;
+	}
+	count = len >> 1;		/* nr of 16-bit words.. */
+	if (count) {
+		if (2 & (unsigned long) buff) {
+			result += *(unsigned short *) buff;
+			count--;
+			len -= 2;
+			buff += 2;
+		}
+		count >>= 1;		/* nr of 32-bit words.. */
+		if (count) {
+			unsigned int carry = 0;
+			do {
+				unsigned int w = *(unsigned int *) buff;
+				count--;
+				buff += 4;
+				result += carry;
+				result += w;
+				carry = (w > result);
+			} while (count);
+			result += carry;
+			result = (result & 0xffff) + (result >> 16);
+		}
+		if (len & 2) {
+			result += *(unsigned short *) buff;
+			buff += 2;
+		}
+	}
+	if (len & 1)
+		result += le16_to_cpu(*buff);
+	result = from32to16(result);
+	if (odd)
+		result = ((result >> 8) & 0xff) | ((result & 0xff) << 8);
+out:
+	return result;
+}
+
+/*
+ *	This is a version of ip_compute_csum() optimized for IP headers,
+ *	which always checksum on 4 octet boundaries.
+ */
+__sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+{
+	return (__force __sum16)~do_csum(iph,ihl*4);
+}
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+__wsum csum_partial(const void *buff, int len, __wsum sum)
+{
+	/*
+	 * Just in case we get nasty checksum data...
+	 * Like 0xffff6ec3 in the case of our IPv6 multicast header.
+	 * We fold to begin with, as well as at the end.
+	 */
+	sum = (sum & 0xffff) + (sum >> 16);
+
+	sum += do_csum(buff, len);
+
+	sum = (sum & 0xffff) + (sum >> 16);
+
+	return sum;
+}
+
+EXPORT_SYMBOL(csum_partial);
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+__sum16 ip_compute_csum(const void *buff, int len)
+{
+	return (__force __sum16)~do_csum(buff,len);
+}
+
+/*
+ * copy from fs while checksumming, otherwise like csum_partial
+ */
+
+__wsum
+csum_partial_copy_from_user(const void __user *src, void *dst,
+			    int len, __wsum sum, int *csum_err)
+{
+	if (csum_err)
+		*csum_err = 0;
+	memcpy(dst, src, len);
+	return csum_partial(dst, len, sum);
+}
+
+/*
+ * copy from ds while checksumming, otherwise like csum_partial
+ */
+
+__wsum
+csum_partial_copy_nocheck(const void *src, void *dst, int len, __wsum sum)
+{
+	memcpy(dst, src, len);
+	return csum_partial(dst, len, sum);
+}
diff --git a/arch/lm32/lib/libgcc2.c b/arch/lm32/lib/libgcc2.c
new file mode 100644
index 0000000..71a09e6
--- /dev/null
+++ b/arch/lm32/lib/libgcc2.c
@@ -0,0 +1,181 @@
+/* Arithmetic functions taken from libgcc2 for lm32 */
+
+typedef		 int QItype	__attribute__ ((mode (QI)));
+typedef unsigned int UQItype	__attribute__ ((mode (QI)));
+typedef		 int HItype	__attribute__ ((mode (HI)));
+typedef unsigned int UHItype	__attribute__ ((mode (HI)));
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+
+typedef 	float SFtype	__attribute__ ((mode (SF)));
+typedef		float DFtype	__attribute__ ((mode (DF)));
+
+typedef int word_type __attribute__ ((mode (__word__)));
+
+#define BITS_PER_UNIT 8
+
+#define Wtype	SItype
+#define UWtype	USItype
+#define HWtype	SItype
+#define UHWtype	USItype
+#define DWtype	DItype
+#define UDWtype	UDItype
+
+extern UDWtype __umulsidi3 (UWtype, UWtype);
+extern DWtype __muldi3 (DWtype, DWtype);
+extern DWtype __divdi3 (DWtype, DWtype);
+extern UDWtype __udivdi3 (UDWtype, UDWtype);
+extern UDWtype __umoddi3 (UDWtype, UDWtype);
+extern DWtype __moddi3 (DWtype, DWtype);
+extern DWtype __negdi2 (DWtype);
+extern DWtype __lshrdi3 (DWtype, word_type);
+extern DWtype __ashldi3 (DWtype, word_type);
+extern DWtype __ashrdi3 (DWtype, word_type);
+
+// big endian
+struct DWstruct {
+	Wtype high, low;
+};
+
+typedef union
+{
+  struct DWstruct s;
+  DWtype ll;
+} DWunion;
+
+DWtype
+__negdi2 (DWtype u)
+{
+  const DWunion uu = {.ll = u};
+  const DWunion w = { {.low = -uu.s.low,
+		       .high = -uu.s.high - ((UWtype) -uu.s.low > 0) } };
+
+  return w.ll;
+}
+
+#define W_TYPE_SIZE	32
+#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))
+#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __x0, __x1, __x2, __x3;					\
+    UHWtype __ul, __vl, __uh, __vh;					\
+									\
+    __ul = __ll_lowpart (u);						\
+    __uh = __ll_highpart (u);						\
+    __vl = __ll_lowpart (v);						\
+    __vh = __ll_highpart (v);						\
+									\
+    __x0 = (UWtype) __ul * __vl;					\
+    __x1 = (UWtype) __ul * __vh;					\
+    __x2 = (UWtype) __uh * __vl;					\
+    __x3 = (UWtype) __uh * __vh;					\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    if (__x1 < __x2)		/* did we get it? */			\
+      __x3 += __ll_B;		/* yes, add it in the proper pos.  */	\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);		\
+  } while (0)
+
+#define __umulsidi3(u, v) \
+  ({DWunion __w;							\
+    umul_ppmm (__w.s.high, __w.s.low, u, v);				\
+    __w.ll; })
+
+DWtype
+__muldi3 (DWtype u, DWtype v)
+{
+  const DWunion uu = {.ll = u};
+  const DWunion vv = {.ll = v};
+  DWunion w = {.ll = __umulsidi3 (uu.s.low, vv.s.low)};
+
+  w.s.high += ((UWtype) uu.s.low * (UWtype) vv.s.high
+	       + (UWtype) uu.s.high * (UWtype) vv.s.low);
+
+  return w.ll;
+}
+
+DWtype
+__lshrdi3 (DWtype u, word_type b)
+{
+  const DWunion uu = {.ll = u};
+  const word_type bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;
+  DWunion w;
+
+  if (b == 0)
+    return u;
+
+  if (bm <= 0)
+    {
+      w.s.high = 0;
+      w.s.low = (UWtype) uu.s.high >> -bm;
+    }
+  else
+    {
+      const UWtype carries = (UWtype) uu.s.high << bm;
+
+      w.s.high = (UWtype) uu.s.high >> b;
+      w.s.low = ((UWtype) uu.s.low >> b) | carries;
+    }
+
+  return w.ll;
+}
+
+DWtype
+__ashldi3 (DWtype u, word_type b)
+{
+  const DWunion uu = {.ll = u};
+  const word_type bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;
+  DWunion w;
+
+  if (b == 0)
+    return u;
+
+  if (bm <= 0)
+    {
+      w.s.low = 0;
+      w.s.high = (UWtype) uu.s.low << -bm;
+    }
+  else
+    {
+      const UWtype carries = (UWtype) uu.s.low >> bm;
+
+      w.s.low = (UWtype) uu.s.low << b;
+      w.s.high = ((UWtype) uu.s.high << b) | carries;
+    }
+
+  return w.ll;
+}
+
+DWtype
+__ashrdi3 (DWtype u, word_type b)
+{
+  const DWunion uu = {.ll = u};
+  const word_type bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;
+  DWunion w;
+
+  if (b == 0)
+    return u;
+
+  if (bm <= 0)
+    {
+      /* w.s.high = 1..1 or 0..0 */
+      w.s.high = uu.s.high >> (sizeof (Wtype) * BITS_PER_UNIT - 1);
+      w.s.low = uu.s.high >> -bm;
+    }
+  else
+    {
+      const UWtype carries = (UWtype) uu.s.high << bm;
+
+      w.s.high = uu.s.high >> b;
+      w.s.low = ((UWtype) uu.s.low >> b) | carries;
+    }
+
+  return w.ll;
+}
diff --git a/arch/lm32/lib/memcpy.c b/arch/lm32/lib/memcpy.c
new file mode 100644
index 0000000..335b883
--- /dev/null
+++ b/arch/lm32/lib/memcpy.c
@@ -0,0 +1,64 @@
+
+#include <linux/types.h>
+#include <linux/autoconf.h>
+
+void * memcpy(void * to, const void * from, size_t n)
+{
+	// TODO: perhaps use this for more speed
+	/*
+  void *xto = to;
+  size_t temp;
+
+  if (!n)
+    return xto;
+  if ((long) to & 1)
+    {
+      char *cto = to;
+      const char *cfrom = from;
+      *cto++ = *cfrom++;
+      to = cto;
+      from = cfrom;
+      n--;
+    }
+  if (n > 2 && (long) to & 2)
+    {
+      short *sto = to;
+      const short *sfrom = from;
+      *sto++ = *sfrom++;
+      to = sto;
+      from = sfrom;
+      n -= 2;
+    }
+  temp = n >> 2;
+  if (temp)
+    {
+      long *lto = to;
+      const long *lfrom = from;
+      for (; temp; temp--)
+	*lto++ = *lfrom++;
+      to = lto;
+      from = lfrom;
+    }
+  if (n & 2)
+    {
+      short *sto = to;
+      const short *sfrom = from;
+      *sto++ = *sfrom++;
+      to = sto;
+      from = sfrom;
+    }
+  if (n & 1)
+    {
+      char *cto = to;
+      const char *cfrom = from;
+      *cto = *cfrom;
+    }
+  return xto;
+#else
+	*/
+  const char *c_from = from;
+  char *c_to = to;
+  while (n-- > 0)
+    *c_to++ = *c_from++;
+  return((void *) to);
+}
diff --git a/arch/lm32/lib/memset.c b/arch/lm32/lib/memset.c
new file mode 100644
index 0000000..1389bf4
--- /dev/null
+++ b/arch/lm32/lib/memset.c
@@ -0,0 +1,47 @@
+#include <linux/types.h>
+
+void * memset(void * s, int c, size_t count)
+{
+  void *xs = s;
+  size_t temp;
+
+  if (!count)
+    return xs;
+  c &= 0xff;
+  c |= c << 8;
+  c |= c << 16;
+  if ((long) s & 1)
+    {
+      char *cs = s;
+      *cs++ = c;
+      s = cs;
+      count--;
+    }
+  if (count > 2 && (long) s & 2)
+    {
+      short *ss = s;
+      *ss++ = c;
+      s = ss;
+      count -= 2;
+    }
+  temp = count >> 2;
+  if (temp)
+    {
+      long *ls = s;
+      for (; temp; temp--)
+	*ls++ = c;
+      s = ls;
+    }
+  if (count & 2)
+    {
+      short *ss = s;
+      *ss++ = c;
+      s = ss;
+    }
+  if (count & 1)
+    {
+      char *cs = s;
+      *cs = c;
+    }
+  return xs;
+}
diff --git a/arch/lm32/mm/Makefile b/arch/lm32/mm/Makefile
new file mode 100644
index 0000000..4ae7f36
--- /dev/null
+++ b/arch/lm32/mm/Makefile
@@ -0,0 +1,5 @@
+#
+# arch/lm32/mm/Makefile
+#
+
+obj-y += memory.o init.o kmap.o
diff --git a/arch/lm32/mm/init.c b/arch/lm32/mm/init.c
new file mode 100644
index 0000000..973bb68
--- /dev/null
+++ b/arch/lm32/mm/init.c
@@ -0,0 +1,242 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/initrd.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+#include <linux/init.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <linux/bootmem.h>
+#include <linux/slab.h>
+#include <linux/linkage.h>
+#include <linux/pfn.h>
+
+#include <asm-generic/sections.h>
+#include <asm-lm32/setup.h>
+
+//#undef DEBUG
+#define DEBUG
+
+/* in arch/lm32/kernel/setup.c */
+extern unsigned long asmlinkage _kernel_arg_initrd_start;
+extern unsigned long asmlinkage _kernel_arg_initrd_end;
+
+unsigned long physical_memory_start;
+unsigned long physical_memory_end;
+unsigned long memory_start;
+unsigned long memory_end;
+
+void __init bootmem_init(void)
+{
+	unsigned long bootmap_size;
+
+	/*
+	 * Init memory
+	 */
+	physical_memory_start = sdram_start;
+	physical_memory_end = sdram_start+sdram_size;
+	if( ((unsigned long)_end < physical_memory_start) || ((unsigned long)_end > physical_memory_end) )
+		printk("BUG: your kernel is not located in the ddr sdram");
+	/* start after kernel code */
+	memory_start = PAGE_ALIGN((unsigned long)_end);
+	memory_end = physical_memory_end;
+#ifdef DEBUG
+	printk("memory from %lx - %lx\n", memory_start, memory_end);
+#endif
+
+	init_mm.start_code = (unsigned long)_stext;
+	init_mm.end_code = (unsigned long)_etext;
+	init_mm.end_data = (unsigned long)_edata;
+	init_mm.brk = (unsigned long)0;
+
+	/*
+	 * Give all the memory to the bootmap allocator, tell it to put the
+	 * boot mem_map at the start of memory.
+	 */
+	bootmap_size = init_bootmem_node(
+			NODE_DATA(0),
+			memory_start >> PAGE_SHIFT, /* map goes here */
+			PAGE_OFFSET >> PAGE_SHIFT,
+			memory_end >> PAGE_SHIFT);
+
+	/*
+	 * Free the usable memory, we have to make sure we do not free
+	 * the bootmem bitmap so we then reserve it after freeing it :-)
+	 */
+	free_bootmem(memory_start, memory_end - memory_start);
+	reserve_bootmem(memory_start, bootmap_size);
+
+	/*
+	 * reserve initrd boot memory
+	 */
+#ifdef CONFIG_BLK_DEV_INITRD
+	if(_kernel_arg_initrd_start) {
+		unsigned long reserve_start = _kernel_arg_initrd_start & PAGE_MASK;
+		unsigned long reserve_end = (_kernel_arg_initrd_end + PAGE_SIZE-1) & PAGE_MASK;
+		initrd_start = _kernel_arg_initrd_start;
+		initrd_end = _kernel_arg_initrd_end;
+		printk("reserving initrd memory: %lx size %lx\n", reserve_start, reserve_end-reserve_start);
+		reserve_bootmem(reserve_start, reserve_end-reserve_start);
+	}
+#endif
+}
+
+/*
+ * paging_init() continues the virtual memory environment setup which
+ * was begun by the code in arch/head.S.
+ * The parameters are pointers to where to stick the starting and ending
+ * addresses of available kernel virtual memory.
+ */
+void __init paging_init(void)
+{
+	/*
+	 * Make sure start_mem is page aligned, otherwise bootmem and
+	 * page_alloc get different views of the world.
+	 */
+#ifdef DEBUG
+	unsigned long start_mem = PAGE_ALIGN(memory_start);
+#endif
+	unsigned long end_mem   = memory_end & PAGE_MASK;
+
+#ifdef DEBUG
+	printk ("start_mem is %#lx\nvirtual_end is %#lx\n",
+		start_mem, end_mem);
+#endif
+
+	set_fs(KERNEL_DS);
+
+#ifdef DEBUG
+	printk ("before free_area_init\n");
+
+	printk ("free_area_init -> start_mem is %#lx\nvirtual_end is %#lx\n",
+		start_mem, end_mem);
+#endif
+
+	{
+		unsigned i;
+		unsigned long zones_size[MAX_NR_ZONES];
+
+		for (i = 0; i < MAX_NR_ZONES; i++)
+			zones_size[i] = 0;
+		zones_size[ZONE_NORMAL] = (end_mem - PAGE_OFFSET) >> PAGE_SHIFT;
+		free_area_init(zones_size);
+	}
+	printk ("after free_area_init\n");
+}
+
+void __init mem_init(void)
+{
+	int codek = 0, datak = 0;
+	unsigned long tmp;
+	unsigned long start_mem = memory_start;
+	unsigned long end_mem   = memory_end;
+	/* TODO: use more of hardware setup to initialize memory */
+	unsigned long ramlen = sdram_size;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "Mem_init: start=%lx, end=%lx\n", start_mem, end_mem);
+#endif
+
+	end_mem &= PAGE_MASK;
+	high_memory = (void *) end_mem;
+
+	start_mem = PAGE_ALIGN(start_mem);
+	max_mapnr = num_physpages = (((unsigned long) high_memory) - PAGE_OFFSET) >> PAGE_SHIFT;
+
+	/* this will put all memory onto the freelists */
+	totalram_pages = free_all_bootmem();
+
+	codek = (_etext - _stext) >> 10;
+	datak = (__bss_stop - __bss_start) >> 10;
+
+	tmp = nr_free_pages() << PAGE_SHIFT;
+	printk(KERN_INFO "Memory available: %luk/%luk RAM, (%dk kernel code, %dk data)\n",
+	       tmp >> 10,
+	       ramlen >> 10,
+	       codek,
+	       datak
+	       );
+}
+
+static void free_init_pages(const char *what, unsigned long start, unsigned long end) {
+	unsigned long pfn;
+	printk("Freeing %s mem: %ldk freed\n", what, (end-start) >> 10);
+
+	for (pfn = PFN_UP(start); pfn < PFN_DOWN(end); pfn++) {
+		struct page* page = pfn_to_page(pfn);
+
+		ClearPageReserved(page);
+		init_page_count(page);
+		__free_page(page);
+		totalram_pages++;
+	}
+}
+
+void
+free_initmem(void)
+{
+	/* this will create segfaults, so deactivated */
+	/* free_init_pages("unused kernel", (unsigned long)&__init_begin, (unsigned* long)&__init_end); */
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+void __init free_initrd_mem(unsigned long start, unsigned long end) {
+	free_init_pages("initrd", start, end);
+}
+#endif
+
+void show_mem(void)
+{
+	unsigned long i;
+	int free = 0, total = 0, reserved = 0, shared = 0;
+	int cached = 0;
+
+	printk(KERN_INFO "\nMem-info:\n");
+	show_free_areas();
+	i = max_mapnr;
+	while (i-- > 0) {
+		total++;
+		if (PageReserved(mem_map+i))
+			reserved++;
+		else if (PageSwapCache(mem_map+i))
+			cached++;
+		else if (!page_count(mem_map+i))
+			free++;
+		else
+			shared += page_count(mem_map+i) - 1;
+	}
+	printk(KERN_INFO "%d pages of RAM\n",total);
+	printk(KERN_INFO "%d free pages\n",free);
+	printk(KERN_INFO "%d reserved pages\n",reserved);
+	printk(KERN_INFO "%d pages shared\n",shared);
+	printk(KERN_INFO "%d pages swap cached\n",cached);
+}
diff --git a/arch/lm32/mm/kmap.c b/arch/lm32/mm/kmap.c
new file mode 100644
index 0000000..2f52264
--- /dev/null
+++ b/arch/lm32/mm/kmap.c
@@ -0,0 +1,81 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ *  linux/arch/lm32/mm/kmap.c
+ *
+ *  Based on:
+ *
+ *  linux/arch/m68knommu/mm/kmap.c
+ *  Copyright (C) 2000 Lineo, <davidm@snapgear.com>
+ *  Copyright (C) 2000-2002 David McCullough <davidm@snapgear.com>
+ */
+
+#include <linux/mm.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <asm/setup.h>
+#include <asm/segment.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+#undef DEBUG
+
+/*
+ * Map some physical address range into the kernel address space.
+ */
+void *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag)
+{
+	return (void *)physaddr;
+}
+
+/*
+ * Unmap a ioremap()ed region again.
+ */
+void iounmap(void *addr)
+{
+}
+
+/*
+ * __iounmap unmaps nearly everything, so be careful
+ * it doesn't free currently pointer/page tables anymore but it
+ * wans't used anyway and might be added later.
+ */
+void __iounmap(void *addr, unsigned long size)
+{
+}
+
+/*
+ * Set new cache mode for some kernel address space.
+ * The caller must push data for that range itself, if such data may already
+ * be in the cache.
+ */
+void kernel_set_cachemode(void *addr, unsigned long size, int cmode)
+{
+}
diff --git a/arch/lm32/mm/memory.c b/arch/lm32/mm/memory.c
new file mode 100644
index 0000000..a347cd6
--- /dev/null
+++ b/arch/lm32/mm/memory.c
@@ -0,0 +1,112 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ *  linux/arch/lm32/mm/memory.c
+ *
+ *  Based on:
+ *
+ *  linux/arch/m68k/mm/memory.c
+ *  Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>,
+ *  Copyright (C) 1999-2002, Greg Ungerer (gerg@snapgear.com)
+ *  Copyright (C) 1995  Hamish Macdonald
+ */
+
+#include <linux/mm.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+
+#include <asm/setup.h>
+#include <asm/segment.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/traps.h>
+#include <asm/io.h>
+
+/*
+ * cache_clear() semantics: Clear any cache entries for the area in question,
+ * without writing back dirty entries first. This is useful if the data will
+ * be overwritten anyway, e.g. by DMA to memory. The range is defined by a
+ * _physical_ address.
+ */
+
+void cache_clear (unsigned long paddr, int len)
+{
+	(void)paddr;
+	(void)len;
+	asm volatile (
+			"nop\n"
+			"wcsr DCC, r0\n"
+			"nop\n"
+	);
+}
+
+
+/*
+ * we can only invalidate the whole cache on the mico32
+ */
+static __inline__ void cache_invalidate_lines(unsigned long paddr, int len)
+{
+	cache_clear(paddr, len);
+}
+
+
+/*
+ * cache_push() semantics: Write back any dirty cache data in the given area,
+ * and invalidate the range in the instruction cache. It needs not (but may)
+ * invalidate those entries also in the data cache. The range is defined by a
+ * _physical_ address.
+ */
+
+void cache_push (unsigned long paddr, int len)
+{
+	cache_invalidate_lines(paddr, len);
+}
+
+
+/*
+ * cache_push_v() semantics: Write back any dirty cache data in the given
+ * area, and invalidate those entries at least in the instruction cache. This
+ * is intended to be used after data has been written that can be executed as
+ * code later. The range is defined by a _user_mode_ _virtual_ address  (or,
+ * more exactly, the space is defined by the %sfc/%dfc register.)
+ */
+
+void cache_push_v (unsigned long vaddr, int len)
+{
+	cache_invalidate_lines(vaddr, len);
+}
+
+/* Map some physical address range into the kernel address space. The
+ * code is copied and adapted from map_chunk().
+ */
+
+unsigned long kernel_map(unsigned long paddr, unsigned long size,
+			 int nocacheflag, unsigned long *memavailp )
+{
+	return paddr;
+}
+
diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 4245b7f..49af06c 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -430,7 +430,7 @@ source "drivers/s390/block/Kconfig"
 
 config XILINX_SYSACE
 	tristate "Xilinx SystemACE support"
-	depends on 4xx
+	depends on 4xx || LM32
 	help
 	  Include support for the Xilinx SystemACE CompactFlash interface
 
diff --git a/drivers/block/xsysace.c b/drivers/block/xsysace.c
index 3ede0b6..233f80e 100644
--- a/drivers/block/xsysace.c
+++ b/drivers/block/xsysace.c
@@ -97,9 +97,14 @@ MODULE_DESCRIPTION("Xilinx SystemACE device driver");
 MODULE_LICENSE("GPL");
 
 /* SystemACE register definitions */
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+#define ACE_BUSMODE (0x00<<1)+2
+#define ACE_STATUS (0x04<<1)+2
+#else
 #define ACE_BUSMODE (0x00)
-
 #define ACE_STATUS (0x04)
+#endif
+
 #define ACE_STATUS_CFGLOCK      (0x00000001)
 #define ACE_STATUS_MPULOCK      (0x00000002)
 #define ACE_STATUS_CFGERROR     (0x00000004)	/* config controller error */
@@ -119,23 +124,41 @@ MODULE_LICENSE("GPL");
 #define ACE_STATUS_CFCORR       (0x00400000)
 #define ACE_STATUS_CFERR        (0x00800000)
 
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+#define ACE_ERROR (0x08<<1)+2
+#define ACE_CFGLBA (0x0c<<1)+2
+#define ACE_MPULBA (0x10<<1)+2
+#else
 #define ACE_ERROR (0x08)
 #define ACE_CFGLBA (0x0c)
 #define ACE_MPULBA (0x10)
+#endif
 
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+#define ACE_SECCNTCMD (0x14<<1)+2
+#else
 #define ACE_SECCNTCMD (0x14)
+#endif
 #define ACE_SECCNTCMD_RESET      (0x0100)
 #define ACE_SECCNTCMD_IDENTIFY   (0x0200)
 #define ACE_SECCNTCMD_READ_DATA  (0x0300)
 #define ACE_SECCNTCMD_WRITE_DATA (0x0400)
 #define ACE_SECCNTCMD_ABORT      (0x0600)
 
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+#define ACE_VERSION (0x16<<1)+2
+#else
 #define ACE_VERSION (0x16)
+#endif
 #define ACE_VERSION_REVISION_MASK (0x00FF)
 #define ACE_VERSION_MINOR_MASK    (0x0F00)
 #define ACE_VERSION_MAJOR_MASK    (0xF000)
 
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+#define ACE_CTRL (0x18<<1)+2
+#else
 #define ACE_CTRL (0x18)
+#endif
 #define ACE_CTRL_FORCELOCKREQ   (0x0001)
 #define ACE_CTRL_LOCKREQ        (0x0002)
 #define ACE_CTRL_FORCECFGADDR   (0x0004)
@@ -151,7 +174,11 @@ MODULE_LICENSE("GPL");
 #define ACE_CTRL_CFGPROG        (0x1000)
 #define ACE_CTRL_CFGADDR_MASK   (0xe000)
 
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+#define ACE_FATSTAT (0x1c<<1)+2
+#else
 #define ACE_FATSTAT (0x1c)
+#endif
 
 #define ACE_NUM_MINORS 16
 #define ACE_SECTOR_SIZE (512)
@@ -274,7 +301,11 @@ static void ace_datain_be16(struct ace_device *ace)
 	int i = ACE_FIFO_SIZE / 2;
 	u16 *dst = ace->data_ptr;
 	while (i--)
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+		*dst++ = in_le16(ace->baseaddr + 0x82);
+#else
 		*dst++ = in_le16(ace->baseaddr + 0x40);
+#endif
 	ace->data_ptr = dst;
 }
 
@@ -283,7 +314,11 @@ static void ace_dataout_be16(struct ace_device *ace)
 	int i = ACE_FIFO_SIZE / 2;
 	u16 *src = ace->data_ptr;
 	while (i--)
+#if defined(CONFIG_PLAT_MILKYMIST) && defined(CONFIG_BOARD_XILINX_ML401)
+		out_le16(ace->baseaddr + 0x82, *src++);
+#else
 		out_le16(ace->baseaddr + 0x40, *src++);
+#endif
 	ace->data_ptr = src;
 }
 
@@ -940,7 +975,7 @@ static int __devinit ace_setup(struct ace_device *ace)
 	/*
 	 * Map the device
 	 */
-	ace->baseaddr = ioremap(ace->physaddr, 0x80);
+	ace->baseaddr = ioremap(ace->physaddr, 0xa0000000);
 	if (!ace->baseaddr)
 		goto err_ioremap;
 
diff --git a/drivers/input/serio/Kconfig b/drivers/input/serio/Kconfig
index 5ce632c..251872c 100644
--- a/drivers/input/serio/Kconfig
+++ b/drivers/input/serio/Kconfig
@@ -165,6 +165,20 @@ config SERIO_LIBPS2
 	  To compile this driver as a module, choose M here: the
 	  module will be called libps2.
 
+config SERIO_MILKBD
+	tristate "Milkymist PS/2 keyboard connector"
+	depends on PLAT_MILKYMIST
+	help
+	  Say Y here if you are building for Milkymist and want to use an AT
+	  keyboard or mouse connected to its PS/2 connector.
+
+config SERIO_MILKMOUSE
+	tristate "Milkymist PS/2 mouse connector"
+	depends on PLAT_MILKYMIST
+	help
+	  Say Y here if you are building for Milkymist and want to use an AT
+	  keyboard or mouse connected to its PS/2 connector.
+
 config SERIO_RAW
 	tristate "Raw access to serio ports"
 	help
diff --git a/drivers/input/serio/Makefile b/drivers/input/serio/Makefile
index 4155197..fe12dbd 100644
--- a/drivers/input/serio/Makefile
+++ b/drivers/input/serio/Makefile
@@ -19,4 +19,6 @@ obj-$(CONFIG_HIL_MLC)		+= hp_sdc_mlc.o hil_mlc.o
 obj-$(CONFIG_SERIO_PCIPS2)	+= pcips2.o
 obj-$(CONFIG_SERIO_MACEPS2)	+= maceps2.o
 obj-$(CONFIG_SERIO_LIBPS2)	+= libps2.o
+obj-$(CONFIG_SERIO_MILKBD)	+= milkbd.o
+obj-$(CONFIG_SERIO_MILKMOUSE)	+= milkmouse.o
 obj-$(CONFIG_SERIO_RAW)		+= serio_raw.o
diff --git a/drivers/input/serio/milkbd.c b/drivers/input/serio/milkbd.c
new file mode 100644
index 0000000..159a768
--- /dev/null
+++ b/drivers/input/serio/milkbd.c
@@ -0,0 +1,143 @@
+/*
+ * milkbd.c
+ */
+
+/*
+ * Milkymist PS/2 keyboard connector driver for Linux
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+
+MODULE_AUTHOR("");
+MODULE_DESCRIPTION("Milkymist PS/2 keyboard connector driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Register numbers.
+ */
+#define	PS2_DATA_REG	0x80007000
+#define	PS2_STATUS_REG	0x80007004
+#define PS2_TX_BUSY	0x01
+
+static int milkbd_write(struct serio *port, unsigned char val)
+{
+	while(readl(PS2_STATUS_REG)&PS2_TX_BUSY);
+
+	writel(val, PS2_DATA_REG);
+
+	return 0;
+}
+
+static irqreturn_t milkbd_rx(int irq, void *dev_id)
+{
+	struct serio *port = dev_id;
+	unsigned int byte;
+	int handled = IRQ_NONE;
+
+	byte = readl(PS2_DATA_REG);
+	serio_interrupt(port, byte, 0);
+	handled = IRQ_HANDLED;
+
+	return handled;
+}
+
+static int milkbd_open(struct serio *port)
+{
+
+	if (request_irq(IRQ_KEYBOARD, milkbd_rx, 0, "milkbd", port) != 0) {
+		printk(KERN_ERR "milkbd.c: Could not allocate keyboard receive IRQ\n");
+		return -EBUSY;
+	}
+
+	lm32_irq_unmask(IRQ_KEYBOARD);
+
+	printk(KERN_INFO "milkymist_ps2: Keyboard connector at 0x%08x irq %d\n",
+		PS2_DATA_REG,
+		IRQ_KEYBOARD);
+
+	return 0;
+}
+
+static void milkbd_close(struct serio *port)
+{
+	free_irq(IRQ_KEYBOARD, port);
+}
+
+/*
+ * Allocate and initialize serio structure for subsequent registration
+ * with serio core.
+ */
+static int __devinit milkbd_probe(struct platform_device *dev)
+{
+	struct serio *serio;
+
+	serio = kzalloc(sizeof(struct serio), GFP_KERNEL);
+	if (!serio)
+		return -ENOMEM;
+
+	serio->id.type		= SERIO_8042;
+	serio->write		= milkbd_write;
+	serio->open		= milkbd_open;
+	serio->close		= milkbd_close;
+	serio->dev.parent	= &dev->dev;
+	strlcpy(serio->name, "Milkymist PS/2 Keyboard connector", sizeof(serio->name));
+	strlcpy(serio->phys, "milkymist/ps2keyboard", sizeof(serio->phys));
+
+	platform_set_drvdata(dev, serio);
+	serio_register_port(serio);
+	return 0;
+}
+
+static int __devexit milkbd_remove(struct platform_device *dev)
+{
+	struct serio *serio = platform_get_drvdata(dev);
+	serio_unregister_port(serio);
+	return 0;
+}
+
+static struct platform_driver milkbd_driver = {
+	.probe		= milkbd_probe,
+	.remove		= __devexit_p(milkbd_remove),
+	.driver		= {
+	.name		= "milkbd",
+	},
+};
+
+static int __init milkbd_init(void)
+{
+	return platform_driver_register(&milkbd_driver);
+}
+
+static void __exit milkbd_exit(void)
+{
+	platform_driver_unregister(&milkbd_driver);
+}
+
+module_init(milkbd_init);
+module_exit(milkbd_exit);
diff --git a/drivers/input/serio/milkmouse.c b/drivers/input/serio/milkmouse.c
new file mode 100644
index 0000000..be00acf
--- /dev/null
+++ b/drivers/input/serio/milkmouse.c
@@ -0,0 +1,143 @@
+/*
+ * milkmouse.c
+ */
+
+/*
+ * Milkymist PS/2 mouse connector driver for Linux
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+
+MODULE_AUTHOR("");
+MODULE_DESCRIPTION("Milkymist PS/2 mouse connector driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Register numbers.
+ */
+#define	PS2_DATA_REG	0x80008000
+#define PS2_STATUS_REG	0x80008004
+#define PS2_TX_BUSY	0x01
+
+static int milkmouse_write(struct serio *port, unsigned char val)
+{
+	while(readl(PS2_STATUS_REG)&PS2_TX_BUSY);
+
+	writel(val, PS2_DATA_REG);
+
+	return 0;
+}
+
+static irqreturn_t milkmouse_rx(int irq, void *dev_id)
+{
+	struct serio *port = dev_id;
+	unsigned int byte;
+	int handled = IRQ_NONE;
+
+	byte = readl(PS2_DATA_REG);
+	serio_interrupt(port, byte, 0);
+	handled = IRQ_HANDLED;
+
+	return handled;
+}
+
+static int milkmouse_open(struct serio *port)
+{
+
+	if (request_irq(IRQ_MOUSE, milkmouse_rx, 0, "milkmouse", port) != 0) {
+		printk(KERN_ERR "milkmouse.c: Could not allocate mouse receive IRQ\n");
+		return -EBUSY;
+	}
+
+	lm32_irq_unmask(IRQ_MOUSE);
+
+	printk(KERN_INFO "milkymist_ps2: Mouse connector at 0x%08x irq %d\n",
+		PS2_DATA_REG,
+		IRQ_MOUSE);
+
+	return 0;
+}
+
+static void milkmouse_close(struct serio *port)
+{
+	free_irq(IRQ_MOUSE, port);
+}
+
+/*
+ * Allocate and initialize serio structure for subsequent registration
+ * with serio core.
+ */
+static int __devinit milkmouse_probe(struct platform_device *dev)
+{
+	struct serio *serio;
+
+	serio = kzalloc(sizeof(struct serio), GFP_KERNEL);
+	if (!serio)
+		return -ENOMEM;
+
+	serio->id.type		= SERIO_8042;
+	serio->write		= milkmouse_write;
+	serio->open		= milkmouse_open;
+	serio->close		= milkmouse_close;
+	serio->dev.parent	= &dev->dev;
+	strlcpy(serio->name, "Milkymist PS/2 Mouse connector", sizeof(serio->name));
+	strlcpy(serio->phys, "milkymist/ps2mouse", sizeof(serio->phys));
+
+	platform_set_drvdata(dev, serio);
+	serio_register_port(serio);
+	return 0;
+}
+
+static int __devexit milkmouse_remove(struct platform_device *dev)
+{
+	struct serio *serio = platform_get_drvdata(dev);
+	serio_unregister_port(serio);
+	return 0;
+}
+
+static struct platform_driver milkmouse_driver = {
+	.probe		= milkmouse_probe,
+	.remove		= __devexit_p(milkmouse_remove),
+	.driver		= {
+	.name		= "milkmouse",
+	},
+};
+
+static int __init milkmouse_init(void)
+{
+	return platform_driver_register(&milkmouse_driver);
+}
+
+static void __exit milkmouse_exit(void)
+{
+	platform_driver_unregister(&milkmouse_driver);
+}
+
+module_init(milkmouse_init);
+module_exit(milkmouse_exit);
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index cc6c734..54ecc46 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -524,6 +524,12 @@ config MTD_OMAP_NOR
 	  These boards include the Innovator, H2, H3, OSK, Perseus2, and
 	  more.  If you have such a board, say 'Y'.
 
+config MTD_MILKYMIST
+	tristate "Milkymist SoC read-only flash mapping driver"
+	depends on MTD_CFI
+	help
+	  Read-only flash memory access for Milkymist VJ SoC
+
 # This needs CFI or JEDEC, depending on the cards found.
 config MTD_PCI
 	tristate "PCI MTD driver"
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 970b189..058583d 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -71,3 +71,4 @@ obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_MILKYMIST)	+= milkymist_flash.o
diff --git a/drivers/mtd/maps/milkymist_flash.c b/drivers/mtd/maps/milkymist_flash.c
new file mode 100644
index 0000000..f155ad7
--- /dev/null
+++ b/drivers/mtd/maps/milkymist_flash.c
@@ -0,0 +1,99 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ /* Based on ecp250_flash.c */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/setup.h>
+
+static struct mtd_partition milkymist_partitions[] = {
+	{
+		.name = "Bios",
+		.size = 0x00040000, 	/* 256 kB */
+		.offset = 0x0000000
+	},
+	{
+		.name = "Linux Kernel",
+		.size = 0x00200000, 	/* 2 MB */
+		.offset = MTDPART_OFS_APPEND,
+	},
+	{
+		.name = "Rootfs",
+		.size = (0x00800000 - 0x40000 - 0x200000), /* rest to play with */
+		.offset = MTDPART_OFS_APPEND,
+	}
+};
+
+static struct map_info milkymist_map[1] = {
+	{
+		/* .name will be set from lm32tag_flash */
+		/* .phys will be set from lm32tag_flash */
+		/* .size will be set from lm32tag_flash */
+		.bankwidth = 2, /* always 32bit access with Mico32 */
+	}
+};
+
+static struct mtd_info *milkymist_flash_mtd[1] = {NULL};
+
+static void __exit  cleanup_milkymist_flash(void)
+{
+	int i;
+
+	for (i=0; i<2; i++) {
+		if (milkymist_flash_mtd[i]) {
+			del_mtd_partitions(milkymist_flash_mtd[i]);
+			map_destroy(milkymist_flash_mtd[i]);
+			iounmap(milkymist_map[0].virt);
+		}
+	}
+}
+
+static int __init init_milkymist_flash(void)
+{
+	printk("milkymist_flash: Flash driver initializing\n");
+
+	milkymist_map[0].name = "milkymist_flash";
+	milkymist_map[0].phys = 0x00000000;
+	milkymist_map[0].size = 0x800000;
+	milkymist_map[0].cached =
+	    ioremap(milkymist_map[0].phys, milkymist_map[0].size);
+
+	milkymist_map[0].virt = ioremap(milkymist_map[0].phys, milkymist_map[0].size);
+
+	milkymist_flash_mtd[0] = do_map_probe("map_rom", &milkymist_map[0]);
+	if (milkymist_flash_mtd[0]) {
+		milkymist_flash_mtd[0]->owner = THIS_MODULE;
+		add_mtd_partitions(milkymist_flash_mtd[0], milkymist_partitions, ARRAY_SIZE(milkymist_partitions));
+		return 0;
+	} else
+		printk("Probing flash device %s failed!\n", milkymist_map[0].name);
+
+	return -ENXIO;
+}
+
+module_init(init_milkymist_flash);
+module_exit(cleanup_milkymist_flash);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Milkymist MTD Mapping driver");
+MODULE_AUTHOR("Clark Xin, codinflu@gmail.com");
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index c551925..8e09b61 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -839,6 +839,14 @@ config ULTRA32
 	  <file:Documentation/networking/net-modules.txt>. The module
 	  will be called smc-ultra32.
 
+config OPEN_ETH
+	tristate "OpenCores Ethernet support"
+	default y
+	depends on NET_ETHERNET && PLAT_MILKYMIST
+	help
+	  This is the driver for ethmac from OpenCores, used as an early Ethernet
+	  controller in Milkymist with slight modifications.
+
 config BFIN_MAC
 	tristate "Blackfin 536/537 on-chip mac support"
 	depends on NET_ETHERNET && (BF537 || BF536) && (!BF537_PORT_H)
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 9c928a8..d5152ae 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -203,6 +203,7 @@ obj-$(CONFIG_MYRI10GE) += myri10ge/
 obj-$(CONFIG_SMC91X) += smc91x.o
 obj-$(CONFIG_SMC911X) += smc911x.o
 obj-$(CONFIG_BFIN_MAC) += bfin_mac.o
+obj-$(CONFIG_OPEN_ETH) += open_eth.o
 obj-$(CONFIG_DM9000) += dm9000.o
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
 obj-$(CONFIG_PASEMI_MAC) += pasemi_mac.o
diff --git a/drivers/net/open_eth.c b/drivers/net/open_eth.c
new file mode 100644
index 0000000..a35ad57
--- /dev/null
+++ b/drivers/net/open_eth.c
@@ -0,0 +1,986 @@
+/*
+ * Ethernet driver for Open Ethernet Controller (www.opencores.org).
+ *      Copyright (c) 2002 Simon Srot (simons@opencores.org) and OpenCores.org
+ *
+ * Changes:
+ * 10. 02. 2004: Matjaz Breskvar (phoenix@bsemi.com)
+ *   port to linux-2.4, workaround for next tx bd number. 
+ *
+ * Based on:
+ *
+ * Ethernet driver for Motorola MPC8xx.
+ *      Copyright (c) 1997 Dan Malek (dmalek@jlc.net)
+ *
+ * mcen302.c: A Linux network driver for Mototrola 68EN302 MCU
+ *
+ *      Copyright (C) 1999 Aplio S.A. Written by Vadim Lebedev
+ *
+ * Rigt now XXBUFF_PREALLOC must be used, bacause MAC does not 
+ * handle unaligned buffers yet.  Also the cache inhibit calls
+ * should be used some day.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+
+#include "open_eth.h"
+
+//#define DEBUG 1
+#undef DEBUG
+#define _print printk
+
+#ifdef DEBUG
+#define D(x) x
+#else
+#define D(x)
+#endif
+
+#define RXBUFF_PREALLOC	1
+#define TXBUFF_PREALLOC	1
+//#undef RXBUFF_PREALLOC
+//#undef TXBUFF_PREALLOC
+
+/* The transmitter timeout
+ */
+#define TX_TIMEOUT	(2*HZ)
+
+/* Buffer number (must be 2^n) 
+ */
+#define OETH_RXBD_NUM		8
+#define OETH_TXBD_NUM		8
+#define OETH_RXBD_NUM_MASK	(OETH_RXBD_NUM-1)
+#define OETH_TXBD_NUM_MASK	(OETH_TXBD_NUM-1)
+
+/* Buffer size 
+ */
+#define OETH_RX_BUFF_SIZE	2048
+#define OETH_TX_BUFF_SIZE	2048
+
+/* How many buffers per page 
+ */
+#define OETH_RX_BUFF_PPGAE	(PAGE_SIZE/OETH_RX_BUFF_SIZE)
+#define OETH_TX_BUFF_PPGAE	(PAGE_SIZE/OETH_TX_BUFF_SIZE)
+
+/* How many pages is needed for buffers 
+ */
+#define OETH_RX_BUFF_PAGE_NUM	(OETH_RXBD_NUM/OETH_RX_BUFF_PPGAE)
+#define OETH_TX_BUFF_PAGE_NUM	(OETH_TXBD_NUM/OETH_TX_BUFF_PPGAE)
+
+/* Buffer size  (if not XXBUF_PREALLOC 
+ */
+#define MAX_FRAME_SIZE		1518
+
+/* The buffer descriptors track the ring buffers.   
+ */
+struct oeth_private {
+	struct	sk_buff* rx_skbuff[OETH_RXBD_NUM];
+	struct	sk_buff* tx_skbuff[OETH_TXBD_NUM];
+
+	ushort	tx_next;			/* Next buffer to be sent */
+	ushort	tx_last;			/* Next buffer to be checked if packet sent */
+	ushort	tx_full;			/* Buffer ring fuul indicator */
+	ushort	rx_cur;				/* Next buffer to be checked if packet received */
+
+	oeth_regs	*regs;			/* Address of controller registers. */
+	oeth_bd		*rx_bd_base;		/* Address of Rx BDs. */
+	oeth_bd		*tx_bd_base;		/* Address of Tx BDs. */
+
+	struct net_device_stats stats;
+};
+
+static int oeth_open(struct net_device *dev);
+static int oeth_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static void oeth_rx(struct net_device *dev);
+static void oeth_tx(struct net_device *dev);
+static irqreturn_t oeth_interrupt(int irq, void *dev_id);
+static int oeth_close(struct net_device *dev);
+static struct net_device_stats *oeth_get_stats(struct net_device *dev);
+static void oeth_set_multicast_list(struct net_device *dev);
+static int oeth_set_mac_add(struct net_device *dev, void *addr);
+static int calc_crc(char *mac_addr);
+
+/* __PHX__ fixme for more ehternet drivers */
+#ifdef CONFIG_OETH_UNKNOWN_TX_NEXT
+static int tx_next = -1;
+#endif
+
+
+#ifdef DEBUG
+static void
+oeth_print_packet(unsigned long add, int len)
+{
+	int i;
+
+	_print("ipacket: add = %lx len = %d\n", add, len);
+	for(i = 0; i < len; i++) {
+  		if(!(i % 16))
+    			_print("\n");
+  		_print(" %.2x", *(((unsigned char *)add) + i));
+	}
+	_print("\n");
+}
+#endif
+
+static int
+oeth_open(struct net_device *dev)
+{
+#ifdef CONFIG_OETH_UNKNOWN_TX_NEXT
+	struct oeth_private *cep = (struct oeth_private *)dev->priv;
+#endif
+
+	oeth_regs *regs = (oeth_regs *)dev->base_addr;
+	D(printk("OPEN: net_device %p\n", dev));
+
+#ifdef CONFIG_OETH_UNKNOWN_TX_NEXT
+	if (tx_next != -1) {
+		cep->tx_next = tx_next;
+	}
+#endif
+
+
+#ifndef RXBUFF_PREALLOC
+	struct oeth_private *cep = (struct oeth_private *)dev->priv;
+	struct  sk_buff *skb;
+	volatile oeth_bd *rx_bd;
+	int i;
+
+	rx_bd = cep->rx_bd_base;
+
+	for(i = 0; i < OETH_RXBD_NUM; i++) {
+
+		skb = dev_alloc_skb(MAX_FRAME_SIZE);
+
+		if (skb == NULL)
+			rx_bd[i].len_status = (0 << 16) | OETH_RX_BD_IRQ;
+		else
+			rx_bd[i].len_status = (0 << 16) | OETH_RX_BD_EMPTY | OETH_RX_BD_IRQ;
+
+		cep->rx_skbuff[i] = skb;
+
+		rx_bd[i].addr = (unsigned long)skb->tail;
+	}
+	rx_bd[OETH_RXBD_NUM - 1].len_status |= OETH_RX_BD_WRAP;
+#endif
+
+	/* Install our interrupt handler.
+	 */
+	if(request_irq(IRQ_ETH_0, oeth_interrupt, 0, "eth", (void *)dev)) {
+		printk(KERN_NOTICE "Unable to attach OETH interrupt\n");
+#ifndef RXBUFF_PREALLOC
+		{
+			int i;
+
+			/* Free all alocated rx buffers 
+			*/
+			for (i = 0; i < OETH_RXBD_NUM; i++) {
+				
+				if (cep->rx_skbuff[i] != NULL)
+					dev_kfree_skb(cep->rx_skbuff[i]);
+				
+			}
+		}
+#endif
+#ifndef TXBUFF_PREALLOC
+		{
+			int i;
+			/* Free all alocated tx buffers 
+			*/
+			for (i = 0; i < OETH_TXBD_NUM; i++) {
+				
+				if (cep->tx_skbuff[i] != NULL)
+					dev_kfree_skb(cep->tx_skbuff[i]);
+			}
+		}
+#endif
+		return -EBUSY;
+	}
+
+	/* Enable receiver and transmiter 
+	 */
+	regs->moder |= OETH_MODER_RXEN | OETH_MODER_TXEN;
+
+	return 0;
+}
+
+static int
+oeth_close(struct net_device *dev)
+{
+#ifdef CONFIG_OETH_UNKNOWN_TX_NEXT
+	struct oeth_private *cep = (struct oeth_private *)dev->priv;
+#endif
+	oeth_regs *regs = (oeth_regs *)dev->base_addr;
+
+	D(printk("CLOSE: net_device %p\n", dev));
+
+	/* Free interrupt hadler 
+	 */
+	free_irq(IRQ_ETH_0, (void *)dev);
+
+	/* Disable receiver and transmitesr 
+	 */
+	regs->moder &= ~(OETH_MODER_RXEN | OETH_MODER_TXEN);	
+
+#ifndef RXBUFF_PREALLOC
+	{
+		int i;
+
+		/* Free all alocated rx buffers 
+		 */
+		for (i = 0; i < OETH_RXBD_NUM; i++) {
+			
+			if (cep->rx_skbuff[i] != NULL)
+				dev_kfree_skb(cep->rx_skbuff[i]);
+			
+		}
+	}
+#endif
+#ifndef TXBUFF_PREALLOC
+	{
+		int i;
+		/* Free all alocated tx buffers 
+		 */
+		for (i = 0; i < OETH_TXBD_NUM; i++) {
+			
+			if (cep->tx_skbuff[i] != NULL)
+				dev_kfree_skb(cep->tx_skbuff[i]);
+		}
+	}
+#endif
+
+#ifdef CONFIG_OETH_UNKNOWN_TX_NEXT
+	tx_next = cep->tx_next;
+#endif
+
+	return 0;
+}
+
+static int
+oeth_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct oeth_private *cep = (struct oeth_private *)dev->priv;
+	volatile oeth_bd *bdp;
+	unsigned long flags;
+
+	D(printk("X"));
+
+	/* Fill in a Tx ring entry 
+	 */
+	bdp = cep->tx_bd_base + cep->tx_next;
+
+	if (cep->tx_full) {
+
+		/* All transmit buffers are full.  Bail out.
+		 */
+		printk("%s: tx queue full!.\n", dev->name);
+		return 1;
+	}
+
+	/* Clear all of the status flags.
+	 */
+	bdp->len_status &= ~OETH_TX_BD_STATS;
+
+	/* If the frame is short, tell CPM to pad it.
+	 */
+	if (skb->len <= ETH_ZLEN)
+		bdp->len_status |= OETH_TX_BD_PAD;
+	else
+		bdp->len_status &= ~OETH_TX_BD_PAD;
+
+#ifdef DEBUG
+	_print("TX\n");
+	oeth_print_packet((unsigned long)skb->data, skb->len);
+#endif
+
+#ifdef TXBUFF_PREALLOC
+
+	/* Copy data in preallocated buffer */
+	if (skb->len > OETH_TX_BUFF_SIZE) {
+		printk("%s: tx frame too long!.\n", dev->name);
+		return 1;
+	}
+	else
+		memcpy((unsigned char *)__va(bdp->addr), skb->data, skb->len);
+
+	bdp->len_status = (bdp->len_status & 0x0000ffff) | (skb->len << 16);
+
+	dev_kfree_skb(skb);
+#else
+	/* Set buffer length and buffer pointer.
+	 */
+	bdp->len_status = (bdp->len_status & 0x0000ffff) | (skb->len << 16);
+	bdp->addr = (uint)__pa(skb->data);
+
+	/* Save skb pointer.
+	 */
+	cep->tx_skbuff[cep->tx_next] = skb;
+#endif
+
+	cep->tx_next = (cep->tx_next + 1) & OETH_TXBD_NUM_MASK;
+	
+	local_irq_save(flags);
+
+	if (cep->tx_next == cep->tx_last)
+		cep->tx_full = 1;
+
+	/* Send it on its way.  Tell controller its ready, interrupt when done,
+	 * and to put the CRC on the end.
+	 */
+	bdp->len_status |= (OETH_TX_BD_READY | OETH_TX_BD_IRQ | OETH_TX_BD_CRC);
+	
+	dev->trans_start = jiffies;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/* The interrupt handler.
+ */
+static irqreturn_t
+oeth_interrupt(int irq, void *dev_id)
+{
+	struct	net_device *dev = dev_id;
+	volatile struct	oeth_private *cep;
+	uint	int_events;
+	int serviced;
+	
+	serviced = 0;
+
+#ifdef DEBUG
+	printk(".");
+	
+	printk("\n=tx_ | %x | %x | %x | %x | %x | %x | %x | %x\n",
+	       ((oeth_bd *)(OETH_BD_BASE))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+8))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+16))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+24))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+32))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+40))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+48))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+56))->len_status);
+	
+	printk("=rx_ | %x | %x | %x | %x | %x | %x | %x | %x\n",
+	       ((oeth_bd *)(OETH_BD_BASE+64))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+64+8))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+64+16))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+64+24))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+64+32))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+64+40))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+64+48))->len_status,
+	       ((oeth_bd *)(OETH_BD_BASE+64+56))->len_status);
+#endif
+	
+	cep = (struct oeth_private *)dev->priv;
+
+	/* Get the interrupt events that caused us to be here.
+	 */
+	int_events = cep->regs->int_src;
+	cep->regs->int_src = int_events;
+
+	/* Handle receive event in its own function.
+	 */
+	if (int_events & (OETH_INT_RXF | OETH_INT_RXE)) {
+		D(serviced |= 0x1); 
+		oeth_rx(dev_id);
+	}
+
+	/* Handle transmit event in its own function.
+	 */
+	if (int_events & (OETH_INT_TXB | OETH_INT_TXE)) {
+		D(serviced |= 0x2);
+
+		oeth_tx(dev_id);
+		if (netif_queue_stopped(dev)) {
+			D(printk("n"));
+			netif_wake_queue(dev);
+		}
+	}
+
+	/* Check for receive busy, i.e. packets coming but no place to
+	 * put them. 
+	 */
+	if (int_events & OETH_INT_BUSY) {
+		D(serviced |= 0x4);
+		D(printk("b"));
+		if (!(int_events & (OETH_INT_RXF | OETH_INT_RXE)))
+			oeth_rx(dev_id);
+	}
+
+
+#if 0
+	if (serviced == 0) {
+		void die(const char * str, struct pt_regs * regs, long err);
+		int show_stack(unsigned long *esp);
+		printk("!");
+//		printk("unserviced irq\n");
+//		show_stack(NULL);
+//		die("unserviced irq\n", regs, 801);
+	}
+#endif
+
+#ifdef DEBUG
+	if (serviced == 0)
+		printk("\nnot serviced: events 0x%x, irq %d, dev %p\n",
+		       int_events, irq, dev_id);
+	else 
+		printk(" | serviced 0x%x, events 0x%x, irq %d, dev %p\n",
+		       serviced, int_events, irq, dev_id);
+#endif
+
+	return IRQ_HANDLED;
+}
+
+
+static void
+oeth_tx(struct net_device *dev)
+{
+	struct	oeth_private *cep;
+	volatile oeth_bd *bdp;
+
+#ifndef TXBUFF_PREALLOC
+	struct	sk_buff *skb;
+#endif
+	D(printk("T"));
+
+	cep = (struct oeth_private *)dev->priv;
+
+	for (;; cep->tx_last = (cep->tx_last + 1) & OETH_TXBD_NUM_MASK) {
+
+		bdp = cep->tx_bd_base + cep->tx_last;
+
+		if ((bdp->len_status & OETH_TX_BD_READY) || 
+			((cep->tx_last == cep->tx_next) && !cep->tx_full))
+			break;
+
+		/* Check status for errors
+		 */
+		if (bdp->len_status & OETH_TX_BD_LATECOL)
+			cep->stats.tx_window_errors++;
+		if (bdp->len_status & OETH_TX_BD_RETLIM)
+			cep->stats.tx_aborted_errors++;
+		if (bdp->len_status & OETH_TX_BD_UNDERRUN)
+			cep->stats.tx_fifo_errors++;
+		if (bdp->len_status & OETH_TX_BD_CARRIER)
+			cep->stats.tx_carrier_errors++;
+		if (bdp->len_status & (OETH_TX_BD_LATECOL | OETH_TX_BD_RETLIM | OETH_TX_BD_UNDERRUN))
+			cep->stats.tx_errors++;
+
+		cep->stats.tx_packets++;
+		cep->stats.collisions += (bdp->len_status >> 4) & 0x000f;
+
+#ifndef TXBUFF_PREALLOC
+		skb = cep->tx_skbuff[cep->tx_last];
+
+		/* Free the sk buffer associated with this last transmit.
+		*/
+		dev_kfree_skb(skb);
+#endif
+
+		if (cep->tx_full)
+			cep->tx_full = 0;
+	}
+}
+
+static void
+oeth_rx(struct net_device *dev)
+{
+	struct	oeth_private *cep;
+	volatile oeth_bd *bdp;
+	struct	sk_buff *skb;
+	int	pkt_len;
+	int	bad = 0;
+#ifndef RXBUFF_PREALLOC
+	struct	sk_buff *small_skb;
+#endif
+
+	asm volatile( /* Invalidate Level-1 data cache */
+		"wcsr DCC, r0\n"
+		"nop\n"
+	);
+
+	D(printk("r"));
+
+	cep = (struct oeth_private *)dev->priv;
+
+	/* First, grab all of the stats for the incoming packet.
+	 * These get messed up if we get called due to a busy condition.
+	 */
+	for (;;cep->rx_cur = (cep->rx_cur + 1) & OETH_RXBD_NUM_MASK) {
+
+		bdp = cep->rx_bd_base + cep->rx_cur;
+
+#ifndef RXBUFF_PREALLOC
+		skb = cep->rx_skbuff[cep->rx_cur];
+
+		if (skb == NULL) {
+
+			skb = dev_alloc_skb(MAX_FRAME_SIZE + 2);
+
+			if (skb != NULL)
+			{
+				bdp->addr = (unsigned long) skb->tail;
+				bdp->len_status |= OETH_RX_BD_EMPTY;
+			}
+			skb_reserve(skb, 2);
+
+			continue;
+		}
+#endif
+			
+		if (bdp->len_status & OETH_RX_BD_EMPTY)
+			break;
+			
+		/* Check status for errors.
+		 */
+		if (bdp->len_status & (OETH_RX_BD_TOOLONG | OETH_RX_BD_SHORT)) {
+			cep->stats.rx_length_errors++;
+			bad = 1;
+		}
+		if (bdp->len_status & OETH_RX_BD_DRIBBLE) {
+			cep->stats.rx_frame_errors++;
+			bad = 1;
+		}
+		if (bdp->len_status & OETH_RX_BD_CRCERR) {
+			cep->stats.rx_crc_errors++;
+			bad = 1;
+		}
+		if (bdp->len_status & OETH_RX_BD_OVERRUN) {
+			cep->stats.rx_crc_errors++;
+			bad = 1;
+		}
+		if (bdp->len_status & OETH_RX_BD_MISS) {
+
+		}
+		if (bdp->len_status & OETH_RX_BD_LATECOL) {
+			cep->stats.rx_frame_errors++;
+			bad = 1;
+		}
+		
+		
+		if (bad) {
+			bdp->len_status &= ~OETH_RX_BD_STATS;
+			bdp->len_status |= OETH_RX_BD_EMPTY;
+
+			continue;
+		}
+
+		/* Process the incoming frame.
+		 */
+		pkt_len = bdp->len_status >> 16;
+        
+#ifdef RXBUFF_PREALLOC
+		skb = dev_alloc_skb(pkt_len + 2);
+        
+		if (skb == NULL) {
+			printk("%s: Memory squeeze, dropping packet.\n", dev->name);
+			cep->stats.rx_dropped++;
+		}
+		else {
+			skb_reserve(skb, 2); /* longword align L3 header */
+			skb->dev = dev;
+#ifdef DEBUG
+			_print("RX\n");
+			oeth_print_packet((unsigned long)__va(bdp->addr), pkt_len);
+#endif
+			memcpy(skb_put(skb, pkt_len), (unsigned char *)__va(bdp->addr), pkt_len);
+			skb->protocol = eth_type_trans(skb,dev);
+			netif_rx(skb);
+			cep->stats.rx_packets++;
+		}
+
+		bdp->len_status &= ~OETH_RX_BD_STATS;
+		bdp->len_status |= OETH_RX_BD_EMPTY;
+#else
+
+		if (pkt_len < 128) {
+
+			small_skb = dev_alloc_skb(pkt_len);
+
+			if (small_skb) {
+				small_skb->dev = dev;
+#if DEBUG
+				_print("RX short\n");
+                                oeth_print_packet(__va(bdp->addr), bdp->len_status >> 16);
+#endif
+                                memcpy(skb_put(small_skb, pkt_len), (unsigned char *)__va(bdp->addr), pkt_len);
+                                small_skb->protocol = eth_type_trans(small_skb,dev);
+                                netif_rx(small_skb);
+				cep->stats.rx_packets++;
+			}
+			else {
+				printk("%s: Memory squeeze, dropping packet.\n", dev->name);
+	                        cep->stats.rx_dropped++;
+			}
+
+			bdp->len_status &= ~OETH_RX_BD_STATS;
+			bdp->len_status |= OETH_RX_BD_EMPTY;
+		}
+		else {
+        		skb->dev = dev;
+			skb_put(skb, bdp->len_status >> 16);
+			skb->protocol = eth_type_trans(skb,dev);
+			netif_rx(skb);
+			cep->stats.rx_packets++;
+#if DEBUG
+			_print("RX long\n");
+                        oeth_print_packet(__va(bdp->addr), bdp->len_status >> 16);
+#endif
+		
+			skb = dev_alloc_skb(MAX_FRAME_SIZE);
+
+			bdp->len_status &= ~OETH_RX_BD_STATS;
+        
+			if (skb) {
+				cep->rx_skbuff[cep->rx_cur] = skb;
+
+				bdp->addr = (unsigned long)skb->tail;
+				bdp->len_status |= OETH_RX_BD_EMPTY;
+			}
+			else {
+				cep->rx_skbuff[cep->rx_cur] = NULL;	
+			}
+		}
+#endif
+	}
+}
+
+static int calc_crc(char *mac_addr)
+{
+	int result = 0;
+	return (result & 0x3f);
+}
+
+static struct net_device_stats *oeth_get_stats(struct net_device *dev)
+{
+        struct oeth_private *cep = (struct oeth_private *)dev->priv;
+ 
+        return &cep->stats;
+}
+
+static void oeth_set_multicast_list(struct net_device *dev)
+{
+	struct	oeth_private *cep;
+	struct	dev_mc_list *dmi;
+	volatile oeth_regs *regs;
+	int	i;
+
+	cep = (struct oeth_private *)dev->priv;
+
+	/* Get pointer of controller registers.
+	 */
+	regs = (oeth_regs *)dev->base_addr;
+
+	if (dev->flags & IFF_PROMISC) {
+	  
+		/* Log any net taps. 
+		 */
+		printk("%s: Promiscuous mode enabled.\n", dev->name);
+		regs->moder |= OETH_MODER_PRO;
+	} else {
+
+		regs->moder &= ~OETH_MODER_PRO;
+
+		if (dev->flags & IFF_ALLMULTI) {
+
+			/* Catch all multicast addresses, so set the
+			 * filter to all 1's.
+			 */
+			regs->hash_addr0 = 0xffffffff;
+			regs->hash_addr1 = 0xffffffff;
+		}
+		else if (dev->mc_count) {
+
+			/* Clear filter and add the addresses in the list.
+			 */
+			regs->hash_addr0 = 0x00000000;
+			regs->hash_addr0 = 0x00000000;
+
+			dmi = dev->mc_list;
+
+			for (i = 0; i < dev->mc_count; i++) {
+				
+				int hash_b;
+
+				/* Only support group multicast for now.
+				 */
+				if (!(dmi->dmi_addr[0] & 1))
+					continue;
+
+				hash_b = calc_crc(dmi->dmi_addr); 
+				if(hash_b >= 32)
+					regs->hash_addr1 |= 1 << (hash_b - 32);
+				else
+					regs->hash_addr0 |= 1 << hash_b;
+			}
+		}
+	}
+}
+
+static int oeth_set_mac_add(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr=p;
+	volatile oeth_regs *regs;
+
+	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
+
+	regs = (oeth_regs *)dev->base_addr;
+
+	regs->mac_addr1 = 	addr->sa_data[0] << 8 	| 
+				addr->sa_data[1];
+        regs->mac_addr0 = 	addr->sa_data[2] << 24 	| 
+				addr->sa_data[3] << 16 	| 
+				addr->sa_data[4] << 8 	| 
+				addr->sa_data[5];	
+
+	return 0;
+}
+
+/* Initialize the Open Ethernet MAC.
+ */
+int __init oeth_init(void)
+{
+	struct net_device *dev;
+	struct oeth_private *cep;
+	volatile oeth_regs *regs;
+	volatile oeth_bd *tx_bd, *rx_bd;
+	int error, i, j, k;
+#ifdef SRAM_BUFF
+	unsigned long mem_addr = SRAM_BUFF_BASE;
+#else
+	unsigned long mem_addr;
+#endif
+
+	/* Create an Ethernet device instance.
+         */
+	dev = alloc_etherdev(sizeof(*cep));
+	if (!dev)
+		return -ENOMEM;
+	
+	cep = dev->priv;
+//	spin_lock_init(&cep->lock);
+
+	/* Get pointer ethernet controller configuration registers.
+	 */
+	cep->regs = (oeth_regs *)(OETH_REG_BASE);
+	regs = (oeth_regs *)(OETH_REG_BASE);
+
+	/* Reset the controller.
+	 */
+	regs->moder = OETH_MODER_RST;	/* Reset ON */
+	regs->moder &= ~OETH_MODER_RST;	/* Reset OFF */
+
+	/* Setting TXBD base to OETH_TXBD_NUM.
+	 */
+	regs->tx_bd_num = OETH_TXBD_NUM;
+	
+	/* Initialize TXBD pointer
+	 */
+	cep->tx_bd_base = (oeth_bd *)OETH_BD_BASE;
+	tx_bd = (volatile oeth_bd *)OETH_BD_BASE;
+
+	/* Initialize RXBD pointer
+	 */
+	cep->rx_bd_base = ((oeth_bd *)OETH_BD_BASE) + OETH_TXBD_NUM;
+	rx_bd = ((volatile oeth_bd *)OETH_BD_BASE) + OETH_TXBD_NUM;
+
+	/* Initialize transmit pointers.
+	 */
+	cep->rx_cur = 0;
+
+	/* workaround */
+#ifdef CONFIG_OETH_UNKNOWN_TX_NEXT
+	/* the first time use value passed by bootloader
+	 * __PHX__ fixme, this woun't work if you have this compiled as module
+	 */
+	{
+		int tmp_next = *((int *)(0xc0000000));
+		
+		/* sanity check */
+		if ((tmp_next >= 0) && (tmp_next < OETH_TXBD_NUM))
+			cep->tx_next = tmp_next;
+		else {
+			printk(KERN_WARNING "open_eth: illegal number of TX buffer descriptors passed (%d), using default (if you did not use ethernet before starting linux this is ok)\n",
+			       tmp_next);
+			cep->tx_next = 0;
+		}
+	}
+#else
+	/* or read it from eth register, or set it to 0 in eth */
+	cep->tx_next = 0;
+#endif
+	cep->tx_last = 0;
+	cep->tx_full = 0;
+
+	/* Set min/max packet length 
+	 */
+	regs->packet_len = 0x00400600;
+
+	/* Set IPGT register to recomended value 
+	 */
+	regs->ipgt = 0x00000012;
+
+	/* Set IPGR1 register to recomended value 
+	 */
+	regs->ipgr1 = 0x0000000c;
+
+	/* Set IPGR2 register to recomended value 
+	 */
+	regs->ipgr2 = 0x00000012;
+
+	/* Set COLLCONF register to recomended value 
+	 */
+	regs->collconf = 0x000f003f;
+
+	/* Set control module mode 
+	 */
+#if 0
+	regs->ctrlmoder = OETH_CTRLMODER_TXFLOW | OETH_CTRLMODER_RXFLOW;
+#else
+	regs->ctrlmoder = 0;
+#endif
+
+  /* Set PHY to show Tx status, Rx status and Link status */
+  regs->miiaddress = 20<<8;
+  regs->miitx_data = 0x1422;
+  regs->miicommand = OETH_MIICOMMAND_WCTRLDATA;
+   
+#ifdef TXBUFF_PREALLOC
+
+	/* Initialize TXBDs.
+	 */
+	for(i = 0, k = 0; i < OETH_TX_BUFF_PAGE_NUM; i++) {
+
+#ifndef SRAM_BUFF
+		mem_addr = __get_free_page(GFP_KERNEL);
+#endif
+
+		for(j = 0; j < OETH_TX_BUFF_PPGAE; j++, k++) {
+			tx_bd[k].len_status = OETH_TX_BD_PAD | OETH_TX_BD_CRC | OETH_RX_BD_IRQ;
+			tx_bd[k].addr = __pa(mem_addr);
+			mem_addr += OETH_TX_BUFF_SIZE;
+		}
+	}
+	tx_bd[OETH_TXBD_NUM - 1].len_status |= OETH_TX_BD_WRAP;
+#else
+
+ 	/* Initialize TXBDs.
+	 */
+	for(i = 0; i < OETH_TXBD_NUM; i++) {
+
+		cep->tx_skbuff[i] = NULL;
+
+		tx_bd[i].len_status = (0 << 16) | OETH_TX_BD_PAD | OETH_TX_BD_CRC | OETH_RX_BD_IRQ;
+		tx_bd[i].addr = 0;
+	}
+	tx_bd[OETH_TXBD_NUM - 1].len_status |= OETH_TX_BD_WRAP;
+#endif
+
+#ifdef RXBUFF_PREALLOC
+
+	/* Initialize RXBDs.
+	 */
+	for(i = 0, k = 0; i < OETH_RX_BUFF_PAGE_NUM; i++) {
+
+#ifndef SRAM_BUFF
+		mem_addr = __get_free_page(GFP_KERNEL);
+#endif
+
+		for(j = 0; j < OETH_RX_BUFF_PPGAE; j++, k++) {
+			rx_bd[k].len_status = OETH_RX_BD_EMPTY | OETH_RX_BD_IRQ;
+			rx_bd[k].addr = __pa(mem_addr);
+			mem_addr += OETH_RX_BUFF_SIZE;
+		}
+	}
+	rx_bd[OETH_RXBD_NUM - 1].len_status |= OETH_RX_BD_WRAP;
+
+#else
+	/* Initialize RXBDs.
+	 */
+	for(i = 0; i < OETH_RXBD_NUM; i++) {
+
+
+		rx_bd[i].len_status = (0 << 16) | OETH_RX_BD_IRQ;
+
+		cep->rx_skbuff[i] = NULL;
+
+		rx_bd[i].addr = 0;
+	}
+	rx_bd[OETH_RXBD_NUM - 1].len_status |= OETH_RX_BD_WRAP;
+
+#endif
+
+	/* Set default ethernet station address.
+	 */
+	dev->dev_addr[0] = MACADDR0;
+	dev->dev_addr[1] = MACADDR1;
+	dev->dev_addr[2] = MACADDR2;
+	dev->dev_addr[3] = MACADDR3;
+	dev->dev_addr[4] = MACADDR4;
+	dev->dev_addr[5] = MACADDR5;
+
+	regs->mac_addr1 = MACADDR0 << 8 | MACADDR1;
+	regs->mac_addr0 = MACADDR2 << 24 | MACADDR3 << 16 | MACADDR4 << 8 | MACADDR5;
+	
+	/* Clear all pending interrupts 
+	 */
+	regs->int_src = 0xffffffff;
+
+	/* Promisc, IFG, CRCEn
+	 */
+	regs->moder |= OETH_MODER_PAD | OETH_MODER_IFG | OETH_MODER_CRCEN;
+
+	/* Enable interrupt sources.
+	 */
+	regs->int_mask = OETH_INT_MASK_TXB 	| 
+		OETH_INT_MASK_TXE 	| 
+		OETH_INT_MASK_RXF 	| 
+		OETH_INT_MASK_RXE 	|
+		OETH_INT_MASK_BUSY 	|
+		OETH_INT_MASK_TXC	|
+		OETH_INT_MASK_RXC;
+
+	/* Fill in the fields of the device structure with ethernet values. 
+	 */
+	ether_setup(dev);
+
+	dev->base_addr = (unsigned long)OETH_REG_BASE;
+
+	/* The Open Ethernet specific entries in the device structure. 
+	 */
+	dev->open = oeth_open;
+	dev->hard_start_xmit = oeth_start_xmit;
+	dev->stop = oeth_close;
+	dev->get_stats = oeth_get_stats;
+	dev->set_multicast_list = oeth_set_multicast_list;
+	dev->set_mac_address = oeth_set_mac_add;
+
+	if ((error = register_netdev(dev))) {
+		free_netdev(dev);
+		return error;
+	}
+
+	printk("%s: Open Ethernet Core Version 1.0\n", dev->name);
+
+	return 0;
+}
+
+module_init(oeth_init);
diff --git a/drivers/net/open_eth.h b/drivers/net/open_eth.h
new file mode 100644
index 0000000..b78b96a
--- /dev/null
+++ b/drivers/net/open_eth.h
@@ -0,0 +1,152 @@
+
+/* Ethernet configuration registers */
+typedef struct _oeth_regs {
+        uint    moder;          /* Mode Register */
+        uint    int_src;        /* Interrupt Source Register */
+        uint    int_mask;       /* Interrupt Mask Register */
+        uint    ipgt;           /* Back to Bak Inter Packet Gap Register */
+        uint    ipgr1;          /* Non Back to Back Inter Packet Gap Register 1 */
+        uint    ipgr2;          /* Non Back to Back Inter Packet Gap Register 2 */
+        uint    packet_len;     /* Packet Length Register (min. and max.) */
+        uint    collconf;       /* Collision and Retry Configuration Register */
+        uint    tx_bd_num;      /* Transmit Buffer Descriptor Number Register */
+        uint    ctrlmoder;      /* Control Module Mode Register */
+        uint    miimoder;       /* MII Mode Register */
+        uint    miicommand;     /* MII Command Register */
+        uint    miiaddress;     /* MII Address Register */
+        uint    miitx_data;     /* MII Transmit Data Register */
+        uint    miirx_data;     /* MII Receive Data Register */
+        uint    miistatus;      /* MII Status Register */
+        uint    mac_addr0;      /* MAC Individual Address Register 0 */
+        uint    mac_addr1;      /* MAC Individual Address Register 1 */
+        uint    hash_addr0;     /* Hash Register 0 */
+        uint    hash_addr1;     /* Hash Register 1 */                           
+} oeth_regs;
+
+/* Ethernet buffer descriptor */
+typedef struct _oeth_bd {
+#if 0
+        ushort  len;            /* Buffer length */
+        ushort  status;         /* Buffer status */
+#else
+        uint    len_status;
+#endif
+        uint    addr;           /* Buffer address */
+} oeth_bd;
+
+#define OETH_REG_BASE           0xc0000000
+#define OETH_BD_BASE            0xc0000400
+#define OETH_TOTAL_BD           128
+#define OETH_MAXBUF_LEN         0x600
+                                
+/* Tx BD */                     
+#define OETH_TX_BD_READY        0x8000 /* Tx BD Ready */
+#define OETH_TX_BD_IRQ          0x4000 /* Tx BD IRQ Enable */
+#define OETH_TX_BD_WRAP         0x2000 /* Tx BD Wrap (last BD) */
+#define OETH_TX_BD_PAD          0x1000 /* Tx BD Pad Enable */
+#define OETH_TX_BD_CRC          0x0800 /* Tx BD CRC Enable */
+                                
+#define OETH_TX_BD_UNDERRUN     0x0100 /* Tx BD Underrun Status */
+#define OETH_TX_BD_RETRY        0x00F0 /* Tx BD Retry Status */
+#define OETH_TX_BD_RETLIM       0x0008 /* Tx BD Retransmission Limit Status */
+#define OETH_TX_BD_LATECOL      0x0004 /* Tx BD Late Collision Status */
+#define OETH_TX_BD_DEFER        0x0002 /* Tx BD Defer Status */
+#define OETH_TX_BD_CARRIER      0x0001 /* Tx BD Carrier Sense Lost Status */
+#define OETH_TX_BD_STATS        (OETH_TX_BD_UNDERRUN            | \
+                                OETH_TX_BD_RETRY                | \
+                                OETH_TX_BD_RETLIM               | \
+                                OETH_TX_BD_LATECOL              | \
+                                OETH_TX_BD_DEFER                | \
+                                OETH_TX_BD_CARRIER)
+                                
+/* Rx BD */                     
+#define OETH_RX_BD_EMPTY        0x8000 /* Rx BD Empty */
+#define OETH_RX_BD_IRQ          0x4000 /* Rx BD IRQ Enable */
+#define OETH_RX_BD_WRAP         0x2000 /* Rx BD Wrap (last BD) */
+                                
+#define OETH_RX_BD_MISS         0x0080 /* Rx BD Miss Status */
+#define OETH_RX_BD_OVERRUN      0x0040 /* Rx BD Overrun Status */
+#define OETH_RX_BD_INVSIMB      0x0020 /* Rx BD Invalid Symbol Status */
+#define OETH_RX_BD_DRIBBLE      0x0010 /* Rx BD Dribble Nibble Status */
+#define OETH_RX_BD_TOOLONG      0x0008 /* Rx BD Too Long Status */
+#define OETH_RX_BD_SHORT        0x0004 /* Rx BD Too Short Frame Status */
+#define OETH_RX_BD_CRCERR       0x0002 /* Rx BD CRC Error Status */
+#define OETH_RX_BD_LATECOL      0x0001 /* Rx BD Late Collision Status */
+#define OETH_RX_BD_STATS        (OETH_RX_BD_MISS                | \
+                                OETH_RX_BD_OVERRUN              | \
+                                OETH_RX_BD_INVSIMB              | \
+                                OETH_RX_BD_DRIBBLE              | \
+                                OETH_RX_BD_TOOLONG              | \
+                                OETH_RX_BD_SHORT                | \
+                                OETH_RX_BD_CRCERR               | \
+                                OETH_RX_BD_LATECOL)
+
+/* MODER Register */
+#define OETH_MODER_RXEN         0x00000001 /* Receive Enable  */
+#define OETH_MODER_TXEN         0x00000002 /* Transmit Enable */
+#define OETH_MODER_NOPRE        0x00000004 /* No Preamble  */
+#define OETH_MODER_BRO          0x00000008 /* Reject Broadcast */
+#define OETH_MODER_IAM          0x00000010 /* Use Individual Hash */
+#define OETH_MODER_PRO          0x00000020 /* Promiscuous (receive all) */
+#define OETH_MODER_IFG          0x00000040 /* Min. IFG not required */
+#define OETH_MODER_LOOPBCK      0x00000080 /* Loop Back */
+#define OETH_MODER_NOBCKOF      0x00000100 /* No Backoff */
+#define OETH_MODER_EXDFREN      0x00000200 /* Excess Defer */
+#define OETH_MODER_FULLD        0x00000400 /* Full Duplex */
+#define OETH_MODER_RST          0x00000800 /* Reset MAC */
+#define OETH_MODER_DLYCRCEN     0x00001000 /* Delayed CRC Enable */
+#define OETH_MODER_CRCEN        0x00002000 /* CRC Enable */
+#define OETH_MODER_HUGEN        0x00004000 /* Huge Enable */
+#define OETH_MODER_PAD          0x00008000 /* Pad Enable */
+#define OETH_MODER_RECSMALL     0x00010000 /* Receive Small */
+ 
+/* Interrupt Source Register */
+#define OETH_INT_TXB            0x00000001 /* Transmit Buffer IRQ */
+#define OETH_INT_TXE            0x00000002 /* Transmit Error IRQ */
+#define OETH_INT_RXF            0x00000004 /* Receive Frame IRQ */
+#define OETH_INT_RXE            0x00000008 /* Receive Error IRQ */
+#define OETH_INT_BUSY           0x00000010 /* Busy IRQ */
+#define OETH_INT_TXC            0x00000020 /* Transmit Control Frame IRQ */
+#define OETH_INT_RXC            0x00000040 /* Received Control Frame IRQ */
+
+/* Interrupt Mask Register */
+#define OETH_INT_MASK_TXB       0x00000001 /* Transmit Buffer IRQ Mask */
+#define OETH_INT_MASK_TXE       0x00000002 /* Transmit Error IRQ Mask */
+#define OETH_INT_MASK_RXF       0x00000004 /* Receive Frame IRQ Mask */
+#define OETH_INT_MASK_RXE       0x00000008 /* Receive Error IRQ Mask */
+#define OETH_INT_MASK_BUSY      0x00000010 /* Busy IRQ Mask */
+#define OETH_INT_MASK_TXC       0x00000020 /* Transmit Control Frame IRQ Mask */
+#define OETH_INT_MASK_RXC       0x00000040 /* Received Control Frame IRQ Mask */
+ 
+/* Control Module Mode Register */
+#define OETH_CTRLMODER_PASSALL  0x00000001 /* Pass Control Frames */
+#define OETH_CTRLMODER_RXFLOW   0x00000002 /* Receive Control Flow Enable */
+#define OETH_CTRLMODER_TXFLOW   0x00000004 /* Transmit Control Flow Enable */
+                               
+/* MII Mode Register */        
+#define OETH_MIIMODER_CLKDIV    0x000000FF /* Clock Divider */
+#define OETH_MIIMODER_NOPRE     0x00000100 /* No Preamble */
+#define OETH_MIIMODER_RST       0x00000200 /* MIIM Reset */
+ 
+/* MII Command Register */
+#define OETH_MIICOMMAND_SCANSTAT  0x00000001 /* Scan Status */
+#define OETH_MIICOMMAND_RSTAT     0x00000002 /* Read Status */
+#define OETH_MIICOMMAND_WCTRLDATA 0x00000004 /* Write Control Data */
+ 
+/* MII Address Register */
+#define OETH_MIIADDRESS_FIAD    0x0000001F /* PHY Address */
+#define OETH_MIIADDRESS_RGAD    0x00001F00 /* RGAD Address */
+ 
+/* MII Status Register */
+#define OETH_MIISTATUS_LINKFAIL 0x00000001 /* Link Fail */
+#define OETH_MIISTATUS_BUSY     0x00000002 /* MII Busy */
+#define OETH_MIISTATUS_NVALID   0x00000004 /* Data in MII Status Register is invalid */
+
+/* TODO */
+#define IRQ_ETH_0 13
+#define MACADDR0 0x00
+#define MACADDR1 0x1e
+#define MACADDR2 0xde
+#define MACADDR3 0xad
+#define MACADDR4 0xbe
+#define MACADDR5 0xef
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 81b52b7..1cdf2d7 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -1259,4 +1259,18 @@ config SERIAL_OF_PLATFORM
 	  Currently, only 8250 compatible ports are supported, but
 	  others can easily be added.
 
+config SERIAL_MILKYMIST
+	bool "Enable Milkymist UART driver"
+	depends on LM32
+	select SERIAL_CORE
+	help
+	  Enable Milkymist UART driver.
+
+config SERIAL_MILKYMIST_CONSOLE
+	bool "Enable Milkymist UART driver as system console"
+	depends on SERIAL_MILKYMIST
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow to use the Milkymist UART driver as system console.
+
 endmenu
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index af6377d..f9cdbed 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -64,3 +64,4 @@ obj-$(CONFIG_SERIAL_UARTLITE) += uartlite.o
 obj-$(CONFIG_SERIAL_NETX) += netx-serial.o
 obj-$(CONFIG_SERIAL_OF_PLATFORM) += of_serial.o
 obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
+obj-$(CONFIG_SERIAL_MILKYMIST) += milkymist_uart.o
diff --git a/drivers/serial/milkymist_uart.c b/drivers/serial/milkymist_uart.c
new file mode 100644
index 0000000..1133fc8
--- /dev/null
+++ b/drivers/serial/milkymist_uart.c
@@ -0,0 +1,498 @@
+/*
+ * (C) Copyright 2009 Sebastien Bourdeauducq
+ * (C) Copyright 2007 Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+
+#define MMPTR(x)		(*((volatile unsigned int *)(x)))
+
+#define CSR_UART_RXTX		MMPTR(0x80000000)
+#define CSR_UART_DIVISOR	MMPTR(0x80000004)
+
+#define IRQ_UARTRX		(3)
+#define IRQ_UARTTX		(4)
+
+#define MILKYMISTUART_DRIVERNAME "milkymist_uart"
+#define MILKYMISTUART_DEVICENAME "ttyS"
+#define MILKYMISTUART_MAJOR TTY_MAJOR
+#define MILKYMISTUART_MINOR 64
+
+static volatile int tx_cts;
+
+/* these two will be initialized by milkymistuart_init */
+static struct uart_port milkymistuart_ports[1];
+
+static struct uart_port* __devinit milkymistuart_init_port(struct platform_device *pdev);
+
+static unsigned int milkymistuart_tx_empty(struct uart_port *port);
+static void milkymistuart_set_mctrl(struct uart_port *port, unsigned int mctrl);
+static unsigned int milkymistuart_get_mctrl(struct uart_port *port);
+static void milkymistuart_start_tx(struct uart_port *port);
+static void milkymistuart_stop_tx(struct uart_port *port);
+static void milkymistuart_stop_rx(struct uart_port *port);
+static void milkymistuart_enable_ms(struct uart_port *port);
+static void milkymistuart_break_ctl(struct uart_port *port, int break_state);
+static int milkymistuart_startup(struct uart_port *port);
+static void milkymistuart_shutdown(struct uart_port *port);
+static void milkymistuart_set_termios(struct uart_port *port, struct ktermios *termios, struct ktermios *old);
+static const char *milkymistuart_type(struct uart_port *port);
+static void milkymistuart_release_port(struct uart_port *port);
+static int milkymistuart_request_port(struct uart_port *port);
+static void milkymistuart_config_port(struct uart_port *port, int flags);
+static int milkymistuart_verify_port(struct uart_port *port, struct serial_struct *ser);
+
+static inline void milkymistuart_set_baud_rate(struct uart_port *port, unsigned long baud);
+static irqreturn_t milkymistuart_irq_rx(int irq, void* portarg);
+static irqreturn_t milkymistuart_irq_tx(int irq, void* portarg);
+
+static struct uart_ops milkymistuart_pops = {
+	.tx_empty	= milkymistuart_tx_empty,
+	.set_mctrl	= milkymistuart_set_mctrl,
+	.get_mctrl	= milkymistuart_get_mctrl,
+	.stop_tx	= milkymistuart_stop_tx,
+	.start_tx	= milkymistuart_start_tx,
+	.stop_rx	= milkymistuart_stop_rx,
+	.enable_ms	= milkymistuart_enable_ms,
+	.break_ctl	= milkymistuart_break_ctl,
+	.startup	= milkymistuart_startup,
+	.shutdown	= milkymistuart_shutdown,
+	.set_termios	= milkymistuart_set_termios,
+	.type		= milkymistuart_type,
+	.release_port	= milkymistuart_release_port,
+	.request_port	= milkymistuart_request_port,
+	.config_port	= milkymistuart_config_port,
+	.verify_port	= milkymistuart_verify_port
+};
+
+static inline void milkymistuart_set_baud_rate(struct uart_port *port, unsigned long baud)
+{
+	CSR_UART_DIVISOR = 100000000 / baud / 16;
+}
+
+static void milkymistuart_tx_next_char(struct uart_port* port)
+{
+	struct circ_buf *xmit = &(port->info->xmit);
+
+	if (port->x_char) {
+		/* send xon/xoff character */
+		tx_cts = 0;
+		CSR_UART_RXTX = port->x_char;
+		port->x_char = 0;
+		port->icount.tx++;
+		return;
+	}
+
+	/* stop transmitting if buffer empty */
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		tx_cts = 1;
+		return;
+	}
+
+	/* send next character */
+	tx_cts = 0;
+	CSR_UART_RXTX = xmit->buf[xmit->tail];
+	xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+	port->icount.tx++;
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+#if 1
+while(!(lm32_irq_pending() & (1 << IRQ_UARTTX)));
+#endif
+}
+
+static void milkymistuart_rx_next_char(struct uart_port* port)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned char ch;
+
+	ch = CSR_UART_RXTX & 0xFF;
+	port->icount.rx++;
+
+	if (uart_handle_sysrq_char(port, ch))
+		goto ignore_char;
+
+	tty_insert_flip_char(tty, ch, TTY_NORMAL);
+
+ignore_char:
+	tty_flip_buffer_push(tty);
+}
+
+static irqreturn_t milkymistuart_irq_rx(int irq, void* portarg)
+{
+	struct uart_port* port = (struct uart_port*)portarg;
+
+	milkymistuart_rx_next_char(port);
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t milkymistuart_irq_tx(int irq, void* portarg)
+{
+	struct uart_port* port = (struct uart_port*)portarg;
+
+	lm32_irq_mask(IRQ_UARTTX);
+	milkymistuart_tx_next_char(port);
+	lm32_irq_unmask(IRQ_UARTTX);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int milkymistuart_tx_empty(struct uart_port *port)
+{
+	return TIOCSER_TEMT;
+}
+
+static void milkymistuart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* no modem control */
+}
+
+static unsigned int milkymistuart_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+static void milkymistuart_start_tx(struct uart_port *port)
+{
+	if (tx_cts) {
+		struct circ_buf *xmit = &(port->info->xmit);
+
+		if (port->x_char) {
+			/* send xon/xoff character */
+			tx_cts = 0;
+			CSR_UART_RXTX = port->x_char;
+			port->x_char = 0;
+			port->icount.tx++;
+			return 0;
+		}
+
+		/* stop transmitting if buffer empty */
+		if (uart_circ_empty(xmit) || uart_tx_stopped(port))
+			return 0;
+
+		/* send next character */
+		tx_cts = 0;
+		CSR_UART_RXTX = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+
+		if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+			uart_write_wakeup(port);
+	}
+	return 0;
+}
+
+static void milkymistuart_stop_tx(struct uart_port *port)
+{
+	return 0;
+}
+
+
+static void milkymistuart_stop_rx(struct uart_port *port)
+{
+	return 0;
+}
+
+static void milkymistuart_enable_ms(struct uart_port *port)
+{
+}
+
+static void milkymistuart_break_ctl(struct uart_port *port, int break_state)
+{
+}
+
+static int milkymistuart_startup(struct uart_port *port)
+{
+	if( request_irq(IRQ_UARTRX, milkymistuart_irq_rx,
+				IRQF_DISABLED, "milkymist_uart RX", port) ) {
+		printk(KERN_NOTICE "Unable to attach Milkymist UART RX interrupt\n");
+		return -EBUSY;
+	}
+	if( request_irq(IRQ_UARTTX, milkymistuart_irq_tx,
+				IRQF_DISABLED, "milkymist_uart TX", port) ) {
+		printk(KERN_NOTICE "Unable to attach Milkymist UART TX interrupt\n");
+		return -EBUSY;
+	}
+
+	lm32_irq_unmask(IRQ_UARTRX);
+	lm32_irq_unmask(IRQ_UARTTX);
+
+	return 0;
+}
+
+static void milkymistuart_shutdown(struct uart_port *port)
+{
+	free_irq(IRQ_UARTRX, port);
+	free_irq(IRQ_UARTTX, port);
+}
+
+static void milkymistuart_set_termios(
+		struct uart_port *port, struct ktermios *termios, struct ktermios *old)
+{
+	unsigned long baud;
+	unsigned long flags;
+
+	/* >> 4 means / 16 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk >> 4);
+
+	/* deactivate irqs */
+	spin_lock_irqsave(&port->lock, flags);
+
+	milkymistuart_set_baud_rate(port, baud);
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/* restore irqs */
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *milkymistuart_type(struct uart_port *port)
+{
+	/* check, to be on the safe side */
+	if( port->type == PORT_MILKYMISTUART )
+		return "milkymist_uart";
+	else
+		return "error";
+}
+
+static void milkymistuart_release_port(struct uart_port *port)
+{
+}
+
+static int milkymistuart_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+/* we will only configure the port type here */
+static void milkymistuart_config_port(struct uart_port *port, int flags)
+{
+	if( flags & UART_CONFIG_TYPE ) {
+		port->type = PORT_MILKYMISTUART;
+	}
+}
+
+/* we do not allow the user to configure via this method */
+static int milkymistuart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	return -EINVAL;
+}
+
+#ifdef CONFIG_SERIAL_MILKYMIST_CONSOLE
+static void milkymist_console_putchar(struct uart_port *port, int ch)
+{
+	CSR_UART_RXTX = ch;
+	while(!(lm32_irq_pending() & (1 << IRQ_UARTTX)));
+	lm32_irq_ack(IRQ_UARTTX);
+}
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void milkymist_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = &milkymistuart_ports[co->index];
+
+	uart_console_write(port, s, count, milkymist_console_putchar);
+}
+
+static int __init milkymist_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port = &milkymistuart_ports[co->index];
+
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver milkymistuart_driver;
+
+static struct console milkymist_console = {
+	.name		= MILKYMISTUART_DEVICENAME,
+	.write		= milkymist_console_write,
+	.device		= uart_console_device,
+	.setup		= milkymist_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &milkymistuart_driver,
+};
+
+/*
+ * Early console initialization
+ */
+static int __init milkymist_early_console_init(void)
+{
+	add_preferred_console(MILKYMISTUART_DEVICENAME, milkymistuart_default_console_device->id, NULL);
+	milkymistuart_init_port(&milkymistuart_default_console_device);
+	register_console(&milkymist_console);
+	pr_info("milkymist_uart: registered real console\n");
+	return 0;
+}
+console_initcall(milkymist_early_console_init);
+
+/*
+ * Late console initialization
+ */
+static int __init milkymist_late_console_init(void)
+{
+	if( !(milkymist_console.flags & CON_ENABLED) ) {
+		register_console(&milkymist_console);
+		pr_info("milkymist_uart: registered real console\n");
+	}
+	return 0;
+}
+core_initcall(milkymist_late_console_init);
+
+#define MILKYMIST_CONSOLE_DEVICE	&milkymist_console
+#else
+#define MILKYMIST_CONSOLE_DEVICE	NULL
+#endif
+
+static struct uart_driver milkymistuart_driver = {
+	.owner       = THIS_MODULE,
+	.driver_name = MILKYMISTUART_DRIVERNAME,
+	.dev_name    = MILKYMISTUART_DEVICENAME,
+	.major       = MILKYMISTUART_MAJOR,
+	.minor       = MILKYMISTUART_MINOR,
+	.nr          = 0, /* will be filled by init */
+	.cons        = MILKYMIST_CONSOLE_DEVICE
+};
+
+static struct uart_port* __devinit milkymistuart_init_port(struct platform_device *pdev)
+{
+	struct uart_port* port;
+	
+	port = &milkymistuart_ports[0];
+	port->type = PORT_MILKYMISTUART;
+	port->iobase = (void __iomem*)0x0;
+	port->membase = (void __iomem*)0x80000000;
+	port->irq = IRQ_UARTRX;
+	port->uartclk = cpu_frequency;
+	port->flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF; // TODO perhaps this is not completely correct
+	port->iotype = UPIO_PORT; // TODO perhaps this is not completely correct
+	port->regshift = 0;
+	port->ops = &milkymistuart_pops;
+	port->line = 0;
+	port->private_data = NULL;
+	return port;
+}
+
+static int __devinit milkymistuart_serial_probe(struct platform_device *pdev)
+{
+	struct uart_port *port;
+	int ret;
+
+	if( pdev->id != 0 )
+		return -1;
+
+	port = milkymistuart_init_port(pdev);
+
+	ret = uart_add_one_port(&milkymistuart_driver, port);
+	if (!ret) {
+		pr_info("milkymist_uart: added port %d with irq %d-%d at 0x%lx\n",
+				port->line, IRQ_UARTRX, IRQ_UARTTX, (unsigned long)port->membase);
+		device_init_wakeup(&pdev->dev, 1);
+		platform_set_drvdata(pdev, port);
+	} else
+		printk(KERN_ERR "milkymist_uart: could not add port %d: %d\n", port->line, ret);
+
+	return ret;
+}
+
+static int __devexit milkymistuart_serial_remove(struct platform_device *pdev)
+{
+	struct uart_port *port = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	device_init_wakeup(&pdev->dev, 0);
+	platform_set_drvdata(pdev, NULL);
+
+	if (port) {
+		ret = uart_remove_one_port(&milkymistuart_driver, port);
+		kfree(port);
+	}
+
+	return ret;
+}
+
+static struct platform_driver milkymistuart_serial_driver = {
+	.probe		= milkymistuart_serial_probe,
+	.remove		= __devexit_p(milkymistuart_serial_remove),
+	.driver		= {
+		.name	= "milkymist_uart",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init milkymistuart_init(void)
+{
+	int ret;
+	
+	pr_info("milkymist_uart: Milkymist UART driver\n");
+
+	/* configure from hardware setup structures */
+	milkymistuart_driver.nr = 1;
+	tx_cts = 1;
+	ret = uart_register_driver(&milkymistuart_driver);
+	if( ret < 0 )
+		return ret;
+
+	ret = platform_driver_register(&milkymistuart_serial_driver);
+	if( ret < 0 )
+		uart_unregister_driver(&milkymistuart_driver);
+
+	return ret;
+}
+
+static void __exit milkymistuart_exit(void)
+{
+	platform_driver_unregister(&milkymistuart_serial_driver);
+	uart_unregister_driver(&milkymistuart_driver);
+}
+
+module_init(milkymistuart_init);
+module_exit(milkymistuart_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Milkymist UART driver");
+MODULE_AUTHOR("Milkymist Project");
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 5216c11..ca3bf4f 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1833,6 +1833,16 @@ config FB_XILINX
 	  framebuffer. ML300 carries a 640*480 LCD display on the board,
 	  ML403 uses a standard DB15 VGA connector.
 
+config FB_MILKYMIST
+	bool "Milkymist framebuffer support"
+	depends on (FB = y) && PLAT_MILKYMIST
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	help
+	  Say Y here to enable support for Milkymist RGB Framebuffer
+
 if ARCH_OMAP
 	source "drivers/video/omap/Kconfig"
 endif
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 06eec7b..6bca8c1 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -112,6 +112,7 @@ obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
 obj-$(CONFIG_FB_PS3)		  += ps3fb.o
 obj-$(CONFIG_FB_SM501)            += sm501fb.o
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
+obj-$(CONFIG_FB_MILKYMIST)        += milkymistfb.o
 obj-$(CONFIG_FB_OMAP)             += omap/
 
 # Platform or fallback drivers go here
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index e58c87b..0b21a84 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -440,6 +440,25 @@ static irqreturn_t fb_vbl_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 #endif
+
+#ifdef CONFIG_PLAT_MILKYMIST
+#ifndef	FMLBRG_FLUSH_BASE
+#define	FMLBRG_FLUSH_BASE	(0x44000000)
+#define	FMLBRG_LINE_LENGTH	(32)
+#define	FMLBRG_LINE_COUNT	(512)
+#endif
+void flush_bridge_cache()
+{
+        volatile char *flushbase = (char *)FMLBRG_FLUSH_BASE;
+        int i, offset;
+
+        offset = 0;
+        for(i=0;i<FMLBRG_LINE_COUNT;i++) {
+                flushbase[offset] = 0;
+                offset += FMLBRG_LINE_LENGTH;
+        }
+}
+#endif
 	
 static void cursor_timer_handler(unsigned long dev_addr)
 {
@@ -447,6 +466,9 @@ static void cursor_timer_handler(unsigned long dev_addr)
 	struct fbcon_ops *ops = info->fbcon_par;
 
 	schedule_work(&info->queue);
+#ifdef CONFIG_PLAT_MILKYMIST
+	flush_bridge_cache();
+#endif
 	mod_timer(&ops->cursor_timer, jiffies + HZ/5);
 }
 
diff --git a/drivers/video/milkymistfb.c b/drivers/video/milkymistfb.c
new file mode 100644
index 0000000..0bda88f
--- /dev/null
+++ b/drivers/video/milkymistfb.c
@@ -0,0 +1,700 @@
+/*
+ *  linux/drivers/video/milkymistfb.c -- Milkymist frame buffer device
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+
+#include <asm/uaccess.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+
+    /*
+     *  RAM we reserve for the frame buffer. This defines the maximum screen
+     *  size
+     *
+     *  The default can be overridden if the driver is compiled as a module
+     */
+
+#define VIDEOMEMSIZE	(1024*800*2)	/* 1.6 MB */
+
+#define	MMPTR(x)		(*((volatile unsigned int *)(x)))
+#define	CSR_VGA_RESET		MMPTR(0x80003000)
+
+#define	VGA_RESET		(0x01)
+
+#define	CSR_VGA_HRES		MMPTR(0x80003004)
+#define	CSR_VGA_HSYNC_START	MMPTR(0x80003008)
+#define	CSR_VGA_HSYNC_END	MMPTR(0x8000300C)
+#define	CSR_VGA_HSCAN		MMPTR(0x80003010)
+
+#define	CSR_VGA_VRES		MMPTR(0x80003014)
+#define	CSR_VGA_VSYNC_START	MMPTR(0x80003018)
+#define	CSR_VGA_VSYNC_END	MMPTR(0x8000301C)
+#define	CSR_VGA_VSCAN		MMPTR(0x80003020)
+
+#define	CSR_VGA_BASEADDRESS	MMPTR(0x80003024)
+#define	CSR_VGA_BASEADDRESS_ACT	MMPTR(0x80003028)
+
+#define	CSR_VGA_BURST_COUNT	MMPTR(0x8000302C)
+
+#define	CSR_VGA_SOURCE_CLOCK	MMPTR(0x80003030)
+#define	VGA_CLOCK_VGA		(0x00)
+#define	VGA_CLOCK_SVGA		(0x01)
+#define	VGA_CLOCK_XGA		(0x02)
+
+/* TODO: move these into the driver private structure (info->par) */
+static void *videomemory;
+static u_long videomemorysize = VIDEOMEMSIZE;
+module_param(videomemorysize, ulong, 0);
+
+static int already_mmaped = 0;
+static unsigned milkymistfb_def_mode = 1;
+
+/*
+ *    Predefine Video Modes
+ */
+struct csr_vga {
+	unsigned int csr_vga_hres;
+	unsigned int csr_vga_hsync_start;
+	unsigned int csr_vga_hsync_end;
+	unsigned int csr_vga_hscan;
+	unsigned int csr_vga_vres;
+	unsigned int csr_vga_vsync_start;
+	unsigned int csr_vga_vsync_end;
+	unsigned int csr_vga_vscan;
+	unsigned int csr_vga_source_clock;
+};
+
+static const struct {
+	const char *name;
+	struct fb_var_screeninfo var;
+	struct fb_fix_screeninfo fix;
+	struct csr_vga vga;
+} milkymistfb_predefined[] = {
+	{
+		/* autodetect mode */
+		.name	= "Autodetect",
+	}, {
+		/* 640x480, 31.29, KHz 59.8 Hz, 25 MHz PixClock */
+		.name	= "640x480",
+		.var	= {
+			.xres =		640,
+			.yres =		480,
+			.xres_virtual =	640,
+			.yres_virtual =	480,
+			.bits_per_pixel = 16,
+			.red =		{11, 5, 0 },
+   		   	.green =	{ 5, 6, 0 },
+ 		     	.blue =		{ 0, 5, 0 },
+  		    	.activate =	FB_ACTIVATE_NOW,
+		      	.height =	-1,
+		      	.width =	-1,
+      			.vmode =	FB_VMODE_NONINTERLACED,
+		},
+		.fix	= {
+			.id =		"MilkymistFB",
+			.type =		FB_TYPE_PACKED_PIXELS,
+			.visual =	FB_VISUAL_TRUECOLOR,
+			.smem_len = 	(640*480*2),
+			.line_length =	640*2,
+			.accel =	FB_ACCEL_NONE,
+		},
+		.vga= {
+			.csr_vga_hres =	640,
+			.csr_vga_hsync_start = 656,
+			.csr_vga_hsync_end = 752,
+			.csr_vga_hscan = 799,
+			.csr_vga_vres = 480,
+			.csr_vga_vsync_start = 491,
+			.csr_vga_vsync_end = 493,
+			.csr_vga_vscan = 523,
+			.csr_vga_source_clock = VGA_CLOCK_VGA,
+		}
+	}, {
+		/* 800x600, 48 KHz, 72.2 Hz, 50 MHz PixClock */
+		.name	= "800x600",
+		.var	= {
+			.xres =		800,
+			.yres =		600,
+			.xres_virtual =	800,
+			.yres_virtual =	600,
+			.bits_per_pixel = 16,
+			.red =		{11, 5, 0 },
+   		   	.green =	{ 5, 6, 0 },
+ 		     	.blue =		{ 0, 5, 0 },
+  		    	.activate =	FB_ACTIVATE_NOW,
+		      	.height =	-1,
+		      	.width =	-1,
+      			.vmode =	FB_VMODE_NONINTERLACED,
+		},
+		.fix	= {
+			.id =		"MilkymistFB",
+			.type =		FB_TYPE_PACKED_PIXELS,
+			.visual =	FB_VISUAL_TRUECOLOR,
+			.smem_len = 	(800*600*2),
+			.line_length =	800*2,
+			.accel =	FB_ACCEL_NONE,
+		},
+		.vga= {
+			.csr_vga_hres =	800,
+			.csr_vga_hsync_start = 848,
+			.csr_vga_hsync_end = 976,
+			.csr_vga_hscan = 1040,
+			.csr_vga_vres = 600,
+			.csr_vga_vsync_start = 637,
+			.csr_vga_vsync_end = 643,
+			.csr_vga_vscan = 666,
+			.csr_vga_source_clock = VGA_CLOCK_SVGA,
+		}
+	}, {
+		/* 1024x768, 48.363 KHz, 60 Hz, 65 MHz PixClock */
+		.name	= "1024x768",
+		.var	= {
+			.xres =		1024,
+			.yres =		768,
+			.xres_virtual =	1024,
+			.yres_virtual =	768,
+			.bits_per_pixel = 16,
+			.red =		{11, 5, 0 },
+   		   	.green =	{ 5, 6, 0 },
+ 		     	.blue =		{ 0, 5, 0 },
+  		    	.activate =	FB_ACTIVATE_NOW,
+		      	.height =	-1,
+		      	.width =	-1,
+      			.vmode =	FB_VMODE_NONINTERLACED,
+		},
+		.fix	= {
+			.id =		"MilkymistFB",
+			.type =		FB_TYPE_PACKED_PIXELS,
+			.visual =	FB_VISUAL_TRUECOLOR,
+			.smem_len = 	(1024*768*2),
+			.line_length =	1024*2,
+			.accel =	FB_ACCEL_NONE,
+		},
+		.vga= {
+			.csr_vga_hres =	1024,
+			.csr_vga_hsync_start = 1040,
+			.csr_vga_hsync_end = 1184,
+			.csr_vga_hscan = 1344,
+			.csr_vga_vres = 768,
+			.csr_vga_vsync_start = 771,
+			.csr_vga_vsync_end = 777,
+			.csr_vga_vscan = 806,
+			.csr_vga_source_clock = VGA_CLOCK_XGA,
+		}
+	}
+};
+
+#define	NUM_TOTAL_MODES	ARRAY_SIZE(milkymistfb_predefined)
+ 
+static int milkymistfb_enable __initdata = 0;	/* disabled by default */
+module_param(milkymistfb_enable, bool, 0);
+
+static int milkymistfb_check_var(struct fb_var_screeninfo *var,
+			 struct fb_info *info);
+static int milkymistfb_set_par(struct fb_info *info);
+static int milkymistfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			 u_int transp, struct fb_info *info);
+static int milkymistfb_pan_display(struct fb_var_screeninfo *var,
+			   struct fb_info *info);
+static int milkymistfb_mmap(struct fb_info *info,
+		    struct vm_area_struct *vma);
+static int milkymistfb_release(struct fb_info *info, int user);
+
+static struct fb_ops milkymistfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_read	= fb_sys_read,
+	.fb_write	= fb_sys_write,
+	.fb_release	= milkymistfb_release,
+	.fb_check_var	= milkymistfb_check_var,
+	.fb_set_par	= milkymistfb_set_par,
+	.fb_setcolreg	= milkymistfb_setcolreg,
+	.fb_pan_display	= milkymistfb_pan_display,
+	.fb_fillrect	= sys_fillrect,
+	.fb_copyarea	= sys_copyarea,
+	.fb_imageblit	= sys_imageblit,
+	.fb_mmap	= milkymistfb_mmap,
+};
+
+    /*
+     *  Internal routines
+     */
+
+static u_long get_line_length(int xres_virtual, int bpp)
+{
+	u_long length;
+
+	length = xres_virtual * bpp;
+	length = (length + 31) & ~31;
+	length >>= 3;
+	return (length);
+}
+
+    /*
+     *  Setting the video mode has been split into two parts.
+     *  First part, xxxfb_check_var, must not write anything
+     *  to hardware, it should only verify and adjust var.
+     *  This means it doesn't alter par but it does use hardware
+     *  data from it to check this var. 
+     */
+
+static int milkymistfb_check_var(struct fb_var_screeninfo *var,
+			 struct fb_info *info)
+{
+	u_long line_length;
+
+	/*
+	 *  FB_VMODE_CONUPDATE and FB_VMODE_SMOOTH_XPAN are equal!
+	 *  as FB_VMODE_SMOOTH_XPAN is only used internally
+	 */
+
+	if (var->vmode & FB_VMODE_CONUPDATE) {
+		var->vmode |= FB_VMODE_YWRAP;
+		var->xoffset = info->var.xoffset;
+		var->yoffset = info->var.yoffset;
+	}
+
+	/*
+	 *  Some very basic checks
+	 */
+	if (!var->xres)
+		var->xres = 1;
+	if (!var->yres)
+		var->yres = 1;
+	if (var->xres > var->xres_virtual)
+		var->xres_virtual = var->xres;
+	if (var->yres > var->yres_virtual)
+		var->yres_virtual = var->yres;
+	if (var->bits_per_pixel <= 1)
+		var->bits_per_pixel = 1;
+	else if (var->bits_per_pixel <= 8)
+		var->bits_per_pixel = 8;
+	else if (var->bits_per_pixel <= 16)
+		var->bits_per_pixel = 16;
+	else if (var->bits_per_pixel <= 24)
+		var->bits_per_pixel = 24;
+	else if (var->bits_per_pixel <= 32)
+		var->bits_per_pixel = 32;
+	else
+		return -EINVAL;
+
+	if (var->xres_virtual < var->xoffset + var->xres)
+		var->xres_virtual = var->xoffset + var->xres;
+	if (var->yres_virtual < var->yoffset + var->yres)
+		var->yres_virtual = var->yoffset + var->yres;
+
+	/*
+	 *  Memory limit
+	 */
+	line_length =
+	    get_line_length(var->xres_virtual, var->bits_per_pixel);
+	if (line_length * var->yres_virtual > videomemorysize)
+		return -ENOMEM;
+
+	/*
+	 * Now that we checked it we alter var. The reason being is that the video
+	 * mode passed in might not work but slight changes to it might make it 
+	 * work. This way we let the user know what is acceptable.
+	 */
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 8:
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 0;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 16:		/* RGBA 5551 */
+		if (var->transp.length) {
+			var->red.offset = 0;
+			var->red.length = 5;
+			var->green.offset = 5;
+			var->green.length = 5;
+			var->blue.offset = 10;
+			var->blue.length = 5;
+			var->transp.offset = 15;
+			var->transp.length = 1;
+		} else {	/* RGB 565 */
+			var->red.offset = 0;
+			var->red.length = 5;
+			var->green.offset = 5;
+			var->green.length = 6;
+			var->blue.offset = 11;
+			var->blue.length = 5;
+			var->transp.offset = 0;
+			var->transp.length = 0;
+		}
+		break;
+	case 24:		/* RGB 888 */
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 16;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 32:		/* RGBA 8888 */
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 16;
+		var->blue.length = 8;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		break;
+	}
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+
+	return 0;
+}
+
+/* This routine actually sets the video mode. It's in here where we
+ * the hardware state info->par and fix which can be affected by the 
+ * change in par. For this driver it doesn't do much. 
+ */
+static int milkymistfb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = get_line_length(info->var.xres_virtual,
+						info->var.bits_per_pixel);
+	return 0;
+}
+
+    /*
+     *  Set a single color register. The values supplied are already
+     *  rounded down to the hardware's capabilities (according to the
+     *  entries in the var structure). Return != 0 for invalid regno.
+     */
+
+static int milkymistfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			 u_int transp, struct fb_info *info)
+{
+	if (regno >= 256)	/* no. of hw registers */
+		return 1;
+	/*
+	 * Program hardware... do anything you want with transp
+	 */
+
+	/* grayscale works only partially under directcolor */
+	if (info->var.grayscale) {
+		/* grayscale = 0.30*R + 0.59*G + 0.11*B */
+		red = green = blue =
+		    (red * 77 + green * 151 + blue * 28) >> 8;
+	}
+
+	/* Directcolor:
+	 *   var->{color}.offset contains start of bitfield
+	 *   var->{color}.length contains length of bitfield
+	 *   {hardwarespecific} contains width of RAMDAC
+	 *   cmap[X] is programmed to (X << red.offset) | (X << green.offset) | (X << blue.offset)
+	 *   RAMDAC[X] is programmed to (red, green, blue)
+	 * 
+	 * Pseudocolor:
+	 *    uses offset = 0 && length = RAMDAC register width.
+	 *    var->{color}.offset is 0
+	 *    var->{color}.length contains widht of DAC
+	 *    cmap is not used
+	 *    RAMDAC[X] is programmed to (red, green, blue)
+	 * Truecolor:
+	 *    does not use DAC. Usually 3 are present.
+	 *    var->{color}.offset contains start of bitfield
+	 *    var->{color}.length contains length of bitfield
+	 *    cmap is programmed to (red << red.offset) | (green << green.offset) |
+	 *                      (blue << blue.offset) | (transp << transp.offset)
+	 *    RAMDAC does not exist
+	 */
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		red = CNVT_TOHW(red, info->var.red.length);
+		green = CNVT_TOHW(green, info->var.green.length);
+		blue = CNVT_TOHW(blue, info->var.blue.length);
+		transp = CNVT_TOHW(transp, info->var.transp.length);
+		break;
+	case FB_VISUAL_DIRECTCOLOR:
+		red = CNVT_TOHW(red, 8);	/* expect 8 bit DAC */
+		green = CNVT_TOHW(green, 8);
+		blue = CNVT_TOHW(blue, 8);
+		/* hey, there is bug in transp handling... */
+		transp = CNVT_TOHW(transp, 8);
+		break;
+	}
+#undef CNVT_TOHW
+	/* Truecolor has hardware independent palette */
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
+		u32 v;
+
+		if (regno >= 16)
+			return 1;
+
+		v = (red << info->var.red.offset) |
+		    (green << info->var.green.offset) |
+		    (blue << info->var.blue.offset) |
+		    (transp << info->var.transp.offset);
+		switch (info->var.bits_per_pixel) {
+		case 8:
+			break;
+		case 16:
+			((u32 *) (info->pseudo_palette))[regno] = v;
+			break;
+		case 24:
+		case 32:
+			((u32 *) (info->pseudo_palette))[regno] = v;
+			break;
+		}
+		return 0;
+	}
+	return 0;
+}
+
+    /*
+     *  Pan or Wrap the Display
+     *
+     *  This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+     */
+
+static int milkymistfb_pan_display(struct fb_var_screeninfo *var,
+			   struct fb_info *info)
+{
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		    || var->yoffset >= info->var.yres_virtual
+		    || var->xoffset)
+			return -EINVAL;
+	} else {
+		if (var->xoffset + var->xres > info->var.xres_virtual ||
+		    var->yoffset + var->yres > info->var.yres_virtual)
+			return -EINVAL;
+	}
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	return 0;
+}
+
+/* Based on bf54x-lq043fb.c */
+static int milkymistfb_mmap(struct fb_info *info,
+		    struct vm_area_struct *vma)
+{
+	if (already_mmaped)
+		return -1;
+	already_mmaped = 1;
+
+	vma->vm_start = (unsigned long)(videomemory);
+	vma->vm_end = vma->vm_start + info->fix.smem_len;
+	vma->vm_flags |=  VM_MAYSHARE | VM_SHARED;
+	return 0;
+}
+
+static int milkymistfb_release(struct fb_info *info, int user)
+{
+	already_mmaped = 0;
+	return 0;
+}
+
+
+#ifndef MODULE
+static int __init milkymistfb_setup(char *options)
+{
+	char *this_opt, s[32];
+	int i;
+
+	milkymistfb_enable = 1;
+
+	if (!options || !*options)
+		return 1;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+		for (i=0; i<NUM_TOTAL_MODES; ++i) {
+			sprintf(s, "mode:%s", milkymistfb_predefined[i].name);
+			if (!strcmp(this_opt, s))
+				milkymistfb_def_mode = i;
+		}
+		if (!strncmp(this_opt, "disable", 7))
+			milkymistfb_enable = 0;
+	}
+	return 1;
+}
+#endif  /*  MODULE  */
+
+    /*
+     *  Initialisation
+     */
+
+static int __init milkymistfb_probe(struct platform_device *dev)
+{
+	struct fb_info *info;
+	struct csr_vga *vga;
+	int retval = -ENOMEM;
+
+	/*
+	 * For real video cards we use ioremap.
+	 */
+	if (!(videomemory = vmalloc(videomemorysize)))
+		return retval;
+
+	/*
+	 * VFB must clear memory to prevent kernel info
+	 * leakage into userspace
+	 * VGA-based drivers MUST NOT clear memory if
+	 * they want to be able to take over vgacon
+	 */
+	memset(videomemory, 0, videomemorysize);
+
+	info = framebuffer_alloc(sizeof(u32) * 256, &dev->dev);
+	if (!info)
+		goto err;
+
+	info->screen_base = (char __iomem *)videomemory;
+	info->fbops = &milkymistfb_ops;
+
+	CSR_VGA_RESET = 1;
+	vga = &milkymistfb_predefined[milkymistfb_def_mode].vga;
+	CSR_VGA_SOURCE_CLOCK = vga->csr_vga_source_clock;
+	if ( CSR_VGA_SOURCE_CLOCK != vga->csr_vga_source_clock ) {
+		milkymistfb_def_mode = 1;
+		vga = &milkymistfb_predefined[milkymistfb_def_mode].vga;
+	}
+
+	info->var = milkymistfb_predefined[milkymistfb_def_mode].var;
+	info->fix = milkymistfb_predefined[milkymistfb_def_mode].fix;
+	info->pseudo_palette = info->par;
+	info->par = NULL;
+	info->flags = FBINFO_FLAG_DEFAULT;
+	info->fix.smem_start = (char *)videomemory;
+
+	retval = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (retval < 0)
+		goto err1;
+
+	retval = register_framebuffer(info);
+	if (retval < 0)
+		goto err2;
+	platform_set_drvdata(dev, info);
+
+	printk(KERN_INFO
+	       "fb%d: Milkymist frame buffer at %p, size %ld k\n",
+	       info->node, videomemory, videomemorysize >> 10);
+	printk(KERN_INFO
+	       "fb%d: mode is %s\n",
+		info->node,
+		milkymistfb_predefined[milkymistfb_def_mode].name);
+
+	CSR_VGA_BASEADDRESS = videomemory;
+	CSR_VGA_HRES = vga->csr_vga_hres;
+	CSR_VGA_HSYNC_START = vga->csr_vga_hsync_start;
+	CSR_VGA_HSYNC_END = vga->csr_vga_hsync_end;
+	CSR_VGA_HSCAN = vga->csr_vga_hscan;
+	CSR_VGA_VRES = vga->csr_vga_vres;
+	CSR_VGA_VSYNC_START = vga->csr_vga_vsync_start;
+	CSR_VGA_VSYNC_END = vga->csr_vga_vsync_end;
+	CSR_VGA_VSCAN = vga->csr_vga_vscan;
+	CSR_VGA_BURST_COUNT = (vga->csr_vga_hres*vga->csr_vga_vres*16)/(4*64);
+	CSR_VGA_RESET = 0;
+       
+	return 0;
+err2:
+	fb_dealloc_cmap(&info->cmap);
+err1:
+	framebuffer_release(info);
+err:
+	vfree(videomemory);
+	return retval;
+}
+
+static int milkymistfb_remove(struct platform_device *dev)
+{
+	struct fb_info *info = platform_get_drvdata(dev);
+
+	CSR_VGA_RESET = VGA_RESET;
+
+	if (info) {
+		unregister_framebuffer(info);
+		vfree(videomemory);
+		framebuffer_release(info);
+	}
+	return 0;
+}
+
+static struct platform_driver milkymistfb_driver = {
+	.probe	= milkymistfb_probe,
+	.remove = milkymistfb_remove,
+	.driver = {
+		.name	= "milkymistfb",
+	},
+};
+
+static struct platform_device *milkymistfb_device;
+
+static int __init milkymistfb_init(void)
+{
+	int ret = 0;
+
+#ifndef MODULE
+	char *option = NULL;
+
+	if (fb_get_options("milkymistfb", &option))
+		return -ENODEV;
+	milkymistfb_setup(option);
+#endif
+
+	if (!milkymistfb_enable)
+		return -ENXIO;
+
+	ret = platform_driver_register(&milkymistfb_driver);
+
+	if (!ret) {
+		milkymistfb_device = platform_device_alloc("milkymistfb", 0);
+
+		if (milkymistfb_device)
+			ret = platform_device_add(milkymistfb_device);
+		else
+			ret = -ENOMEM;
+
+		if (ret) {
+			platform_device_put(milkymistfb_device);
+			platform_driver_unregister(&milkymistfb_driver);
+		}
+	}
+
+	return ret;
+}
+
+module_init(milkymistfb_init);
+
+#ifdef MODULE
+static void __exit milkymistfb_exit(void)
+{
+	platform_device_unregister(milkymistfb_device);
+	platform_driver_unregister(&milkymistfb_driver);
+}
+
+module_exit(milkymistfb_exit);
+
+MODULE_LICENSE("GPL");
+#endif				/* MODULE */
diff --git a/fs/Kconfig.binfmt b/fs/Kconfig.binfmt
index d4fc609..69739a2 100644
--- a/fs/Kconfig.binfmt
+++ b/fs/Kconfig.binfmt
@@ -26,7 +26,7 @@ config BINFMT_ELF
 config BINFMT_ELF_FDPIC
 	bool "Kernel support for FDPIC ELF binaries"
 	default y
-	depends on (FRV || BLACKFIN)
+	depends on (FRV || BLACKFIN || LM32)
 	help
 	  ELF FDPIC binaries are based on ELF, but allow the individual load
 	  segments of a binary to be located in memory independently of each
diff --git a/fs/binfmt_elf_fdpic.c b/fs/binfmt_elf_fdpic.c
index 2f5d8db..7f174f7 100644
--- a/fs/binfmt_elf_fdpic.c
+++ b/fs/binfmt_elf_fdpic.c
@@ -1443,6 +1443,7 @@ static int elf_dump_thread_status(long signr, struct elf_thread_status *t)
 	t->num_notes++;
 	sz += notesize(&t->notes[0]);
 
+#ifdef ELF_CORE_COPY_FPREGS
 	t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL, &t->fpu);
 	if (t->prstatus.pr_fpvalid) {
 		fill_note(&t->notes[1], "CORE", NT_PRFPREG, sizeof(t->fpu),
@@ -1450,6 +1451,7 @@ static int elf_dump_thread_status(long signr, struct elf_thread_status *t)
 		t->num_notes++;
 		sz += notesize(&t->notes[1]);
 	}
+#endif
 
 #ifdef ELF_CORE_COPY_XFPREGS
 	if (elf_core_copy_task_xfpregs(p, &t->xfpu)) {
@@ -1571,7 +1573,9 @@ static int elf_fdpic_core_dump(long signr, struct pt_regs *regs,
  	struct task_struct *g, *p;
  	LIST_HEAD(thread_list);
  	struct list_head *t;
+#ifdef ELF_CORE_COPY_FPREGS
 	elf_fpregset_t *fpu = NULL;
+#endif
 #ifdef ELF_CORE_COPY_XFPREGS
 	elf_fpxregset_t *xfpu = NULL;
 #endif
@@ -1607,9 +1611,11 @@ static int elf_fdpic_core_dump(long signr, struct pt_regs *regs,
 	notes = kmalloc(NUM_NOTES * sizeof(struct memelfnote), GFP_KERNEL);
 	if (!notes)
 		goto cleanup;
+#ifdef ELF_CORE_COPY_FPREGS
 	fpu = kmalloc(sizeof(*fpu), GFP_KERNEL);
 	if (!fpu)
 		goto cleanup;
+#endif
 #ifdef ELF_CORE_COPY_XFPREGS
 	xfpu = kmalloc(sizeof(*xfpu), GFP_KERNEL);
 	if (!xfpu)
@@ -1682,11 +1688,13 @@ static int elf_fdpic_core_dump(long signr, struct pt_regs *regs,
 	fill_note(&notes[numnote++], "CORE", NT_AUXV,
 		  i * sizeof(elf_addr_t), auxv);
 
-  	/* Try to dump the FPU. */
+#ifdef ELF_CORE_COPY_FPREGS
+	/* Try to dump the FPU. */
 	if ((prstatus->pr_fpvalid =
 	     elf_core_copy_task_fpregs(current, regs, fpu)))
 		fill_note(notes + numnote++,
 			  "CORE", NT_PRFPREG, sizeof(*fpu), fpu);
+#endif
 #ifdef ELF_CORE_COPY_XFPREGS
 	if (elf_core_copy_task_xfpregs(current, xfpu))
 		fill_note(notes + numnote++,
@@ -1808,7 +1816,9 @@ cleanup:
 	kfree(prstatus);
 	kfree(psinfo);
 	kfree(notes);
+#ifdef ELF_CORE_COPY_FPREGS
 	kfree(fpu);
+#endif
 #ifdef ELF_CORE_COPY_XFPREGS
 	kfree(xfpu);
 #endif
diff --git a/include/asm-lm32/Kbuild b/include/asm-lm32/Kbuild
new file mode 100644
index 0000000..da18df3
--- /dev/null
+++ b/include/asm-lm32/Kbuild
@@ -0,0 +1,5 @@
+include include/asm-generic/Kbuild.asm
+
+header-y += io.h
+header-y += registers.h
+header-y += traps.h
diff --git a/include/asm-lm32/a.out.h b/include/asm-lm32/a.out.h
new file mode 100644
index 0000000..4f71414
--- /dev/null
+++ b/include/asm-lm32/a.out.h
@@ -0,0 +1,31 @@
+/*
+ * Based on:
+ * include/asm-m68k/a.out.h
+ */
+
+#ifndef _LM32_ASM_A_OUT_H
+#define _LM32_ASM_A_OUT_H
+
+struct exec
+{
+  unsigned long a_info;		/* Use macros N_MAGIC, etc for access */
+  unsigned a_text;		/* length of text, in bytes */
+  unsigned a_data;		/* length of data, in bytes */
+  unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
+  unsigned a_syms;		/* length of symbol table data in file, in bytes */
+  unsigned a_entry;		/* start address */
+  unsigned a_trsize;		/* length of relocation info for text, in bytes */
+  unsigned a_drsize;		/* length of relocation info for data, in bytes */
+};
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#ifdef __KERNEL__
+
+#define STACK_TOP	TASK_SIZE
+
+#endif
+
+#endif /* _LM32_ASM_A_OUT_H */
diff --git a/include/asm-lm32/atomic.h b/include/asm-lm32/atomic.h
new file mode 100644
index 0000000..72e8a6b
--- /dev/null
+++ b/include/asm-lm32/atomic.h
@@ -0,0 +1,193 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_ATOMIC_H
+#define _LM32_ASM_ATOMIC_H
+
+#include <linux/compiler.h> /* likely / unlikely */
+#include <asm/system.h>
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ */
+
+/*
+ * We do not have SMP lm32 systems.
+ */
+
+typedef struct { int counter; } atomic_t;
+#define ATOMIC_INIT(i)	{ (i) }
+
+#define atomic_read(v)		((v)->counter)
+#define atomic_set(v, i)	(((v)->counter) = i)
+
+static __inline__ void atomic_add(int i, atomic_t *v)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	v->counter += i;
+	local_irq_restore(flags);
+}
+
+static __inline__ void atomic_sub(int i, atomic_t *v)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	v->counter -= i;
+	local_irq_restore(flags);
+}
+
+static __inline__ int atomic_sub_and_test(int i, atomic_t * v)
+{
+	int ret;
+	unsigned long flags;
+	local_irq_save(flags);
+	v->counter -= i;
+	ret = v->counter != 0;
+	local_irq_restore(flags);
+	return ret;
+}
+
+static __inline__ void atomic_inc(volatile atomic_t *v)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	v->counter++;
+	local_irq_restore(flags);
+}
+
+/*
+ * atomic_inc_and_test - increment and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+
+static __inline__ int atomic_inc_and_test(volatile atomic_t *v)
+{
+	int ret;
+	unsigned long flags;
+	local_irq_save(flags);
+	v->counter++;
+	ret = v->counter == 0;
+	local_irq_restore(flags);
+	return ret;
+}
+
+static __inline__ void atomic_dec(volatile atomic_t *v)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	v->counter--;
+	local_irq_restore(flags);
+}
+
+static __inline__ int atomic_dec_and_test(volatile atomic_t *v)
+{
+	int ret;
+	unsigned long flags;
+	local_irq_save(flags);
+	v->counter--;
+	ret = v->counter == 0;
+	local_irq_restore(flags);
+	return ret;
+}
+
+static __inline__ void atomic_clear_mask(unsigned long mask, unsigned long *v)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	*v &= mask;
+	local_irq_restore(flags);
+}
+
+static __inline__ void atomic_set_mask(unsigned long mask, unsigned long *v)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	*v |= mask;
+	local_irq_restore(flags);
+}
+
+/* Atomic operations are already serializing */
+#define smp_mb__before_atomic_dec()    barrier()
+#define smp_mb__after_atomic_dec() barrier()
+#define smp_mb__before_atomic_inc()    barrier()
+#define smp_mb__after_atomic_inc() barrier()
+
+static inline int atomic_add_return(int i, atomic_t * v)
+{
+	unsigned long temp, flags;
+
+	local_irq_save(flags);
+	temp = *(long *)v;
+	temp += i;
+	*(long *)v = temp;
+	local_irq_restore(flags);
+
+	return temp;
+}
+
+#define atomic_add_negative(a, v)	(atomic_add_return((a), (v)) < 0)
+
+static inline int atomic_sub_return(int i, atomic_t * v)
+{
+	unsigned long temp, flags;
+
+	local_irq_save(flags);
+	temp = *(long *)v;
+	temp -= i;
+	*(long *)v = temp;
+	local_irq_restore(flags);
+
+	return temp;
+}
+
+#define atomic_cmpxchg(v, o, n) ((int)cmpxchg(&((v)->counter), (o), (n)))
+#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
+
+static __inline__ int atomic_add_unless(atomic_t *v, int a, int u)
+{
+	int c, old;
+	c = atomic_read(v);
+	for (;;) {
+		if( unlikely(c == (u)) )
+			break;
+		old = atomic_cmpxchg((v), c, c + (a));
+		if( likely(old == c) )
+			break;
+		c = old;
+	}
+	return c != (u);
+}
+
+#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+
+#define atomic_dec_return(v) atomic_sub_return(1,(v))
+#define atomic_inc_return(v) atomic_add_return(1,(v))
+
+#include <asm-generic/atomic.h>
+#endif /* _LM32_ATOMIC_H */
diff --git a/include/asm-lm32/auxvec.h b/include/asm-lm32/auxvec.h
new file mode 100644
index 0000000..35c9c30
--- /dev/null
+++ b/include/asm-lm32/auxvec.h
@@ -0,0 +1,2 @@
+/* keep me */
+
diff --git a/include/asm-lm32/bitops.h b/include/asm-lm32/bitops.h
new file mode 100644
index 0000000..1b64792
--- /dev/null
+++ b/include/asm-lm32/bitops.h
@@ -0,0 +1,11 @@
+#ifndef _LM32_ASM_BITOPS_H
+#define _LM32_ASM_BITOPS_H
+
+#include <asm/system.h>
+
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+#include <asm-generic/bitops.h>
+
+#endif /* _LM32_BITOPS_H */
diff --git a/include/asm-lm32/bootinfo.h b/include/asm-lm32/bootinfo.h
new file mode 100644
index 0000000..35c9c30
--- /dev/null
+++ b/include/asm-lm32/bootinfo.h
@@ -0,0 +1,2 @@
+/* keep me */
+
diff --git a/include/asm-lm32/bug.h b/include/asm-lm32/bug.h
new file mode 100644
index 0000000..b12fd89
--- /dev/null
+++ b/include/asm-lm32/bug.h
@@ -0,0 +1 @@
+#include <asm-generic/bug.h>
diff --git a/include/asm-lm32/bugs.h b/include/asm-lm32/bugs.h
new file mode 100644
index 0000000..142ebf4
--- /dev/null
+++ b/include/asm-lm32/bugs.h
@@ -0,0 +1,11 @@
+#ifndef _LM32_ASM_BUGS_H
+#define _LM32_ASM_BUGS_H
+
+/*
+ * This is included by init/main.c to check for architecture-dependent bugs.
+ */
+static void check_bugs(void)
+{
+}
+
+#endif
diff --git a/include/asm-lm32/byteorder.h b/include/asm-lm32/byteorder.h
new file mode 100644
index 0000000..5189dc4
--- /dev/null
+++ b/include/asm-lm32/byteorder.h
@@ -0,0 +1,16 @@
+#ifndef _LM32_ASM_BYTEORDER_H
+#define _LM32_ASM_BYTEORDER_H
+
+#include <asm/types.h>
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+// there is a 64bit data type supported by the processor
+#  define __BYTEORDER_HAS_U64__
+
+// so we don't have to implement swab64 in assembler ;) 
+#  define __SWAB_64_THRU_32__
+#endif
+
+#include <linux/byteorder/big_endian.h>
+
+#endif /* _LM32_BYTEORDER_H */
diff --git a/include/asm-lm32/cache.h b/include/asm-lm32/cache.h
new file mode 100644
index 0000000..3862855
--- /dev/null
+++ b/include/asm-lm32/cache.h
@@ -0,0 +1,32 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_LM32_CACHE_H
+#define __ASM_LM32_CACHE_H
+
+/* 32 byte cache lines */
+#define L1_CACHE_BYTES 32
+#define L1_CACHE_SHIFT 5
+
+#endif
+
diff --git a/include/asm-lm32/cacheflush.h b/include/asm-lm32/cacheflush.h
new file mode 100644
index 0000000..120afa6
--- /dev/null
+++ b/include/asm-lm32/cacheflush.h
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_CACHEFLUSH_H
+#define _LM32_ASM_CACHEFLUSH_H
+
+#include <linux/mm.h>
+
+#define flush_cache_all()			__flush_cache_all()
+#define flush_cache_mm(mm)			__flush_cache_all()
+#define flush_cache_dup_mm(mm)			__flush_cache_all()
+#define flush_cache_range(vma, start, end)	__flush_cache_all()
+#define flush_cache_page(vma, vmaddr)		__flush_cache_all()
+#define flush_dcache_range(start,len)		__flush_cache_all()
+#define flush_dcache_page(page)			__flush_cache_all()
+#define flush_dcache_mmap_lock(mapping)		__flush_cache_all()
+#define flush_dcache_mmap_unlock(mapping)	__flush_cache_all()
+#define flush_icache_range(start,len)		__flush_cache_all()
+#define flush_icache_page(vma,pg)		__flush_cache_all()
+#define flush_icache_user_range(vma,pg,adr,len)	__flush_cache_all()
+#define flush_cache_vmap(start, end)		__flush_cache_all()
+#define flush_cache_vunmap(start, end)		__flush_cache_all()
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+
+static inline void __flush_cache_all(void)
+{
+	asm volatile (
+			"nop\n"
+			"wcsr DCC, r0\n"
+			"nop\n"
+	);
+}
+
+#endif /* _LM32_ASM_CACHEFLUSH_H */
diff --git a/include/asm-lm32/checksum.h b/include/asm-lm32/checksum.h
new file mode 100644
index 0000000..8781efe
--- /dev/null
+++ b/include/asm-lm32/checksum.h
@@ -0,0 +1,157 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on:
+ * include/asm-m68k/checksum.h
+ */
+
+#ifndef _LM32_ASM_CHECKSUM_H
+#define _LM32_ASM_CHECKSUM_H
+
+#include <linux/in6.h>
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+__wsum csum_partial(const void *buff, int len, __wsum sum);
+
+/*
+ * the same as csum_partial, but copies from src while it
+ * checksums
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+__wsum csum_partial_copy_nocheck(const void *src, void *dst,
+	int len, __wsum sum);
+
+
+/*
+ * the same as csum_partial_copy, but copies from user space.
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+extern __wsum csum_partial_copy_from_user(const void __user *src,
+	void *dst, int len, __wsum sum, int *csum_err);
+
+__sum16 ip_fast_csum(const void *iph, unsigned int ihl);
+
+/*
+ *	Fold a partial checksum
+ */
+
+static inline __sum16 csum_fold(__wsum sum)
+{
+#if 0
+        while (sum >> 16)
+                sum = (sum & 0xffff) + (sum >> 16);
+        return ((~(sum << 16)) >> 16);
+#endif
+
+	/* This C function will generate is equivalent to the following
+	   assembly output:
+
+	   srui     r2, r1, 16
+	   andi     r1, r1, 65535
+	   add      r2, r1, r2
+	   cmpgui   r1, r2, 0xffff
+	   add      r2, r2, r1
+	   xori     r2, r2, 0xffff
+	*/
+	   
+        u32   lo = sum & 0xffff ;
+        u32   hi = sum >> 16 ;
+        u32   tmp;
+        u32   carry;
+
+        tmp = lo + hi;
+     /* carry = tmp & 0x10000;    if bit 17 is set there was a
+																	carry from adding 16 bit to 16 bit */
+				carry = (tmp > 0xffff);
+				asm volatile( "cmpgui %0, %1, 0xffff": "=r"(carry) : "r"(tmp) );
+        tmp = tmp + carry;
+        asm volatile ( "xori %0, %1, 0xffff" : "=r"(tmp) : "0"(tmp) );
+        return tmp;
+}
+
+
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+
+static inline __wsum
+csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len,
+		  unsigned short proto, __wsum sum)
+{
+  u32  s = sum;
+  u32  tmp;
+  u32  carry;
+
+  /* add saddr */
+  tmp   = s + saddr;
+  carry = (s > tmp);
+  s     = tmp + carry;
+  /* add daddr */
+  tmp   = s + daddr;
+  carry = (s > tmp);
+  s     = tmp + carry;
+  /* addr len and proto */
+  tmp   = s + (proto + len);  /* this is correct for big-endian only! */
+  carry = (s > tmp);  /* this will generate a single cmpgu insn */
+  s     = tmp + carry;
+
+  return (__force __wsum) s;
+}
+
+static inline __sum16
+csum_tcpudp_magic(__be32 saddr, __be32 daddr, unsigned short len,
+		  unsigned short proto, __wsum sum)
+{
+	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+
+extern __sum16 ip_compute_csum(const void *buff, int len);
+
+//#define _HAVE_ARCH_IPV6_CSUM
+//TODO activate _HAVE_ARCH_IPV6_CSUM
+
+#endif
diff --git a/include/asm-lm32/cputime.h b/include/asm-lm32/cputime.h
new file mode 100644
index 0000000..6d68ad7
--- /dev/null
+++ b/include/asm-lm32/cputime.h
@@ -0,0 +1 @@
+#include <asm-generic/cputime.h>
diff --git a/include/asm-lm32/current.h b/include/asm-lm32/current.h
new file mode 100644
index 0000000..7d262e8
--- /dev/null
+++ b/include/asm-lm32/current.h
@@ -0,0 +1,25 @@
+/*
+ * Based on:
+ * include/asm-blackfin/current.h
+ *	(C) Copyright 2000, Lineo, David McCullough <davidm@uclinux.org>
+ *
+ *	rather than dedicate a register (as the m68k source does), we
+ *	just keep a global,  we should probably just change it all to be
+ *	current and lose _current_task.
+ */
+
+#ifndef _LM32_ASM_CURRENT_H
+#define _LM32_ASM_CURRENT_H
+
+#include <linux/thread_info.h>
+
+struct task_struct;
+
+static inline struct task_struct *get_current(void)
+{
+	return(current_thread_info()->task);
+}
+
+#define	current	(get_current())
+
+#endif /* _LM32_ASM_CURRENT_H */
diff --git a/include/asm-lm32/delay.h b/include/asm-lm32/delay.h
new file mode 100644
index 0000000..d146365
--- /dev/null
+++ b/include/asm-lm32/delay.h
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on:
+ * include/asm-mips/delay.h
+ */
+
+#ifndef _LM32_DELAY_H
+#define _LM32_DELAY_H
+
+static inline void __delay(unsigned long loops)
+{
+	/* get a realistic delay by using add more often than branch 
+	 * (branch needs 4 cycles if taken, add only one) */
+	asm volatile(
+		"andi r2, %0, 1\n"
+		"be r2, r0, 8\n" /* jump over next instruction */
+		"addi %0, %0, -1\n"
+		"andi r2, %0, 2\n"
+		"be r2, r0, 8\n" /* jump over next instruction */
+		"addi %0, %0, -2\n"
+		"andi r2, %0, 4\n"
+		"be r2, r0, 8\n" /* jump over next instruction */
+		"addi %0, %0, -4\n"
+		"addi %0, %0, -1\n" /* loop */ 
+		"addi %0, %0, -1\n"
+		"addi %0, %0, -1\n"
+		"addi %0, %0, -1\n"
+		"addi %0, %0, -1\n"
+		"addi %0, %0, -1\n"
+		"addi %0, %0, -1\n"
+		"addi %0, %0, -1\n"
+		"bne %0, r0, -32\n"
+		: "=r"(loops)
+		: "0"(loops)
+		: "r2"
+	);
+}
+
+#include <linux/param.h>	/* needed for HZ */
+
+/*
+ * Use only for very small delays ( < 1 msec).  Should probably use a
+ * lookup table, really, as the multiplications take much too long with
+ * short delays.  This is a "reasonable" implementation, though (and the
+ * first constant multiplications gets optimized away if the delay is
+ * a constant)
+ */
+static inline void udelay(unsigned long usecs)
+{
+	extern unsigned long loops_per_jiffy;
+	__delay(usecs * loops_per_jiffy / (1000000 / HZ));
+}
+
+#endif
diff --git a/include/asm-lm32/device.h b/include/asm-lm32/device.h
new file mode 100644
index 0000000..f0a4c25
--- /dev/null
+++ b/include/asm-lm32/device.h
@@ -0,0 +1 @@
+#include <asm-generic/device.h>
diff --git a/include/asm-lm32/div64.h b/include/asm-lm32/div64.h
new file mode 100644
index 0000000..6cd978c
--- /dev/null
+++ b/include/asm-lm32/div64.h
@@ -0,0 +1 @@
+#include <asm-generic/div64.h>
diff --git a/include/asm-lm32/dma-mapping.h b/include/asm-lm32/dma-mapping.h
new file mode 100644
index 0000000..396656e
--- /dev/null
+++ b/include/asm-lm32/dma-mapping.h
@@ -0,0 +1,8 @@
+#ifndef _LM32_ASM_DMA_MAPPING_H
+#define _LM32_ASM_DMA_MAPPING_H
+
+/* no DMA at the moment */
+#include <asm/scatterlist.h>
+#include <asm-generic/dma-mapping.h>
+
+#endif  /* _LM32_ASM_DMA_MAPPING_H */
diff --git a/include/asm-lm32/dma.h b/include/asm-lm32/dma.h
new file mode 100644
index 0000000..1a9818c
--- /dev/null
+++ b/include/asm-lm32/dma.h
@@ -0,0 +1,19 @@
+/*
+ * Based on:
+ * include/asm-m68k/dma.h
+ */
+
+#ifndef _LM32_ASM_DMA_H
+#define _LM32_ASM_DMA_H
+ 
+#define MAX_DMA_CHANNELS 8
+
+/* Don't define MAX_DMA_ADDRESS; it's useless on the m68k/coldfire and any
+   occurrence should be flagged as an error.  */
+#define MAX_DMA_ADDRESS PAGE_OFFSET
+
+/* These are in kernel/dma.c: */
+//extern int request_dma(unsigned int dmanr, const char *device_id);	/* reserve a DMA channel */
+//extern void free_dma(unsigned int dmanr);	/* release it again */
+ 
+#endif /* _LM32_ASM_DMA_H */
diff --git a/include/asm-lm32/elf.h b/include/asm-lm32/elf.h
new file mode 100644
index 0000000..a2b40b6
--- /dev/null
+++ b/include/asm-lm32/elf.h
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_ELF_H
+#define _LM32_ASM_ELF_H
+
+#include <asm/registers.h>
+#include <asm/user.h>
+
+/*
+ * ELF register definitions..
+ */
+
+
+/* Processor specific flags for the ELF header e_flags field.  */
+#define EF_LM32_PIC		0x00000001	/* TODO -fpic */
+#define EF_LM32_FDPIC		0x00000002	/* TODO -mfdpic or -G */
+
+#define ELF_FDPIC_CORE_EFLAGS EF_LM32_FDPIC
+
+/*
+ * ELF relocation types
+ */
+#define R_LM32_NONE                      0
+#define R_LM32_8                         1
+#define R_LM32_16                        2
+#define R_LM32_32                        3
+#define R_LM32_HI16                      4
+#define R_LM32_LO16                      5
+#define R_LM32_GPREL16                   6
+#define R_LM32_CALL                      7
+#define R_LM32_BRANCH                    8
+#define R_LM32_GNU_VTINHERIT             9
+#define R_LM32_GNU_VTENTRY               10
+#define R_LM32_16_GOT                    11
+#define R_LM32_GOTOFF_HI16               12
+#define R_LM32_GOTOFF_LO16               13
+#define R_LM32_COPY                      14
+#define R_LM32_GLOB_DAT                  15
+#define R_LM32_JMP_SLOT                  16
+#define R_LM32_RELATIVE                  17
+
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG (sizeof(struct pt_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct fp_regs elf_fpregset_t;
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) ((x)->e_machine == EM_LM32)
+#define elf_check_fdpic(x) (1)
+#define elf_check_const_displacement(x) (1)
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#define ELF_DATA	ELFDATA2MSB
+#define ELF_ARCH	EM_LM32
+
+#define ELF_PLAT_INIT(_r, load_addr)	do { } while(0)
+
+#define ELF_FDPIC_PLAT_INIT(_regs, _exec_map_addr, _interp_map_addr, _dynamic_addr)	\
+do { \
+	_regs->r11	= _exec_map_addr;				\
+	_regs->r12	= _interp_map_addr;				\
+	_regs->r13	= _dynamic_addr;				\
+	_regs->r14	= 0; /* 6th argument to uclibc start: rtld_fini = NULL */ \
+} while(0)
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	4096
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+// TODO: change this value as soon as we use ET_DYN
+#define ELF_ET_DYN_BASE         0xD0000000UL
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this cpu supports.  */
+
+#define ELF_HWCAP	(0)
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.  */
+
+#define ELF_PLATFORM  (NULL)
+
+// TODO SET_PERSONALITY
+//#ifdef __KERNEL__
+//#define SET_PERSONALITY(ex, ibcs2) set_personality((ibcs2)?PER_SVR4:PER_LINUX)
+//#endif
+
+#endif
diff --git a/include/asm-lm32/emergency-restart.h b/include/asm-lm32/emergency-restart.h
new file mode 100644
index 0000000..3711bd9
--- /dev/null
+++ b/include/asm-lm32/emergency-restart.h
@@ -0,0 +1 @@
+#include <asm-generic/emergency-restart.h>
diff --git a/include/asm-lm32/errno.h b/include/asm-lm32/errno.h
new file mode 100644
index 0000000..4c82b50
--- /dev/null
+++ b/include/asm-lm32/errno.h
@@ -0,0 +1 @@
+#include <asm-generic/errno.h>
diff --git a/include/asm-lm32/fb.h b/include/asm-lm32/fb.h
new file mode 100644
index 0000000..fa9bbb9
--- /dev/null
+++ b/include/asm-lm32/fb.h
@@ -0,0 +1,13 @@
+#ifndef _ASM_FB_H_
+#define _ASM_FB_H_
+#include <linux/device.h>
+
+/* Caching is off in the I/O space quadrant by design.  */
+#define fb_pgprotect(...) do {} while (0)
+
+static inline int fb_is_primary_device(struct fb_info *info)
+{
+	return 0;
+}
+
+#endif /* _ASM_FB_H_ */
diff --git a/include/asm-lm32/fcntl.h b/include/asm-lm32/fcntl.h
new file mode 100644
index 0000000..46ab12d
--- /dev/null
+++ b/include/asm-lm32/fcntl.h
@@ -0,0 +1 @@
+#include <asm-generic/fcntl.h>
diff --git a/include/asm-lm32/flat.h b/include/asm-lm32/flat.h
new file mode 100644
index 0000000..ca08c80
--- /dev/null
+++ b/include/asm-lm32/flat.h
@@ -0,0 +1,17 @@
+/*
+ * Based on:
+ * include/asm-m68knommu/flat.h
+ */
+
+#ifndef _ASM_LM32_FLAT_H__
+#define _ASM_LM32_FLAT_H__
+
+#define	flat_stack_align(sp)			/* nothing needed */
+#define	flat_argvp_envp_on_stack()		1
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
+#define	flat_get_addr_from_rp(rp, relval, flags)	get_unaligned(rp)
+#define	flat_put_addr_at_rp(rp, val, relval)	put_unaligned(val,rp)
+#define	flat_get_relocate_addr(rel)		(rel)
+
+#endif /* _ASM_LM32_FLAT_H__ */
diff --git a/include/asm-lm32/futex.h b/include/asm-lm32/futex.h
new file mode 100644
index 0000000..0b74582
--- /dev/null
+++ b/include/asm-lm32/futex.h
@@ -0,0 +1 @@
+#include <asm-generic/futex.h>
diff --git a/include/asm-lm32/hardirq.h b/include/asm-lm32/hardirq.h
new file mode 100644
index 0000000..fb3b938
--- /dev/null
+++ b/include/asm-lm32/hardirq.h
@@ -0,0 +1,30 @@
+/*
+ * Based on:
+ * include/asm-m68knommu/hardirq.h
+ */
+
+#ifndef _LM32_ASM_HARDIRQ_H
+#define _LM32_ASM_HARDIRQ_H
+
+#include <linux/cache.h>
+#include <linux/threads.h>
+#include <asm/irq.h>
+
+typedef struct {
+	unsigned int __softirq_pending;
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+#define HARDIRQ_BITS	8
+
+/*
+ * The hardirq mask has to be large enough to have
+ * space for potentially all IRQ sources in the system
+ * nesting on a single CPU:
+ */
+#if (1 << HARDIRQ_BITS) < NR_IRQS
+# error HARDIRQ_BITS is too low!
+#endif
+
+#endif /* _LM32_ASM_HARDIRQ_H */
diff --git a/include/asm-lm32/hw_irq.h b/include/asm-lm32/hw_irq.h
new file mode 100644
index 0000000..cdf44be
--- /dev/null
+++ b/include/asm-lm32/hw_irq.h
@@ -0,0 +1,23 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
diff --git a/include/asm-lm32/io.h b/include/asm-lm32/io.h
new file mode 100644
index 0000000..b7eed7b
--- /dev/null
+++ b/include/asm-lm32/io.h
@@ -0,0 +1,237 @@
+/*
+ * Based on:
+ * include/asm-m68knommu/io.h
+ *
+ * lm32 does not currently support ISA/PCI
+ */
+
+#ifndef _LM32_ASM_IO_H
+#define _LM32_ASM_IO_H
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+/*
+ * These are for ISA/PCI shared memory _only_ and should never be used
+ * on any other type of memory, including Zorro memory. They are meant to
+ * access the bus in the bus byte order which is little-endian!.
+ *
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the m68k architecture, we just read/write the
+ * memory location directly.
+ */
+/* ++roman: The assignments to temp. vars avoid that gcc sometimes generates
+ * two accesses to memory, which may be undesireable for some devices.
+ */
+
+/*
+ * swap functions are sometimes needed to interface little-endian hardware
+ */
+static inline unsigned short _swapw(volatile unsigned short v)
+{
+    return ((v << 8) | (v >> 8));
+}
+
+static inline unsigned int _swapl(volatile unsigned long v)
+{
+    return ((v << 24) | ((v & 0xff00) << 8) | ((v & 0xff0000) >> 8) | (v >> 24));
+}
+
+#define readb(addr) \
+    ({ unsigned char __v = (*(volatile unsigned char *) (addr)); __v; })
+#define readw(addr) \
+    ({ unsigned short __v = (*(volatile unsigned short *) (addr)); __v; })
+#define readl(addr) \
+    ({ unsigned int __v = (*(volatile unsigned int *) (addr)); __v; })
+
+#define readb_relaxed(addr) readb(addr)
+#define readw_relaxed(addr) readw(addr)
+#define readl_relaxed(addr) readl(addr)
+
+#define writeb(b,addr) (void)((*(volatile unsigned char *) (addr)) = (b))
+#define writew(b,addr) (void)((*(volatile unsigned short *) (addr)) = (b))
+#define writel(b,addr) (void)((*(volatile unsigned int *) (addr)) = (b))
+
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+
+static inline void outsb(unsigned int addr, const void *buf, int len)
+{
+	volatile unsigned char *ap = (volatile unsigned char *) addr;
+	const unsigned char *bp = (const unsigned char *) buf;
+	while (len--)
+		*ap = *bp++;
+}
+
+static inline void outsw(unsigned int addr, const void *buf, int len)
+{
+	volatile unsigned short *ap = (volatile unsigned short *) addr;
+	const unsigned short *bp = (const unsigned short *) buf;
+	while (len--)
+		*ap = _swapw(*bp++);
+}
+
+static inline void outsl(unsigned int addr, const void *buf, int len)
+{
+	volatile unsigned int *ap = (volatile unsigned int *) addr;
+	const unsigned int *bp = (const unsigned int *) buf;
+	while (len--)
+		*ap = _swapl(*bp++);
+}
+
+static inline void insb(unsigned int addr, void *buf, int len)
+{
+	volatile unsigned char *ap = (volatile unsigned char *) addr;
+	unsigned char *bp = (unsigned char *) buf;
+	while (len--)
+		*bp++ = *ap;
+}
+
+static inline void insw(unsigned int addr, void *buf, int len)
+{
+	volatile unsigned short *ap = (volatile unsigned short *) addr;
+	unsigned short *bp = (unsigned short *) buf;
+	while (len--)
+		*bp++ = _swapw(*ap);
+}
+
+static inline void insl(unsigned int addr, void *buf, int len)
+{
+	volatile unsigned int *ap = (volatile unsigned int *) addr;
+	unsigned int *bp = (unsigned int *) buf;
+	while (len--)
+		*bp++ = _swapl(*ap);
+}
+
+#define mmiowb()
+
+/*
+ *	make the short names macros so specific devices
+ *	can override them as required
+ */
+
+#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
+#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+
+#define inb(addr)    readb(addr)
+#define inw(addr)    readw(addr)
+#define inl(addr)    readl(addr)
+#define outb(x,addr) ((void) writeb(x,addr))
+#define outw(x,addr) ((void) writew(x,addr))
+#define outl(x,addr) ((void) writel(x,addr))
+
+#define inb_p(addr)    inb(addr)
+#define inw_p(addr)    inw(addr)
+#define inl_p(addr)    inl(addr)
+#define outb_p(x,addr) outb(x,addr)
+#define outw_p(x,addr) outw(x,addr)
+#define outl_p(x,addr) outl(x,addr)
+
+#define DEF_MMIO_IN_BE(name, size, insn)                                \
+static inline u##size name(const volatile u##size __iomem *addr)        \
+{                                                                       \
+        u##size ret;                                                    \
+        __asm__ __volatile__(#insn " %0,%1"\
+                : "=r" (ret) : "m" (*addr) : "memory");                 \
+        return ret;                                                     \
+}
+
+#define DEF_MMIO_OUT_BE(name, size, insn)                               \
+static inline void name(volatile u##size __iomem *addr, u##size val)    \
+{                                                                       \
+        __asm__ __volatile__(#insn " %0,%1"                 \
+                : "=m" (*addr) : "r" (val) : "memory");                 \
+}
+
+#if 0
+//#define in_8(addr)     readb(addr)
+//#define in_be16(addr)  readw(addr)
+//#define out_8(b, addr) ((void) writeb(b,addr))
+//#define out_be16(b, addr) ((void)writew(b,addr))
+#else
+DEF_MMIO_IN_BE(in_8,     8, lb);
+DEF_MMIO_IN_BE(in_be16, 16, lh);
+DEF_MMIO_OUT_BE(out_8,     8, sb);
+DEF_MMIO_OUT_BE(out_be16, 16, sh);
+#endif
+
+#define in_le16(addr)  __le16_to_cpu(readw(addr))
+#define out_le16(b, addr) ((void)writew(__cpu_to_le16(b),addr))
+
+
+
+#define IO_SPACE_LIMIT 0xffff
+
+
+/* Values for nocacheflag and cmode */
+#define IOMAP_FULL_CACHING		0
+#define IOMAP_NOCACHE_SER		1
+#define IOMAP_NOCACHE_NONSER		2
+#define IOMAP_WRITETHROUGH		3
+
+extern void *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag);
+extern void __iounmap(void *addr, unsigned long size);
+
+static inline void *ioremap(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+static inline void *ioremap_nocache(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+static inline void *ioremap_writethrough(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
+}
+static inline void *ioremap_fullcache(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
+}
+
+extern void iounmap(void *addr);
+
+/* Nothing to do */
+
+#define dma_cache_inv(_start,_size)		do { } while (0)
+#define dma_cache_wback(_start,_size)		do { } while (0)
+#define dma_cache_wback_inv(_start,_size)	do { } while (0)
+
+/* Pages to physical address... */
+#define page_to_phys(page)      ((page - mem_map) << PAGE_SHIFT)
+#define page_to_bus(page)       ((page - mem_map) << PAGE_SHIFT)
+
+/*
+ * Macros used for converting between virtual and physical mappings.
+ */
+#define mm_ptov(vaddr)		((void *) (vaddr))
+#define mm_vtop(vaddr)		((unsigned long) (vaddr))
+#define phys_to_virt(addr)	((void *)__phys_to_virt (addr))
+#define virt_to_phys(addr)	((unsigned long)__virt_to_phys (addr))
+
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif /* _LM32_ASM_IO_H */
diff --git a/include/asm-lm32/ioctl.h b/include/asm-lm32/ioctl.h
new file mode 100644
index 0000000..b279fe0
--- /dev/null
+++ b/include/asm-lm32/ioctl.h
@@ -0,0 +1 @@
+#include <asm-generic/ioctl.h>
diff --git a/include/asm-lm32/ioctls.h b/include/asm-lm32/ioctls.h
new file mode 100644
index 0000000..f3ad1fa
--- /dev/null
+++ b/include/asm-lm32/ioctls.h
@@ -0,0 +1,85 @@
+/*
+ * Based on:
+ * include/asm-arm/ioctls.h
+ */
+
+#ifndef _ASM_LM32_IOCTLS_H
+#define _ASM_LM32_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450  /* these numbers need to be adjusted. */
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define FIOQSIZE	0x545E
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT	0x01	/* Transmitter physically empty */
+
+#endif
diff --git a/include/asm-lm32/ipcbuf.h b/include/asm-lm32/ipcbuf.h
new file mode 100644
index 0000000..b1efffe
--- /dev/null
+++ b/include/asm-lm32/ipcbuf.h
@@ -0,0 +1,34 @@
+/*
+ * Based on:
+ * include/asm-arm/ipcbuf.h
+ */
+
+#ifndef __ASM_LM32_IPCBUF_H
+#define __ASM_LM32_IPCBUF_H
+
+/*
+ * The ipc64_perm structure for arm architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t and seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm
+{
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+	unsigned short		__pad1;
+	unsigned short		seq;
+	unsigned short		__pad2;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif
diff --git a/include/asm-lm32/irq.h b/include/asm-lm32/irq.h
new file mode 100644
index 0000000..747c6d9
--- /dev/null
+++ b/include/asm-lm32/irq.h
@@ -0,0 +1,71 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_IRQ_H
+#define _LM32_ASM_IRQ_H
+
+/* # of lm32 interrupts */
+#define NR_IRQS (32)
+
+/* # of lm32 irq levels */
+#define NR_IRQLVL	1
+
+#define	NO_IRQ		(-1)
+
+/* LM32: we always use the first timer in the hardware-description as the system timer */
+extern unsigned int  lm32_core_timer_irq;
+
+#define	IRQ_GPIO		(0)
+#define	IRQ_TIMER0		(1)
+#define	IRQ_TIMER1		(2)
+#define	IRQ_UARTRX		(3)
+#define	IRQ_UARTTX		(4)
+#define	IRQ_AC97CRREQUEST	(5)
+#define	IRQ_AC97CRREPLY		(6)
+#define	IRQ_AC97DMAR		(7)
+#define	IRQ_AC97DMAW		(8)
+#define	IRQ_PFPU		(9)
+#define	IRQ_TMU			(10)
+#define	IRQ_KEYBOARD		(11)
+#define	IRQ_MOUSE		(12)
+
+#define IRQ_SYSTMR	(IRQ_TIMER0)
+
+#include <linux/irq.h>
+
+#define irq_canonicalize(i) (i)
+
+extern unsigned long irq_err_count;
+static inline void ack_bad_irq(int irq)
+{
+	irq_err_count++;
+}
+
+
+/* in arch/lm32/kernel/irq.c */
+void lm32_irq_mask(unsigned int irq);
+void lm32_irq_unmask(unsigned int irq);
+void lm32_irq_ack(unsigned int irq);
+unsigned long lm32_irq_pending(void);
+
+#endif /* _LM32_ASM_IRQ_H_ */
diff --git a/include/asm-lm32/irq_regs.h b/include/asm-lm32/irq_regs.h
new file mode 100644
index 0000000..3dd9c0b
--- /dev/null
+++ b/include/asm-lm32/irq_regs.h
@@ -0,0 +1 @@
+#include <asm-generic/irq_regs.h>
diff --git a/include/asm-lm32/irqnode.h b/include/asm-lm32/irqnode.h
new file mode 100644
index 0000000..40c400c
--- /dev/null
+++ b/include/asm-lm32/irqnode.h
@@ -0,0 +1,59 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_IRQNODE_H
+#define _LM32_ASM_IRQNODE_H
+
+#include <linux/interrupt.h>
+
+/*
+ * This structure is used to chain together the ISRs for a particular
+ * interrupt source (if it supports chaining).
+ */
+typedef struct irq_node {
+	irq_handler_t	handler;
+	unsigned long	flags;
+	void *dev_id;
+	const char *devname;
+	struct irq_node *next;
+} irq_node_t;
+
+/*
+ * This structure has only 4 elements for speed reasons
+ */
+struct irq_entry {
+	irq_handler_t	handler;
+	unsigned long	flags;
+	void *dev_id;
+	const char *devname;
+};
+
+/* count of spurious interrupts */
+extern volatile unsigned int num_spurious;
+
+/*
+ * This function returns a new irq_node_t
+ */
+extern irq_node_t *new_irq_node(void);
+
+#endif /* _LM32_ASM_IRQNODE_H */
diff --git a/include/asm-lm32/kdebug.h b/include/asm-lm32/kdebug.h
new file mode 100644
index 0000000..6ece1b0
--- /dev/null
+++ b/include/asm-lm32/kdebug.h
@@ -0,0 +1 @@
+#include <asm-generic/kdebug.h>
diff --git a/include/asm-lm32/kmap_types.h b/include/asm-lm32/kmap_types.h
new file mode 100644
index 0000000..5ddad12
--- /dev/null
+++ b/include/asm-lm32/kmap_types.h
@@ -0,0 +1,29 @@
+/*
+ * Based on:
+ * include/asm-arm/kmap_types.h
+ */
+
+#ifndef _LM32_ASM_KMAP_TYPES_H
+#define _LM32_ASM_KMAP_TYPES_H
+
+/*
+ * This is the "bare minimum".  AIO seems to require this.
+ */
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BIO_SRC_IRQ,
+	KM_BIO_DST_IRQ,
+	KM_PTE0,
+	KM_PTE1,
+	KM_IRQ0,
+	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#endif
diff --git a/include/asm-lm32/linkage.h b/include/asm-lm32/linkage.h
new file mode 100644
index 0000000..8e7aece
--- /dev/null
+++ b/include/asm-lm32/linkage.h
@@ -0,0 +1,7 @@
+#ifndef _LM32_ASM_LINKAGE_H
+#define _LM32_ASM_LINKAGE_H
+
+#define __ALIGN .align 4
+#define __ALIGN_STR ".align 4"
+
+#endif
diff --git a/include/asm-lm32/local.h b/include/asm-lm32/local.h
new file mode 100644
index 0000000..c11c530
--- /dev/null
+++ b/include/asm-lm32/local.h
@@ -0,0 +1 @@
+#include <asm-generic/local.h>
diff --git a/include/asm-lm32/mman.h b/include/asm-lm32/mman.h
new file mode 100644
index 0000000..d56eaee
--- /dev/null
+++ b/include/asm-lm32/mman.h
@@ -0,0 +1,44 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_MMAN_H__
+#define _LM32_ASM_MMAN_H__
+
+#include <asm-generic/mman.h>
+
+/* These are linux-specific */
+#define MAP_NORESERVE	0x0400		/* don't check for reservations */
+#define MAP_GROWSDOWN	0x1000		/* stack-like segment */
+#define MAP_DENYWRITE	0x2000		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x4000		/* mark it as an executable */
+#define MAP_LOCKED	0x8000		/* pages are locked */
+#define MAP_POPULATE	0x10000		/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x20000		/* do not block on IO */
+
+/*
+ * Flags for mlockall
+ */
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#endif /* _LM32_ASM_MMAN_H__ */
diff --git a/include/asm-lm32/mmu.h b/include/asm-lm32/mmu.h
new file mode 100644
index 0000000..571fe42
--- /dev/null
+++ b/include/asm-lm32/mmu.h
@@ -0,0 +1,37 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LM32_MMU_H
+#define __LM32_MMU_H
+
+typedef struct {
+	struct vm_list_struct	*vmlist;
+	unsigned long		end_brk;
+
+#ifdef CONFIG_BINFMT_ELF_FDPIC
+	unsigned long	exec_fdpic_loadmap;
+	unsigned long	interp_fdpic_loadmap;
+#endif
+} mm_context_t;
+
+#endif 
diff --git a/include/asm-lm32/mmu_context.h b/include/asm-lm32/mmu_context.h
new file mode 100644
index 0000000..3eb9bb0
--- /dev/null
+++ b/include/asm-lm32/mmu_context.h
@@ -0,0 +1,32 @@
+#ifndef _LM32_MMU_CONTEXT_H
+#define _LM32_MMU_CONTEXT_H
+
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+#include <asm-generic/mm_hooks.h>
+
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+static inline int
+init_new_context(struct task_struct *tsk, struct mm_struct *mm)
+{
+	return(0);
+}
+
+#define destroy_context(mm)		do { } while(0)
+
+static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk)
+{
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+
+static inline void activate_mm(struct mm_struct *prev_mm,
+			       struct mm_struct *next_mm)
+{
+}
+
+#endif
diff --git a/include/asm-lm32/module.h b/include/asm-lm32/module.h
new file mode 100644
index 0000000..7f9e62a
--- /dev/null
+++ b/include/asm-lm32/module.h
@@ -0,0 +1,20 @@
+/*
+ * Based on:
+ * include/asm-arm/module.h
+ */
+
+#ifndef _LM32_ASM_MODULE_H
+#define _LM32_ASM_MODULE_H
+
+struct mod_arch_specific
+{
+	int foo;
+};
+
+#define Elf_Shdr	Elf32_Shdr
+#define Elf_Sym		Elf32_Sym
+#define Elf_Ehdr	Elf32_Ehdr
+
+#define MODULE_ARCH_VERMAGIC	"LM32v1"
+
+#endif /* _LM32_ASM_MODULE_H */
diff --git a/include/asm-lm32/msgbuf.h b/include/asm-lm32/msgbuf.h
new file mode 100644
index 0000000..f33f1cb
--- /dev/null
+++ b/include/asm-lm32/msgbuf.h
@@ -0,0 +1,33 @@
+/*
+ * Based on:
+ * include/asm-m68k/msgbuf.h
+ *
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+#ifndef _LM32_MSGBUF_H
+#define _LM32_MSGBUF_H
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long	__unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long	__unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long	__unused3;
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif /* _LM32_MSGBUF_H */
diff --git a/include/asm-lm32/mutex.h b/include/asm-lm32/mutex.h
new file mode 100644
index 0000000..3530a11
--- /dev/null
+++ b/include/asm-lm32/mutex.h
@@ -0,0 +1,2 @@
+/* TODO: there may be room for optimisation in mutex implementation */
+#include <asm-generic/mutex-dec.h>
diff --git a/include/asm-lm32/namei.h b/include/asm-lm32/namei.h
new file mode 100644
index 0000000..281546e
--- /dev/null
+++ b/include/asm-lm32/namei.h
@@ -0,0 +1,20 @@
+/*
+ * Based on:
+ * include/asm-blackfin/namei.h
+ *
+ * Included from linux/fs/namei.c
+ *
+ * Changes made by Lineo Inc.    May 2001
+ */
+
+#ifndef _ASM_LM32_NAMEI_H
+#define _ASM_LM32_NAMEI_H
+
+/* This dummy routine maybe changed to something useful
+ * for /usr/gnemul/ emulation stuff.
+ * Look at asm-sparc/namei.h for details.
+ */
+
+#define __emul_prefix() NULL
+
+#endif
diff --git a/include/asm-lm32/page.h b/include/asm-lm32/page.h
new file mode 100644
index 0000000..74c4389
--- /dev/null
+++ b/include/asm-lm32/page.h
@@ -0,0 +1,120 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * Based on:
+ * include/asm-v850/page.h -- VM ops
+ *
+ *  Copyright (C) 2001,02,03,05  NEC Electronics Corporation
+ *  Copyright (C) 2001,02,03,05  Miles Bader <miles@gnu.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file COPYING in the main directory of this
+ * archive for more details.
+ *
+ * Written by Miles Bader <miles@gnu.org>
+ */
+
+#ifndef _LM32_ASM_PAGE_H
+#define _LM32_ASM_PAGE_H
+
+#include <asm/setup.h>
+#include <asm/io.h>
+
+#ifdef __KERNEL__
+
+/* PAGE_SHIFT determines the page size */
+
+/* TODO: determine good page size, 12 means 2^12 bytes page size */
+#define PAGE_SHIFT	(13)
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#ifndef __ASSEMBLY__
+ 
+#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
+#define free_user_page(page, addr)	free_page(addr)
+
+#define clear_page(page)	memset((page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((to), (from), PAGE_SIZE)
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd[16]; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((&x)->pmd[0])
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) } )
+#define __pmd(x)	((pmd_t) { (x) } )
+#define __pgd(x)	((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+#endif /* !__ASSEMBLY__ */
+
+#define PAGE_OFFSET 0x00000000
+
+#ifndef __ASSEMBLY__
+
+/* No virtual memory.  */
+#define __virt_to_phys(addr)	(addr)
+#define __phys_to_virt(addr)	(addr)
+
+#define virt_to_pfn(kaddr)	(__pa(kaddr) >> PAGE_SHIFT)
+#define pfn_to_virt(pfn)	__va((pfn) << PAGE_SHIFT)
+
+#define virt_to_page(addr)	(mem_map + (((unsigned long)(addr)-PAGE_OFFSET) >> PAGE_SHIFT))
+#define page_to_virt(page)	((((page) - mem_map) << PAGE_SHIFT) + PAGE_OFFSET)
+
+//#define pfn_to_page(pfn)	virt_to_page(pfn_to_virt(pfn))
+//#define page_to_pfn(page)	virt_to_pfn(page_to_virt(page))
+#define pfn_valid(pfn)	        ((pfn) < max_mapnr)
+
+#define	virt_addr_valid(kaddr)	(((void *)(kaddr) >= (void *)PAGE_OFFSET) && \
+				((void *)(kaddr) < (void *)memory_end))
+
+#define __pa(vaddr)		__virt_to_phys((unsigned long)(vaddr))
+#define __va(paddr)		((void*)__phys_to_virt((unsigned long)(paddr)))
+
+#endif /* __ASSEMBLY__ */
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/page.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _LM32_PAGE_H */
diff --git a/include/asm-lm32/param.h b/include/asm-lm32/param.h
new file mode 100644
index 0000000..cde72f6
--- /dev/null
+++ b/include/asm-lm32/param.h
@@ -0,0 +1,18 @@
+#ifndef _LM32_ASM_PARAM_H
+#define _LM32_ASM_PARAM_H 
+
+#define CONFIG_SPLIT_PTLOCK_CPUS 4096
+
+#ifdef __KERNEL__
+#define HZ		CONFIG_HZ	/* Internal kernel timer frequency */
+#define	USER_HZ		HZ
+#define	CLOCKS_PER_SEC	(USER_HZ)
+#endif
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* _LM32_PARAM_H */
diff --git a/include/asm-lm32/pci.h b/include/asm-lm32/pci.h
new file mode 100644
index 0000000..b544613
--- /dev/null
+++ b/include/asm-lm32/pci.h
@@ -0,0 +1,86 @@
+/*
+ * Based on:
+ * linux/include/asm-xtensa/pci.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 - 2005 Tensilica Inc.
+ */
+
+// TODO: lm32 does not support PCI
+
+#ifndef _LM32_ASM_PCI_H
+#define _LM32_ASM_PCI_H
+
+#ifdef __KERNEL__
+
+/* Can be used to override the logic in pci_scan_bus for skipping
+ * already-configured bus numbers - to be used for buggy BIOSes
+ * or architectures with incomplete PCI setup by the loader
+ */
+
+#define pcibios_assign_all_busses()	0
+
+extern struct pci_controller* pcibios_alloc_controller(void);
+
+static inline void pcibios_set_master(struct pci_dev *dev)
+{
+	/* No special bus mastering setup handling */
+}
+
+static inline void pcibios_penalize_isa_irq(int irq)
+{
+	/* We don't do dynamic PCI IRQ allocation */
+}
+
+/* Assume some values. (We should revise them, if necessary) */
+
+#define PCIBIOS_MIN_IO		0x2000
+#define PCIBIOS_MIN_MEM		0x10000000
+
+/* Dynamic DMA mapping stuff.
+ * Xtensa has everything mapped statically like x86.
+ */
+
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <asm/scatterlist.h>
+#include <linux/string.h>
+#include <asm/io.h>
+
+struct pci_dev;
+
+/* The PCI address space does equal the physical memory address space.
+ * The networking and block device layers use this boolean for bounce buffer
+ * decisions.
+ */
+
+#define PCI_DMA_BUS_IS_PHYS	(1)
+
+/* pci_unmap_{page,single} is a no-op, so */
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME)
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME)
+#define pci_unmap_addr(PTR, ADDR_NAME)		(0)
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL)	do { } while (0)
+#define pci_ubnmap_len(PTR, LEN_NAME)		(0)
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL)	do { } while (0)
+
+/* We cannot access memory above 4GB */
+#define pci_dac_dma_supported(pci_dev, mask)	(0)
+
+static inline int pcibios_add_platform_entries(struct pci_dev *dev)
+{
+	return 0;
+}
+
+#endif /* __KERNEL__ */
+
+/* Implement the pci_ DMA API in terms of the generic device dma_ one */
+//#include <asm-generic/pci-dma-compat.h>
+
+/* Generic PCI */
+#include <asm-generic/pci.h>
+
+#endif
diff --git a/include/asm-lm32/percpu.h b/include/asm-lm32/percpu.h
new file mode 100644
index 0000000..06a959d
--- /dev/null
+++ b/include/asm-lm32/percpu.h
@@ -0,0 +1 @@
+#include <asm-generic/percpu.h>
diff --git a/include/asm-lm32/pgalloc.h b/include/asm-lm32/pgalloc.h
new file mode 100644
index 0000000..883c994
--- /dev/null
+++ b/include/asm-lm32/pgalloc.h
@@ -0,0 +1,8 @@
+#ifndef _LM32_ASM_PGALLOC_H
+#define _LM32_ASM_PGALLOC_H
+
+#include <asm/setup.h>
+
+#define check_pgt_cache()	do { } while (0)
+
+#endif
diff --git a/include/asm-lm32/pgtable.h b/include/asm-lm32/pgtable.h
new file mode 100644
index 0000000..4477556
--- /dev/null
+++ b/include/asm-lm32/pgtable.h
@@ -0,0 +1,93 @@
+/*
+ * Based on:
+ * include/asm-blackfin/pgtable.h
+ */
+
+#ifndef _LM32_ASM_PGTABLE_H
+#define _LM32_ASM_PGTABLE_H
+
+#include <asm-generic/4level-fixup.h>
+
+#include <asm/page.h>
+
+typedef pte_t *pte_addr_t;
+/*
+* Trivial page table functions.
+*/
+#define pgd_present(pgd)	(1)
+#define pgd_none(pgd)		(0)
+#define pgd_bad(pgd)		(0)
+#define pgd_clear(pgdp)
+#define kern_addr_valid(addr)	(1)
+
+#define pmd_offset(a, b)	((void *)0)
+#define pmd_none(x)		(!pmd_val(x))
+#define pmd_present(x)		(pmd_val(x))
+#define pmd_clear(xp)		do { set_pmd(xp, __pmd(0)); } while (0)
+#define pmd_bad(x)		(pmd_val(x) & ~PAGE_MASK)
+
+#define kern_addr_valid(addr) (1)
+
+#define PAGE_NONE		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_SHARED		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_COPY		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_READONLY		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_KERNEL		__pgprot(0)	/* these mean nothing to NO_MM */
+
+extern void paging_init(void);
+
+#define __swp_type(x)		(0)
+#define __swp_offset(x)		(0)
+#define __swp_entry(typ,off)	((swp_entry_t) { ((typ) | ((off) << 7)) })
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+static inline int pte_file(pte_t pte)
+{
+	return 0;
+}
+
+#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
+#define set_pte_at(mm, addr, ptep, pteval) set_pte(ptep, pteval)
+
+/*
+ * Page assess control based on Blackfin CPLB management
+ */
+#define PTE_BIT_FUNC(fn, op) static inline pte_t pte_##fn(pte_t _pte) { return _pte; }
+
+PTE_BIT_FUNC(rdprotect, &= ~_PAGE_RD);
+PTE_BIT_FUNC(mkread, |= _PAGE_RD);
+PTE_BIT_FUNC(wrprotect, &= ~_PAGE_WR);
+PTE_BIT_FUNC(mkwrite, |= _PAGE_WR);
+PTE_BIT_FUNC(exprotect, &= ~_PAGE_USER);
+PTE_BIT_FUNC(mkexec, |= _PAGE_USER);
+PTE_BIT_FUNC(mkclean, &= ~_PAGE_DIRTY);
+PTE_BIT_FUNC(mkdirty, |= _PAGE_DIRTY);
+PTE_BIT_FUNC(mkold, &= ~_PAGE_ACCESSED);
+PTE_BIT_FUNC(mkyoung, |= _PAGE_ACCESSED);
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+#define ZERO_PAGE(vaddr)	(virt_to_page(0))
+
+extern unsigned int kobjsize(const void *objp);
+
+#define swapper_pg_dir ((pgd_t *) 0)
+/*
+ * No page table caches to initialise.
+ */
+#define pgtable_cache_init()	do { } while (0)
+#define io_remap_pfn_range      remap_pfn_range
+
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
+#include <asm-generic/pgtable.h>
+
+#endif				/* _LM32_ASM_PGTABLE_H */
diff --git a/include/asm-lm32/poll.h b/include/asm-lm32/poll.h
new file mode 100644
index 0000000..c98509d
--- /dev/null
+++ b/include/asm-lm32/poll.h
@@ -0,0 +1 @@
+#include <asm-generic/poll.h>
diff --git a/include/asm-lm32/posix_types.h b/include/asm-lm32/posix_types.h
new file mode 100644
index 0000000..75bb000
--- /dev/null
+++ b/include/asm-lm32/posix_types.h
@@ -0,0 +1,70 @@
+/*
+ * Based on:
+ * include/asm-m68k/posix_types.h
+ */
+
+#ifndef __ARCH_LM32_ASM_POSIX_TYPES_H
+#define __ARCH_LM32_ASM_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int	val[2];
+#else /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int	__val[2];
+#endif /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
+
+#undef	__FD_CLR
+#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
+
+#undef	__FD_ISSET
+#define	__FD_ISSET(d, set)	((set)->fds_bits[__FDELT(d)] & __FDMASK(d))
+
+#undef	__FD_ZERO
+#define __FD_ZERO(fdsetp) (memset (fdsetp, 0, sizeof(*(fd_set *)fdsetp)))
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif
diff --git a/include/asm-lm32/processor.h b/include/asm-lm32/processor.h
new file mode 100644
index 0000000..0cf882b
--- /dev/null
+++ b/include/asm-lm32/processor.h
@@ -0,0 +1,112 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * Based on
+ * include/asm-m68knommu/processor.h
+ *
+ * Copyright (C) 1995 Hamish Macdonald
+ */
+
+#ifndef _ASM_LM32_PROCESSOR_H
+#define _ASM_LM32_PROCESSOR_H
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+#include <linux/compiler.h>
+#include <linux/threads.h>
+#include <asm/types.h>
+#include <asm/ptrace.h>
+#include <asm/current.h>
+
+/*
+ * User space process size: 3.75GB. This is hardcoded into a few places,
+ * so don't change it unless you know what you are doing.
+ */
+#define TASK_SIZE	(0xF0000000UL)
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's. We won't be using it
+ */
+#define TASK_UNMAPPED_BASE	0
+
+/* 
+ * if you change this structure, you must change the code and offsets
+ * in asm-offsets.c
+ */
+   
+struct thread_struct {
+	unsigned long ksp;	/* kernel stack pointer */
+	unsigned long usp;	/* user stack pointer */
+	unsigned long which_stack; /* 0 if we are on kernel stack, 1 if we are on user stack */
+	void *        debuggerinfo;
+};
+
+#define KSTK_TOS(tsk) ((unsigned long)task_stack_page(tsk) + THREAD_SIZE - 32)
+#define task_pt_regs(tsk) ((struct pt_regs *)KSTK_TOS(tsk) - 1)
+#define KSTK_EIP(tsk) 0
+#define KSTK_ESP(tsk) 0
+
+#define INIT_THREAD  { \
+	sizeof(init_stack) + (unsigned long) init_stack, 0, \
+	0, \
+	0 \
+}
+
+#define	reformat(_regs)		do { } while (0)
+
+/*
+ * Do necessary setup to start up a newly executed thread.
+ */
+extern void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp);
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+
+/* Free all resources held by a thread. */
+static inline void release_thread(struct task_struct *dead_task)
+{
+}
+
+/* Prepare to copy thread state - unlazy all lazy status */
+#define prepare_to_copy(tsk)	do { } while (0)
+
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/*
+ * Free current thread data structures etc..
+ */
+static inline void exit_thread(void)
+{
+}
+
+unsigned long thread_saved_pc(struct task_struct *tsk);
+unsigned long get_wchan(struct task_struct *p);
+
+#define cpu_relax()    barrier()
+
+#endif
diff --git a/include/asm-lm32/ptrace.h b/include/asm-lm32/ptrace.h
new file mode 100644
index 0000000..0d7a9e7
--- /dev/null
+++ b/include/asm-lm32/ptrace.h
@@ -0,0 +1,49 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_PTRACE_H
+#define _LM32_ASM_PTRACE_H
+
+#include <asm/registers.h>
+
+/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
+#define PTRACE_GETREGS            12
+#define PTRACE_SETREGS            13
+
+/* for gdb */
+#define PT_TEXT_ADDR	50
+#define PT_TEXT_END_ADDR	51
+#define PT_DATA_ADDR	52
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+#define user_mode(regs) (get_fs() == USER_DS)
+#define instruction_pointer(regs) ((regs)->ea)
+#define profile_pc(regs) instruction_pointer(regs)
+extern void show_regs(struct pt_regs *);
+
+#endif
+#endif
+
+#endif /* _LM32_PTRACE_H */
diff --git a/include/asm-lm32/registers.h b/include/asm-lm32/registers.h
new file mode 100644
index 0000000..67a468f
--- /dev/null
+++ b/include/asm-lm32/registers.h
@@ -0,0 +1,84 @@
+
+/* registers.h: register frame declarations
+ *
+ * Copyright (C) 2003 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _ASM_REGISTERS_H
+#define _ASM_REGISTERS_H
+
+#ifndef __ASSEMBLY__
+
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+struct pt_regs {
+  long     r0;
+  long     r1;
+  long     r2;
+  long     r3;
+  long     r4;
+  long     r5;
+  long     r6;
+  long     r7;
+  long     r8;
+  long     r9;
+  long     r10;
+  long     r11;
+  long     r12;
+  long     r13;
+  long     r14;
+  long     r15;
+  long     r16;
+  long     r17;
+  long     r18;
+  long     r19;
+  long     r20;
+  long     r21;
+  long     r22;
+  long     r23;
+  long     r24;
+  long     r25;
+  long     gp;
+  long     fp;
+  long     sp;
+  long     ra;
+  long     ea;
+  long     ba;
+};
+
+/* this defines the registers stored during an interrupt */
+struct int_regs {
+  long     r1;
+  long     r2;
+  long     r3;
+  long     r4;
+  long     r5;
+  long     r6;
+  long     r7;
+  long     r8;
+  long     r9;
+  long     r10;
+  long     ra;
+  long     ea;
+};
+
+/* no fp_regs but the kernel likes to have them */
+struct fp_regs
+{
+};
+
+struct user_context
+{
+	struct pt_regs regs;
+	struct fp_regs fpregs;
+} __attribute__((aligned(4)));
+
+#endif /* __ASSEMBLY__ */
+
+#endif
diff --git a/include/asm-lm32/resource.h b/include/asm-lm32/resource.h
new file mode 100644
index 0000000..04bc4db
--- /dev/null
+++ b/include/asm-lm32/resource.h
@@ -0,0 +1 @@
+#include <asm-generic/resource.h>
diff --git a/include/asm-lm32/scatterlist.h b/include/asm-lm32/scatterlist.h
new file mode 100644
index 0000000..03481c9
--- /dev/null
+++ b/include/asm-lm32/scatterlist.h
@@ -0,0 +1,25 @@
+/*
+ * Based on
+ * include/asm-m68knommu/scatterlist.h
+ */
+
+#ifndef _LM32_ASM_SCATTERLIST_H
+#define _LM32_ASM_SCATTERLIST_H
+
+#include <linux/mm.h>
+#include <asm/types.h>
+
+struct scatterlist {
+	struct page	*page;
+	unsigned int	offset;
+	dma_addr_t	dma_address;
+	unsigned int	length;
+};
+
+#define sg_address(sg)		(page_address((sg)->page) + (sg)->offset)
+#define sg_dma_address(sg)      ((sg)->dma_address)
+#define sg_dma_len(sg)          ((sg)->length)
+
+#define ISA_DMA_THRESHOLD	(0xffffffff)
+
+#endif /* _LM32_ASM_SCATTERLIST_H */
diff --git a/include/asm-lm32/sections.h b/include/asm-lm32/sections.h
new file mode 100644
index 0000000..2b8c516
--- /dev/null
+++ b/include/asm-lm32/sections.h
@@ -0,0 +1 @@
+#include <asm-generic/sections.h>
diff --git a/include/asm-lm32/segment.h b/include/asm-lm32/segment.h
new file mode 100644
index 0000000..96c4f0e
--- /dev/null
+++ b/include/asm-lm32/segment.h
@@ -0,0 +1,38 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_SEGMENT_H
+#define _LM32_ASM_SEGMENT_H
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned long mm_segment_t;
+
+#define USER_DS		(0x5)
+#define KERNEL_DS	(0xA)
+
+#define segment_eq(a,b)	((a) == (b))
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _LM32_ASM_SEGMENT_H */
diff --git a/include/asm-lm32/semaphore-helper.h b/include/asm-lm32/semaphore-helper.h
new file mode 100644
index 0000000..a12562c
--- /dev/null
+++ b/include/asm-lm32/semaphore-helper.h
@@ -0,0 +1,85 @@
+/*
+ * Based on:
+ * include/asm-blackfin/semaphore-helper.h
+ * 
+ * Based on M68K version,	Lineo Inc.	May 2001
+ *
+ * SMP- and interrupt-safe semaphores helper functions.
+ *
+ * (C) Copyright 1996 Linus Torvalds
+ *
+ */
+
+#ifndef _ASM_LM32_SEMAPHORE_HELPER_H
+#define _ASM_LM32_SEMAPHORE_HELPER_H
+
+#include <asm/errno.h>
+
+/*
+ * These two _must_ execute atomically wrt each other.
+ */
+static inline void wake_one_more(struct semaphore *sem)
+{
+	atomic_inc(&sem->waking);
+}
+
+static inline int waking_non_zero(struct semaphore *sem)
+{
+	int ret;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	ret = 0;
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 1;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+/*
+ * waking_non_zero_interruptible:
+ *	1	got the lock
+ *	0	go to sleep
+ *	-EINTR	interrupted
+ */
+static inline int waking_non_zero_interruptible(struct semaphore *sem,
+						struct task_struct *tsk)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 1;
+	} else if (signal_pending(tsk)) {
+		atomic_inc(&sem->count);
+		ret = -EINTR;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+/*
+ * waking_non_zero_trylock:
+ *	1	failed to lock
+ *	0	got the lock
+ */
+static inline int waking_non_zero_trylock(struct semaphore *sem)
+{
+	int ret = 1;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 0;
+	} else
+		atomic_inc(&sem->count);
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+#endif
diff --git a/include/asm-lm32/semaphore.h b/include/asm-lm32/semaphore.h
new file mode 100644
index 0000000..7b5c6a1
--- /dev/null
+++ b/include/asm-lm32/semaphore.h
@@ -0,0 +1,131 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * Based on 
+ * include/asm-v850/semaphore.h
+ * include/asm-m68k/semaphore.h
+ *
+ * Interrupt-safe semaphores..
+ *
+ * (C) Copyright 1996 Linus Torvalds
+ */
+
+
+#ifndef __ASM_LM32_SEMAPHORE_H
+#define __ASM_LM32_SEMAPHORE_H
+
+#ifndef __ASSEMBLY__
+
+#include <linux/linkage.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/rwsem.h>
+#include <asm/atomic.h>
+
+struct semaphore {
+	atomic_t count;
+	atomic_t waking;
+	int sleepers;
+	wait_queue_head_t wait;
+};
+
+#define __SEMAPHORE_INITIALIZER(name, n)				\
+{									\
+	.count		= ATOMIC_INIT(n),				\
+	.sleepers	= 0,						\
+	.wait		= __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)	\
+}
+
+#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
+
+#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+
+static inline void sema_init(struct semaphore *sem, int val)
+{
+	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER(*sem, val);
+}
+
+static inline void init_MUTEX(struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static inline void init_MUTEX_LOCKED(struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+asmlinkage void __down(struct semaphore *sem);
+asmlinkage int __down_interruptible(struct semaphore *sem);
+asmlinkage int __down_trylock(struct semaphore *sem);
+asmlinkage void __up(struct semaphore *sem);
+
+extern spinlock_t semaphore_wake_lock;
+
+/*
+ * This is ugly, but we want the default case to fall through.
+ * "down_failed" is a special asm handler that calls the C
+ * routine that actually waits.
+ */
+static inline void down(struct semaphore *sem)
+{
+	might_sleep();
+	if (atomic_dec_return(&sem->count) < 0)
+		__down(sem);
+}
+
+static inline int down_interruptible(struct semaphore *sem)
+{
+	int ret = 0;
+
+	might_sleep();
+	if (atomic_dec_return(&sem->count) < 0)
+		ret = __down_interruptible(sem);
+	return (ret);
+}
+
+static inline int down_trylock(struct semaphore *sem)
+{
+	int ret = 0;
+
+	if (atomic_dec_return(&sem->count) < 0)
+		ret = __down_trylock(sem);
+	return ret;
+}
+
+/*
+ * Note! This is subtle. We jump to wake people up only if
+ * the semaphore was negative (== somebody was waiting on it).
+ * The default case (no contention) will result in NO
+ * jumps for both down() and up().
+ */
+static inline void up(struct semaphore *sem)
+{
+	if (atomic_inc_return(&sem->count) <= 0)
+		__up(sem);
+}
+
+#endif				/* __ASSEMBLY__ */
+#endif
diff --git a/include/asm-lm32/sembuf.h b/include/asm-lm32/sembuf.h
new file mode 100644
index 0000000..af2cf46
--- /dev/null
+++ b/include/asm-lm32/sembuf.h
@@ -0,0 +1,30 @@
+/*
+ * Based on:
+ * include/asm-m68knommu/sembuf.h
+ */
+
+#ifndef _ASM_LM32_SEMBUF_H
+#define _ASM_LM32_SEMBUF_H
+
+/* 
+ * The semid64_ds structure for the Lattice Mico 32 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;		/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;		/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif 
diff --git a/include/asm-lm32/setup.h b/include/asm-lm32/setup.h
new file mode 100644
index 0000000..cb8f618
--- /dev/null
+++ b/include/asm-lm32/setup.h
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_SETUP_H
+#define _LM32_ASM_SETUP_H
+
+#ifndef __ASSEMBLY__
+
+#ifdef __KERNEL__
+
+extern unsigned int cpu_frequency;
+extern unsigned int sdram_start;
+extern unsigned int sdram_size;
+extern struct platform_device* milkymistuart_default_console_device;
+
+#endif /* __KERNEL__ */
+#endif /* #ifndef __ASSEMBLY__ */
+
+#define COMMAND_LINE_SIZE 256
+
+#endif
diff --git a/include/asm-lm32/shmbuf.h b/include/asm-lm32/shmbuf.h
new file mode 100644
index 0000000..351a492
--- /dev/null
+++ b/include/asm-lm32/shmbuf.h
@@ -0,0 +1,47 @@
+/*
+ * Based on:
+ * include/asm-m68k/shmbuf.h
+ */
+
+#ifndef _LM32_ASM_SHMBUF_H
+#define _LM32_ASM_SHMBUF_H
+
+/*
+ * The shmid64_ds structure for lm32 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	unsigned long		__unused1;
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	unsigned long		__unused2;
+	__kernel_time_t		shm_ctime;	/* last change time */
+	unsigned long		__unused3;
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _LM32_ASM_SHMBUF_H */
diff --git a/include/asm-lm32/shmparam.h b/include/asm-lm32/shmparam.h
new file mode 100644
index 0000000..65523c5
--- /dev/null
+++ b/include/asm-lm32/shmparam.h
@@ -0,0 +1,6 @@
+#ifndef _LM32_ASM_SHMPARAM_H
+#define _LM32_ASM_SHMPARAM_H
+
+#define	SHMLBA PAGE_SIZE		 /* attach addr a multiple of this */
+
+#endif /* _LM32_ASM_SHMPARAM_H */
diff --git a/include/asm-lm32/sigcontext.h b/include/asm-lm32/sigcontext.h
new file mode 100644
index 0000000..80489bc
--- /dev/null
+++ b/include/asm-lm32/sigcontext.h
@@ -0,0 +1,49 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_LM32_SIGCONTEXT_H
+#define __ASM_LM32_SIGCONTEXT_H
+
+#include <asm/registers.h>
+
+/*
+ * Signal context structure - contains all info to do with the state
+ * before the signal handler was invoked.  Note: only add new entries
+ * to the end of the structure.
+ */
+struct sigcontext {
+	struct pt_regs regs;
+	unsigned long oldmask;
+	/* TODO
+  unsigned long exception_no;
+  unsigned long sc_pc;
+  unsigned long sc_regs[32];
+  unsigned long sc_EBA;
+  unsigned long sc_DEBA;
+  unsigned long sc_IM;
+  unsigned long sc_IP;
+	*/
+};
+
+
+#endif
diff --git a/include/asm-lm32/siginfo.h b/include/asm-lm32/siginfo.h
new file mode 100644
index 0000000..0815d29
--- /dev/null
+++ b/include/asm-lm32/siginfo.h
@@ -0,0 +1 @@
+#include <asm-generic/siginfo.h>
diff --git a/include/asm-lm32/signal.h b/include/asm-lm32/signal.h
new file mode 100644
index 0000000..d91bd37
--- /dev/null
+++ b/include/asm-lm32/signal.h
@@ -0,0 +1,183 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_LM32_SIGNAL_H
+#define __ASM_LM32_SIGNAL_H
+
+#include <linux/types.h>
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+#ifdef __KERNEL__
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
+#define _NSIG		64
+#define _NSIG_BPW	32
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+typedef unsigned long old_sigset_t;	/* at least 32 bits */
+
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif				/* __KERNEL__ */
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001
+#define SA_NOCLDWAIT	0x00000002	/* not supported yet */
+#define SA_SIGINFO	0x00000004
+#define SA_ONSTACK	0x08000000
+#define SA_RESTART	0x10000000
+#define SA_NODEFER	0x40000000
+#define SA_RESETHAND	0x80000000
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+/*
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#include <asm-generic/signal.h>
+
+#ifdef __KERNEL__
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer) (void);
+};
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	void (*sa_restorer) (void);
+	sigset_t sa_mask;	/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+struct sigaction {
+	union {
+		__sighandler_t _sa_handler;
+		void (*_sa_sigaction) (int, struct siginfo *, void *);
+	} _u;
+	sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer) (void);
+};
+
+#define sa_handler	_u._sa_handler
+#define sa_sigaction	_u._sa_sigaction
+
+#endif				/* __KERNEL__ */
+
+typedef struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#ifdef __KERNEL__
+
+#include <asm/sigcontext.h>
+#undef __HAVE_ARCH_SIG_BITOPS
+
+#define ptrace_signal_deliver(regs, cookie) do { } while (0)
+
+#endif				/* __KERNEL__ */
+
+#endif
diff --git a/include/asm-lm32/socket.h b/include/asm-lm32/socket.h
new file mode 100644
index 0000000..bd09945
--- /dev/null
+++ b/include/asm-lm32/socket.h
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_SOCKET_H
+#define _LM32_ASM_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockoptions(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER	26
+#define SO_DETACH_FILTER	27
+
+#define SO_PEERNAME		28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+#define SO_PEERSEC		31
+#define SO_PASSSEC		34
+#define SO_TIMESTAMPNS		35
+#define SCM_TIMESTAMPNS		SO_TIMESTAMPNS
+#endif /* _LM32_ASM_SOCKET_H */
diff --git a/include/asm-lm32/sockios.h b/include/asm-lm32/sockios.h
new file mode 100644
index 0000000..70a1424
--- /dev/null
+++ b/include/asm-lm32/sockios.h
@@ -0,0 +1,18 @@
+/*
+ * Based on:
+ * include/asm-arm/sockios.h
+ */
+
+#ifndef _LM32_ASM_SOCKIOS__
+#define _LM32_ASM_SOCKIOS__
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906		/* Get stamp (timeval) */
+#define SIOCGSTAMPNS	0x8907		/* Get stamp (timespec) */
+
+#endif /* _LM32_ASM_SOCKIOS__ */
diff --git a/include/asm-lm32/stat.h b/include/asm-lm32/stat.h
new file mode 100644
index 0000000..1121416
--- /dev/null
+++ b/include/asm-lm32/stat.h
@@ -0,0 +1,82 @@
+/*
+ * Based on:
+ * include/asm-m68k/stat.h
+ */
+
+#ifndef _LM32_ASM_STAT_H
+#define _LM32_ASM_STAT_H
+
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned long  st_size;
+	unsigned long  st_atime;
+	unsigned long  st_mtime;
+	unsigned long  st_ctime;
+};
+
+struct stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long  st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+	unsigned long  __unused1;
+	unsigned long  st_mtime;
+	unsigned long  __unused2;
+	unsigned long  st_ctime;
+	unsigned long  __unused3;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned long long	st_dev;
+	unsigned char	__pad1[4];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned long	__st_ino;
+
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long	st_rdev;
+	unsigned char	__pad3[4];
+
+	long long	st_size;
+	unsigned long	st_blksize;
+
+	unsigned long long	st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long long	st_ino;
+};
+
+#endif /* _LM32_ASM_STAT_H */
diff --git a/include/asm-lm32/statfs.h b/include/asm-lm32/statfs.h
new file mode 100644
index 0000000..0b91fe1
--- /dev/null
+++ b/include/asm-lm32/statfs.h
@@ -0,0 +1 @@
+#include <asm-generic/statfs.h>
diff --git a/include/asm-lm32/string.h b/include/asm-lm32/string.h
new file mode 100644
index 0000000..2e29682
--- /dev/null
+++ b/include/asm-lm32/string.h
@@ -0,0 +1,6 @@
+#ifndef _LM32_ASM_STRING_H
+#define _LM32_ASM_STRING_H
+
+//#include <asm/setup.h>
+
+#endif	/* _LM32_ASM_STRING_H */
diff --git a/include/asm-lm32/system.h b/include/asm-lm32/system.h
new file mode 100644
index 0000000..a15c06b
--- /dev/null
+++ b/include/asm-lm32/system.h
@@ -0,0 +1,199 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_SYSTEM_H
+#define _LM32_ASM_SYSTEM_H
+
+#include <linux/linkage.h>
+
+#ifndef __ASSEMBLY__
+
+static inline int local_irq_disable(void)
+{
+	unsigned int old_ie, new_ie;
+	asm volatile (
+		"mvi %0,0xfffffffe\n" \
+		"rcsr %1, IE\n" \
+		"and %0, %1, %0\n" \
+		"wcsr IE, %0\n" \
+		"andi %1, %1, 1\n" \
+		: "=r"(new_ie), "=r"(old_ie) \
+	);
+	return old_ie;
+}
+
+static inline void local_irq_enable(void)
+{
+	unsigned int ie;
+	asm volatile (
+		"rcsr %0, IE\n" 
+		"ori %0, %0, 1\n"
+		"wcsr IE, %0\n"
+		: "=r"(ie));
+}
+
+#define local_save_flags(x) asm volatile ("rcsr %0, IE\n" : "=r"(x))
+
+#define local_irq_save(x) { x = local_irq_disable(); }
+
+#define local_irq_restore(x) { unsigned int ie; \
+	asm volatile ( \
+		"rcsr %0, IE\n" \
+		"or %0, %0, %1\n" \
+		"wcsr IE, %0\n": \
+		 "=&r"(ie): "r"(x) ); }
+
+static inline int irqs_disabled(void)
+{
+	unsigned long flags;
+	local_save_flags(flags);
+	return ((flags & 0x1) == 0);
+}
+
+extern asmlinkage struct task_struct* resume(struct task_struct* last, struct task_struct* next);
+
+#define switch_to(prev,next,last)				\
+do {								\
+  lm32_current_thread = task_thread_info(next);  	\
+  last = resume(prev, next);	\
+} while (0)
+
+#define nop()  asm volatile ("nop"::)
+#define mb()   asm volatile (""   : : :"memory")
+#define rmb()  asm volatile (""   : : :"memory")
+#define wmb()  asm volatile (""   : : :"memory")
+#define set_rmb(var, value)    do { xchg(&var, value); } while (0)
+#define set_mb(var, value)     set_rmb(var, value)
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#define smp_read_barrier_depends()	read_barrier_depends()
+#else
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#define smp_read_barrier_depends()	do { } while(0)
+#endif
+
+#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	unsigned long ret;
+	unsigned long flags;
+
+	switch (size) {
+	case 1:
+		local_irq_save(flags);
+		ret = *(volatile unsigned char *)ptr;
+		*(volatile unsigned char *)ptr = x;
+		local_irq_restore(flags);
+		break;
+
+	case 2:
+		local_irq_save(flags);
+		ret = *(volatile unsigned short *)ptr;
+		*(volatile unsigned short *)ptr = x;
+		local_irq_restore(flags);
+		break;
+
+	case 4:
+		local_irq_save(flags);
+		ret = *(volatile unsigned long *)ptr;
+		*(volatile unsigned long *)ptr = x;
+		local_irq_restore(flags);
+		break;
+
+	}
+
+	return ret;
+}
+
+
+/*
+ * Atomic compare and exchange.  Compare OLD with MEM, if identical,
+ * store NEW in MEM.  Return the initial value in MEM.  Success is
+ * indicated by comparing RETURN with OLD.
+ */
+
+static inline unsigned long __cmpxchg_u32(volatile int *p, unsigned long old,
+					  unsigned long nnew)
+{
+	 unsigned long flags;
+	 int prev;
+
+	 local_irq_save(flags);
+	 if ((prev = *p) == old)
+					 *p = nnew;
+	 local_irq_restore(flags);
+	 return(prev);
+}
+
+static inline unsigned long long __cmpxchg_u64(volatile long long *p, unsigned long long old,
+					  unsigned long long nnew)
+{
+	 unsigned long flags;
+	 int prev;
+
+	 local_irq_save(flags);
+	 if ((prev = *p) == old)
+					 *p = nnew;
+	 local_irq_restore(flags);
+	 return(prev);
+}
+
+/* This function doesn't exist, so you'll get a linker error
+   if something tries to do an invalid cmpxchg().  */
+extern void __cmpxchg_called_with_bad_pointer(void);
+
+//#define __HAVE_ARCH_CMPXCHG 1
+
+static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
+				      unsigned long new, int size)
+{
+	switch (size) {
+	case 4:
+		return __cmpxchg_u32(ptr, old, new);
+	case 8:
+		return __cmpxchg_u64(ptr, old, new);
+	}
+
+	__cmpxchg_called_with_bad_pointer();
+	return old;
+}
+
+#define cmpxchg(ptr, old, new)					\
+	((typeof(*(ptr)))__cmpxchg((ptr), (unsigned long)(old),	\
+				   (unsigned long)(new),	\
+				   sizeof(*(ptr))))
+
+//TODO: implement reset
+//#define HARD_RESET_NOW() {}
+
+#define arch_align_stack(x) (x)
+
+#endif /* !__ASSEMBLY__ */
+
+#endif 
diff --git a/include/asm-lm32/termbits.h b/include/asm-lm32/termbits.h
new file mode 100644
index 0000000..ffca52e
--- /dev/null
+++ b/include/asm-lm32/termbits.h
@@ -0,0 +1,191 @@
+/*
+ * Based on:
+ * include/asm-m68k/termbits.h
+ */
+
+#ifndef _LM32_ASM_TERMBITS_H__
+#define _LM32_ASM_TERMBITS_H__
+
+#include <linux/posix_types.h>
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+};
+
+struct ktermios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8	0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000		/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000		/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif /* _LM32_ASM_TERMBITS_H__ */
diff --git a/include/asm-lm32/termios.h b/include/asm-lm32/termios.h
new file mode 100644
index 0000000..c7296de
--- /dev/null
+++ b/include/asm-lm32/termios.h
@@ -0,0 +1,92 @@
+/*
+ * Based on:
+ * include/asm-m68k/termios.h
+ */
+
+#ifndef _LM32_ASM_TERMIOS_H
+#define _LM32_ASM_TERMIOS_H
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+#ifdef __KERNEL__
+/*	intr=^C		quit=^\		erase=del	kill=^U
+	eof=^D		vtime=\0	vmin=\1		sxtc=\0
+	start=^Q	stop=^S		susp=^Z		eol=\0
+	reprint=^R	discard=^U	werase=^W	lnext=^V
+	eol2=\0
+*/
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
+
+/*
+ * Translate a "termio" structure into a "termios". Ugh.
+ */
+#define user_termio_to_kernel_termios(termios, termio) \
+({ \
+	unsigned short tmp; \
+	get_user(tmp, &(termio)->c_iflag); \
+	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
+	get_user(tmp, &(termio)->c_oflag); \
+	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
+	get_user(tmp, &(termio)->c_cflag); \
+	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
+	get_user(tmp, &(termio)->c_lflag); \
+	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
+	get_user((termios)->c_line, &(termio)->c_line); \
+	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
+})
+
+/*
+ * Translate a "termios" structure into a "termio". Ugh.
+ */
+#define kernel_termios_to_user_termio(termio, termios) \
+({ \
+	put_user((termios)->c_iflag, &(termio)->c_iflag); \
+	put_user((termios)->c_oflag, &(termio)->c_oflag); \
+	put_user((termios)->c_cflag, &(termio)->c_cflag); \
+	put_user((termios)->c_lflag, &(termio)->c_lflag); \
+	put_user((termios)->c_line,  &(termio)->c_line); \
+	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
+})
+
+#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios))
+#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios))
+
+#endif	/* __KERNEL__ */
+
+#endif /* _LM32_ASM_TERMIOS_H */
diff --git a/include/asm-lm32/thread_info.h b/include/asm-lm32/thread_info.h
new file mode 100644
index 0000000..3945221
--- /dev/null
+++ b/include/asm-lm32/thread_info.h
@@ -0,0 +1,117 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_THREAD_INFO_H
+#define _LM32_ASM_THREAD_INFO_H
+
+#include <asm/page.h>
+#include <asm/segment.h>
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+/*
+ * Size of kernel stack for each process. This must be a power of 2...
+ */
+#define THREAD_SIZE_ORDER (2)
+#define THREAD_SIZE (PAGE_SIZE<<THREAD_SIZE_ORDER)
+
+/*
+ * low level task data.
+ */
+struct thread_info {
+	struct task_struct *task;		/* main task structure */
+	struct exec_domain *exec_domain;	/* execution domain */
+	unsigned long	   flags;		/* low level flags */
+	int		   cpu;			/* cpu we're on */
+	int		   preempt_count;	/* 0 => preemptable, <0 => BUG */
+	struct restart_block restart_block;
+	mm_segment_t	mem_seg; /* USER_DS if user mode thread, KERNEL_DS if kernel mode thread */
+};
+
+/*
+ * macros/functions for gaining access to the thread information structure
+ */
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.task		= &tsk,			\
+	.exec_domain	= &default_exec_domain,	\
+	.flags		= 0,			\
+	.cpu		= 0,			\
+	.preempt_count	= 0,			\
+	.restart_block	= {			\
+		.fn = do_no_restart_syscall,	\
+	},					\
+	.mem_seg = KERNEL_DS, \
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+
+/*
+ * how to get the thread information struct from C
+ */
+static inline struct thread_info *current_thread_info(void) __attribute_const__;
+
+extern struct thread_info* lm32_current_thread;
+
+static inline struct thread_info *current_thread_info(void)
+{
+	return lm32_current_thread;
+}
+
+
+/* thread information allocation */
+#define alloc_thread_info(tsk) ((struct thread_info *) \
+				__get_free_pages(GFP_KERNEL, THREAD_SIZE_ORDER))
+#define free_thread_info(ti)	free_pages((unsigned long) (ti), THREAD_SIZE_ORDER)
+#endif /* __ASSEMBLY__ */
+
+#define	PREEMPT_ACTIVE	0x4000000
+
+/*
+ * thread information flag bit numbers
+ */
+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
+#define TIF_NOTIFY_RESUME	1	/* resumption notification requested */
+#define TIF_SIGPENDING		2	/* signal pending */
+#define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_POLLING_NRFLAG	4	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		5
+#define TIF_RESTORE_SIGMASK	6
+
+/* as above, but as bit values */
+#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
+#define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
+#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+#define _TIF_RESTORE_SIGMASK	(1<<TIF_RESTORE_SIGMASK)
+
+#define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
+
+#endif /* __KERNEL__ */
+
+#endif /* _LM32_ASM_THREAD_INFO_H */
diff --git a/include/asm-lm32/timex.h b/include/asm-lm32/timex.h
new file mode 100644
index 0000000..bfe5b22
--- /dev/null
+++ b/include/asm-lm32/timex.h
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ASM_TIMEX_H
+#define _ASM_TIMEX_H
+
+#ifdef __KERNEL__
+
+/* cannot use value supplied by bootloader because this value is used in an #if */
+/* 100 MHz works as default value, even for 75 MHz bitstreams */
+#define CLOCK_TICK_RATE		(100*1000*1000)
+
+#endif /* __KERNEL__ */
+
+typedef unsigned long long cycles_t;
+
+cycles_t get_cycles(void);
+
+void lm32_systimer_ack(void);
+void lm32_systimer_program(int periodic, cycles_t cyc);
+
+#endif /*  _ASM_TIMEX_H */
diff --git a/include/asm-lm32/tlb.h b/include/asm-lm32/tlb.h
new file mode 100644
index 0000000..37a07a3
--- /dev/null
+++ b/include/asm-lm32/tlb.h
@@ -0,0 +1,20 @@
+#ifndef _LM32_ASM_TLB_H
+#define _LM32_ASM_TLB_H
+
+/*
+ * lm32 doesn't need any special per-pte or
+ * per-vma handling..
+ */
+#define tlb_start_vma(tlb, vma)	do { } while (0)
+#define tlb_end_vma(tlb, vma)	do { } while (0)
+#define __tlb_remove_tlb_entry(tlb, ptep, address)	do { } while (0)
+
+/*
+ * .. because we flush the whole mm when it
+ * fills up.
+ */
+#define tlb_flush(tlb)		flush_tlb_mm((tlb)->mm)
+
+#include <asm-generic/tlb.h>
+
+#endif /* _LM32_ASM_TLB_H */
diff --git a/include/asm-lm32/tlbflush.h b/include/asm-lm32/tlbflush.h
new file mode 100644
index 0000000..562bf38
--- /dev/null
+++ b/include/asm-lm32/tlbflush.h
@@ -0,0 +1,64 @@
+/*
+ * Based on:
+ * include/arch/asm-m68knommu/tlbflush.h
+ * 
+ * Copyright (C) 2000 Lineo, David McCullough <davidm@uclinux.org>
+ * Copyright (C) 2000-2002, Greg Ungerer <gerg@snapgear.com>
+ */
+
+#ifndef _LM32_ASM_TLBFLUSH_H
+#define _LM32_ASM_TLBFLUSH_H
+
+#include <asm/setup.h>
+
+/*
+ * flush all user-space atc entries.
+ */
+static inline void __flush_tlb(void)
+{
+	BUG();
+}
+
+static inline void __flush_tlb_one(unsigned long addr)
+{
+	BUG();
+}
+
+#define flush_tlb() __flush_tlb()
+
+/*
+ * flush all atc entries (both kernel and user-space entries).
+ */
+static inline void flush_tlb_all(void)
+{
+	BUG();
+}
+
+static inline void flush_tlb_mm(struct mm_struct *mm)
+{
+	BUG();
+}
+
+static inline void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)
+{
+	BUG();
+}
+
+static inline void flush_tlb_range(struct mm_struct *mm,
+				   unsigned long start, unsigned long end)
+{
+	BUG();
+}
+
+static inline void flush_tlb_kernel_page(unsigned long addr)
+{
+	BUG();
+}
+
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
+				      unsigned long start, unsigned long end)
+{
+	BUG();
+}
+
+#endif /* _LM32_ASM_TLBFLUSH_H */
diff --git a/include/asm-lm32/topology.h b/include/asm-lm32/topology.h
new file mode 100644
index 0000000..5428f33
--- /dev/null
+++ b/include/asm-lm32/topology.h
@@ -0,0 +1 @@
+#include <asm-generic/topology.h>
diff --git a/include/asm-lm32/traps.h b/include/asm-lm32/traps.h
new file mode 100644
index 0000000..6289ddb
--- /dev/null
+++ b/include/asm-lm32/traps.h
@@ -0,0 +1,10 @@
+#ifndef __ASM_LM32_TRAPS_H
+#define __ASM_LM32_TRAPS_H
+
+#ifdef CONFIG_LM32_HW_JTAG
+#define LM32_HW_JTAG  1
+#else
+#undef LM32_HW_JTAG
+#endif
+
+#endif
diff --git a/include/asm-lm32/types.h b/include/asm-lm32/types.h
new file mode 100644
index 0000000..9bd8838
--- /dev/null
+++ b/include/asm-lm32/types.h
@@ -0,0 +1,97 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * Based on:
+ * include/asm-m68k/types.h
+ */
+
+#ifndef _LM32_ASM_TYPES_H
+#define _LM32_ASM_TYPES_H
+
+#include <asm/param.h>
+
+/*
+ * This file is never included by application software unless
+ * explicitly requested (e.g., via linux/types.h) in which case the
+ * application is Linux specific so (user-) name space pollution is
+ * not a major issue.  However, for interoperability, libraries still
+ * need to be careful to avoid a name clashes.
+ */
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+/* DMA addresses are always 32-bits wide */
+
+// TODO ensure this is correct once dma is implemented
+typedef u32 dma_addr_t;
+typedef u32 dma64_addr_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif /* _LM32_TYPES_H */
diff --git a/include/asm-lm32/uaccess.h b/include/asm-lm32/uaccess.h
new file mode 100644
index 0000000..1139470
--- /dev/null
+++ b/include/asm-lm32/uaccess.h
@@ -0,0 +1,205 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_UACCESS_H
+#define _LM32_ASM_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+
+#include <asm/thread_info.h>
+#include <asm/segment.h>
+#include <asm-generic/uaccess.h>
+#include <asm-generic/sections.h>
+
+#define VERIFY_READ	0
+#define VERIFY_WRITE	1
+
+#define access_ok(type,addr,size)	_access_ok((unsigned long)(addr),(size))
+
+static inline int _access_ok(unsigned long addr, unsigned long size)
+{
+	extern unsigned long physical_memory_start;
+	extern unsigned long physical_memory_end;
+
+	return
+		(addr >= physical_memory_start) &&
+		(addr < physical_memory_end) &&
+		((addr+size) <= physical_memory_end);
+}
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+/* Returns 0 if exception not found and fixup otherwise.  */
+extern unsigned long search_exception_table(unsigned long);
+
+
+/*
+ * These are the main single-value transfer routines.  They automatically
+ * use the right size if we just have the right pointer type.
+ */
+
+#define put_user(x, ptr)				\
+({							\
+    int __pu_err = 0;					\
+    typeof(*(ptr)) __pu_val = (x);			\
+    switch (sizeof (*(ptr))) {				\
+    case 1:						\
+    case 2:						\
+    case 4:						\
+    case 8:						\
+	memcpy(ptr, &__pu_val, sizeof (*(ptr))); \
+	break;						\
+    default:						\
+	__pu_err = __put_user_bad();			\
+	break;						\
+    }							\
+    __pu_err;						\
+})
+#define __put_user(x, ptr) put_user(x, ptr)
+
+extern int __put_user_bad(void);
+
+/*
+ * Tell gcc we read from memory instead of writing: this is because
+ * we do not write to any memory gcc knows about, so there are no
+ * aliasing issues.
+ */
+
+#define __ptr(x) ((unsigned long *)(x))
+
+#define get_user(x, ptr)					\
+({								\
+    int __gu_err = 0;						\
+    typeof(x) __gu_val = 0;					\
+    switch (sizeof(*(ptr))) {					\
+    case 1:							\
+    case 2:							\
+    case 4:							\
+    case 8:							\
+	memcpy((void *) &__gu_val, ptr, sizeof (*(ptr)));	\
+	break;							\
+    default:							\
+	__gu_val = 0;						\
+	__gu_err = __get_user_bad();				\
+	break;							\
+    }								\
+    (x) = (typeof(*(ptr))) __gu_val;				\
+    __gu_err;							\
+})
+#define __get_user(x, ptr) get_user(x, ptr)
+
+extern int __get_user_bad(void);
+
+#define copy_from_user(to, from, n) (access_ok(VERIFY_READ,(from),(n))?(memcpy((to),(from),(n)),0):-EFAULT)
+#define copy_to_user(to, from, n) (access_ok(VERIFY_WRITE,(to),(n))?(memcpy((to),(from),(n)),0):-EFAULT)
+
+#define __copy_from_user(to, from, n) copy_from_user(to, from, n)
+#define __copy_to_user(to, from, n) copy_to_user(to, from, n)
+#define __copy_to_user_inatomic __copy_to_user
+#define __copy_from_user_inatomic __copy_from_user
+
+#define copy_to_user_ret(to,from,n,retval) ({ if (copy_to_user(to,from,n)) return retval; })
+
+#define copy_from_user_ret(to,from,n,retval) ({ if (copy_from_user(to,from,n)) return retval; })
+
+/*
+ * Copy a null terminated string from userspace.
+ */
+
+static inline long
+strncpy_from_user(char *dst, const char *src, long count)
+{
+	char *tmp;
+	if( !access_ok(VERIFY_READ, src, count) )
+		return -EFAULT;
+	strncpy(dst, src, count);
+	for (tmp = dst; *tmp && count > 0; tmp++, count--)
+		;
+	return(tmp - dst); /* TODO DAVIDM should we count a NUL ?  check getname */
+}
+
+#define __strncpy_from_user(dst,src,count) strncpy_from_user(dst,src,count)
+
+/*
+ * Return the size of a string (including the ending 0)
+ *
+ * Return 0 on exception, a value greater than N if too long
+ */
+static inline long strnlen_user(const char *src, long n)
+{
+	return(strlen(src) + 1); /* TODO DAVIDM make safer */
+}
+
+#define strlen_user(str) strnlen_user(str, 32767)
+
+/*
+ * Zero Userspace
+ */
+
+static inline unsigned long
+clear_user(void *to, unsigned long n)
+{
+	memset(to, 0, n);
+	return 0;
+}
+
+#define __clear_user clear_user
+
+static inline mm_segment_t get_fs(void)
+{
+    return current_thread_info()->mem_seg;
+}
+
+static inline mm_segment_t get_ds(void)
+{
+    /* return the supervisor data space code */
+    return KERNEL_DS;
+}
+
+static inline void set_fs(mm_segment_t val)
+{
+    current_thread_info()->mem_seg = val;
+}
+
+#endif /* _LM32_ASM_UACCESS_H */
diff --git a/include/asm-lm32/unaligned.h b/include/asm-lm32/unaligned.h
new file mode 100644
index 0000000..6cecbbb
--- /dev/null
+++ b/include/asm-lm32/unaligned.h
@@ -0,0 +1 @@
+#include <asm-generic/unaligned.h>
diff --git a/include/asm-lm32/unistd.h b/include/asm-lm32/unistd.h
new file mode 100644
index 0000000..2a6254a
--- /dev/null
+++ b/include/asm-lm32/unistd.h
@@ -0,0 +1,418 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_LM32_UNISTD_H
+#define __ASM_LM32_UNISTD_H
+
+#define __NR_SYSCALL_BASE	0
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_exit		  1
+#define __NR_fork		  2
+#define __NR_read		  3
+#define __NR_write		  4
+#define __NR_open		  5
+#define __NR_close		  6
+				/* 7 __NR_waitpid obsolete */
+#define __NR_creat		  8
+#define __NR_link		  9
+#define __NR_unlink		 10
+#define __NR_execve		 11
+#define __NR_chdir		 12
+#define __NR_time		 13
+#define __NR_mknod		 14
+#define __NR_chmod		 15
+#define __NR_chown		 16
+				/* 17 __NR_break obsolete */
+				/* 18 __NR_oldstat obsolete */
+#define __NR_lseek		 19
+#define __NR_getpid		 20
+#define __NR_mount		 21
+				/* 22 __NR_umount obsolete */
+#define __NR_setuid		 23
+#define __NR_getuid		 24
+#define __NR_stime		 25
+#define __NR_ptrace		 26
+#define __NR_alarm		 27
+				/* 28 __NR_oldfstat obsolete */
+#define __NR_pause		 29
+				/* 30 __NR_utime obsolete */
+				/* 31 __NR_stty obsolete */
+				/* 32 __NR_gtty obsolete */
+#define __NR_access		 33
+#define __NR_nice		 34
+				/* 35 __NR_ftime obsolete */
+#define __NR_sync		 36
+#define __NR_kill		 37
+#define __NR_rename		 38
+#define __NR_mkdir		 39
+#define __NR_rmdir		 40
+#define __NR_dup		 41
+#define __NR_pipe		 42
+#define __NR_times		 43
+				/* 44 __NR_prof obsolete */
+#define __NR_brk		 45
+#define __NR_setgid		 46
+#define __NR_getgid		 47
+				/* 48 __NR_signal obsolete */
+#define __NR_geteuid		 49
+#define __NR_getegid		 50
+#define __NR_acct		 51
+#define __NR_umount2		 52
+				/* 53 __NR_lock obsolete */
+#define __NR_ioctl		 54
+#define __NR_fcntl		 55
+				/* 56 __NR_mpx obsolete */
+#define __NR_setpgid		 57
+				/* 58 __NR_ulimit obsolete */
+				/* 59 __NR_oldolduname obsolete */
+#define __NR_umask		 60
+#define __NR_chroot		 61
+#define __NR_ustat		 62
+#define __NR_dup2		 63
+#define __NR_getppid		 64
+#define __NR_getpgrp		 65
+#define __NR_setsid		 66
+				/* 67 __NR_sigaction obsolete */
+#define __NR_sgetmask		 68
+#define __NR_ssetmask		 69
+#define __NR_setreuid		 70
+#define __NR_setregid		 71
+				/* 72 __NR_sigsuspend obsolete */
+				/* 73 __NR_sigpending obsolete */
+#define __NR_sethostname	 74
+#define __NR_setrlimit		 75
+				/* 76 __NR_old_getrlimit obsolete */
+#define __NR_getrusage		 77
+#define __NR_gettimeofday	 78
+#define __NR_settimeofday	 79
+#define __NR_getgroups		 80
+#define __NR_setgroups		 81
+				/* 82 __NR_select obsolete */
+#define __NR_symlink		 83
+				/* 84 __NR_oldlstat obsolete */
+#define __NR_readlink		 85
+				/* 86 __NR_uselib obsolete */
+#define __NR_swapon		 87 /* obsolete but needed by generic allocator */
+#define __NR_reboot		 88
+				/* 89 __NR_readdir obsolete */
+				/* 90 __NR_mmap obsolete */
+#define __NR_munmap		 91
+#define __NR_truncate		 92
+#define __NR_ftruncate		 93
+#define __NR_fchmod		 94
+#define __NR_fchown		 95
+#define __NR_getpriority	 96
+#define __NR_setpriority	 97
+				/* 98 __NR_profil obsolete */
+#define __NR_statfs		 99
+#define __NR_fstatfs		100
+				/* 101 __NR_ioperm */
+				/* 102 __NR_socketcall obsolete */
+#define __NR_syslog		103
+#define __NR_setitimer		104
+#define __NR_getitimer		105
+#define __NR_stat		106
+#define __NR_lstat		107
+#define __NR_fstat		108
+				/* 109 __NR_olduname obsolete */
+				/* 110 __NR_iopl obsolete */
+#define __NR_vhangup		111
+				/* 112 __NR_idle obsolete */
+				/* 113 __NR_vm86old */
+#define __NR_wait4		114
+				/* 115 __NR_swapoff obsolete */
+#define __NR_sysinfo		116
+				/* 117 __NR_ipc oboslete */
+#define __NR_fsync		118
+#define __NR_sigreturn	119 
+#define __NR_clone		120
+#define __NR_setdomainname	121
+#define __NR_uname		122
+				/* 123 __NR_modify_ldt obsolete */
+#define __NR_adjtimex		124
+#define __NR_mprotect		125
+				/* 126 __NR_sigprocmask obsolete */
+				/* 127 __NR_create_module obsolete */
+#define __NR_init_module	128
+#define __NR_delete_module	129
+				/* 130 __NR_get_kernel_syms obsolete */
+#define __NR_quotactl		131
+#define __NR_getpgid		132
+#define __NR_fchdir		133
+#define __NR_bdflush		134
+				/* 135 was sysfs */
+#define __NR_personality	136
+				/* 137 __NR_afs_syscall */
+#define __NR_setfsuid		138
+#define __NR_setfsgid		139
+#define __NR__llseek		140
+#define __NR_getdents		141
+#define __NR__newselect         142
+#define __NR_flock		143
+				/* 144 __NR_msync obsolete */
+#define __NR_readv		145
+#define __NR_writev		146
+#define __NR_getsid		147
+#define __NR_fdatasync		148
+#define __NR__sysctl		149
+				/* 150 __NR_mlock */
+				/* 151 __NR_munlock */
+				/* 152 __NR_mlockall */
+				/* 153 __NR_munlockall */
+#define __NR_sched_setparam		154
+#define __NR_sched_getparam		155
+#define __NR_sched_setscheduler		156
+#define __NR_sched_getscheduler		157
+#define __NR_sched_yield		158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep		162
+				/* 163 __NR_mremap */
+#define __NR_setresuid		164
+#define __NR_getresuid		165
+				/* 166 __NR_vm86 */
+				/* 167 __NR_query_module */
+				/* 168 __NR_poll */
+				/* 169 __NR_nfsservctl */
+#define __NR_setresgid		170
+#define __NR_getresgid		171
+#define __NR_prctl		172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread		180
+#define __NR_pwrite		181
+#define __NR_lchown		182
+#define __NR_getcwd		183
+#define __NR_capget		184
+#define __NR_capset		185
+#define __NR_sigaltstack	186
+#define __NR_sendfile		187
+				/* 188 __NR_getpmsg */
+				/* 189 __NR_putpmsg */
+#define __NR_vfork		190
+#define __NR_getrlimit		191
+#define __NR_mmap2		192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_chown32		198
+#define __NR_getuid32		199
+#define __NR_getgid32		200
+#define __NR_geteuid32		201
+#define __NR_getegid32		202
+#define __NR_setreuid32		203
+#define __NR_setregid32		204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32		207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_lchown32		212
+#define __NR_setuid32		213
+#define __NR_setgid32		214
+#define __NR_setfsuid32		215
+#define __NR_setfsgid32		216
+#define __NR_pivot_root		217
+				/* 218 __NR_mincore */
+				/* 219 __NR_madvise */
+#define __NR_getdents64		220
+#define __NR_fcntl64		221
+				/* 222 reserved for TUX */
+				/* 223 reserved for TUX */
+#define __NR_gettid		224
+				/* 225 __NR_readahead */
+#define __NR_setxattr		226
+#define __NR_lsetxattr		227
+#define __NR_fsetxattr		228
+#define __NR_getxattr		229
+#define __NR_lgetxattr		230
+#define __NR_fgetxattr		231
+#define __NR_listxattr		232
+#define __NR_llistxattr		233
+#define __NR_flistxattr		234
+#define __NR_removexattr	235
+#define __NR_lremovexattr	236
+#define __NR_fremovexattr	237
+#define __NR_tkill		238
+#define __NR_sendfile64		239
+#define __NR_futex		240
+#define __NR_sched_setaffinity	241
+#define __NR_sched_getaffinity	242
+				/* 243 __NR_set_thread_area */
+				/* 244 __NR_get_thread_area */
+#define __NR_io_setup		245
+#define __NR_io_destroy		246
+#define __NR_io_getevents	247
+#define __NR_io_submit		248
+#define __NR_io_cancel		249
+				/* 250 __NR_alloc_hugepages */
+				/* 251 __NR_free_hugepages */
+#define __NR_exit_group		252
+#define __NR_lookup_dcookie     253
+				/* 254 spinlock (on bfin) */
+#define __NR_epoll_create	255
+#define __NR_epoll_ctl		256
+#define __NR_epoll_wait		257
+				/* 258 __NR_remap_file_pages */
+#define __NR_set_tid_address	259
+#define __NR_timer_create	260
+#define __NR_timer_settime	(__NR_timer_create+1)
+#define __NR_timer_gettime	(__NR_timer_create+2)
+#define __NR_timer_getoverrun	(__NR_timer_create+3)
+#define __NR_timer_delete	(__NR_timer_create+4)
+#define __NR_clock_settime	(__NR_timer_create+5)
+#define __NR_clock_gettime	(__NR_timer_create+6)
+#define __NR_clock_getres	(__NR_timer_create+7)
+#define __NR_clock_nanosleep	(__NR_timer_create+8)
+#define __NR_statfs64		269
+#define __NR_fstatfs64		270
+#define __NR_tgkill		271
+#define __NR_utimes		272
+#define __NR_fadvise64_64	273
+				/* 274 __NR_vserver */
+				/* 275 __NR_mbind */
+				/* 276 __NR_get_mempolicy */
+				/* 277 __NR_set_mempolicy */
+#define __NR_mq_open 		278
+#define __NR_mq_unlink		(__NR_mq_open+1)
+#define __NR_mq_timedsend	(__NR_mq_open+2)
+#define __NR_mq_timedreceive	(__NR_mq_open+3)
+#define __NR_mq_notify		(__NR_mq_open+4)
+#define __NR_mq_getsetattr	(__NR_mq_open+5)
+				/* 284 __NR_sys_kexec_load */
+#define __NR_waitid		285
+#define __NR_add_key		286
+#define __NR_request_key	287
+#define __NR_keyctl		288
+#define __NR_ioprio_set		289
+#define __NR_ioprio_get		290
+#define __NR_inotify_init	291
+#define __NR_inotify_add_watch	292
+#define __NR_inotify_rm_watch	293
+				/* 294 __NR_migrate_pages */
+#define __NR_openat		295
+#define __NR_mkdirat		296
+#define __NR_mknodat		297
+#define __NR_fchownat		298
+#define __NR_futimesat		299
+#define __NR_fstatat64		300
+#define __NR_unlinkat		301
+#define __NR_renameat		302
+#define __NR_linkat		303
+#define __NR_symlinkat		304
+#define __NR_readlinkat		305
+#define __NR_fchmodat		306
+#define __NR_faccessat		307
+#define __NR_pselect6		308
+#define __NR_ppoll		309
+#define __NR_unshare		310
+
+/* private syscalls (not implemented) */
+#define __NR_sram_alloc		311
+#define __NR_sram_free		312
+#define __NR_dma_memcpy		313
+
+/* socket syscalls */
+#define __NR_accept		314
+#define __NR_bind		315
+#define __NR_connect		316
+#define __NR_getpeername	317
+#define __NR_getsockname	318
+#define __NR_getsockopt		319
+#define __NR_listen		320
+#define __NR_recv		321
+#define __NR_recvfrom		322
+#define __NR_recvmsg		323
+#define __NR_send		324
+#define __NR_sendmsg		325
+#define __NR_sendto		326
+#define __NR_setsockopt		327
+#define __NR_shutdown		328
+#define __NR_socket		329
+#define __NR_socketpair		330
+
+#define __NR_splice	331
+#define __NR_sync_file_range2	332
+#define __NR_tee	333
+#define __NR_vmsplice	334
+#define __NR_getcpu	335
+
+/* sysv ipc syscalls */
+#define __NR_semctl		336
+#define __NR_semget		337
+#define __NR_semop		338
+#define __NR_msgctl		339
+#define __NR_msgget		340
+#define __NR_msgrcv		341
+#define __NR_msgsnd		342
+#define __NR_shmat		343
+#define __NR_shmctl		344
+#define __NR_shmdt		345
+#define __NR_shmget		346
+#define __NR_semtimedop		348
+
+#define __NR_syscall		348
+#define NR_syscalls		__NR_syscall
+
+#ifdef __KERNEL__
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_SGETMASK
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#define __ARCH_WANT_SYS_SIGNAL
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#define cond_syscall(x) asm(".weak\t_" #x "\n\t.set\t_" #x ",_sys_ni_syscall");
+
+#endif	/* __KERNEL__ */
+
+#endif
diff --git a/include/asm-lm32/user.h b/include/asm-lm32/user.h
new file mode 100644
index 0000000..b33141b
--- /dev/null
+++ b/include/asm-lm32/user.h
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2007
+ *     Theobroma Systems <www.theobroma-systems.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LM32_ASM_USER_H
+#define _LM32_ASM_USER_H
+
+#include <asm/page.h>
+#include <asm/registers.h>
+
+/* When the kernel dumps core, it starts by dumping the user struct -
+   this will be used by gdb to figure out where the data and stack segments
+   are within the file, and what virtual addresses to use. */
+struct user{
+	/* We start with the registers, to mimic the way that "memory" is returned
+   from the ptrace(3,...) function.  */
+  struct user_context context;	/* Where the registers are actually stored */
+	/* The rest of this junk is to help gdb figure out what goes where */
+  unsigned long int u_tsize;	/* Text segment size (pages). */
+  unsigned long int u_dsize;	/* Data segment size (pages). */
+  unsigned long int u_ssize;	/* Stack segment size (pages). */
+  unsigned long start_code;     /* Starting virtual address of text. */
+  unsigned long start_stack;	/* Starting virtual address of stack area.
+				   This is actually the bottom of the stack,
+				   the top of the stack is always found in the
+				   esp register.  */
+  long int signal;     		/* Signal that caused the core dump. */
+  unsigned long magic;		/* To uniquely identify a core file */
+  char u_comm[32];		/* User command that was responsible */
+};
+
+#define NBPG PAGE_SIZE
+#define UPAGES 1
+#define HOST_TEXT_START_ADDR (u.start_code)
+#define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
+
+#endif
diff --git a/include/linux/elf-em.h b/include/linux/elf-em.h
index 5834e84..6b9d724 100644
--- a/include/linux/elf-em.h
+++ b/include/linux/elf-em.h
@@ -32,6 +32,7 @@
 #define EM_M32R		88	/* Renesas M32R */
 #define EM_H8_300	46	/* Renesas H8/300,300H,H8S */
 #define EM_BLACKFIN     106     /* ADI Blackfin Processor */
+#define EM_LM32         138     /* Lattice Mico32 */
 #define EM_FRV		0x5441	/* Fujitsu FR-V */
 #define EM_AVR32	0x18ad	/* Atmel AVR32 */
 
diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 81f3a31..875af58 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -362,10 +362,21 @@ static inline map_word map_word_ff(struct map_info *map)
 	return r;
 }
 
+#ifdef CONFIG_LM32
+/* flush all caches */
+static inline void lm32_flush_caches(void) {
+	asm volatile("wcsr DCC, r0");
+	asm volatile("wcsr ICC, r0");
+}
+#endif
+
 static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 {
 	map_word r;
 
+#ifdef CONFIG_LM32
+	lm32_flush_caches();
+#endif
 	if (map_bankwidth_is_1(map))
 		r.x[0] = __raw_readb(map->virt + ofs);
 	else if (map_bankwidth_is_2(map))
@@ -397,6 +408,9 @@ static inline void inline_map_write(struct map_info *map, const map_word datum,
 	else if (map_bankwidth_is_large(map))
 		memcpy_toio(map->virt+ofs, datum.x, map->bankwidth);
 	mb();
+#ifdef CONFIG_LM32
+	lm32_flush_caches();
+#endif
 }
 
 static inline void inline_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 09d17b0..694df21 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -146,6 +146,9 @@
 /* Broadcom SB1250, etc. SOC */
 #define PORT_SB1250_DUART	77
 
+/* Milkymist UART */
+#define PORT_MILKYMISTUART	78
+
 
 #ifdef __KERNEL__
 
diff --git a/init/Kconfig b/init/Kconfig
index d54d0ca..93ed2d8 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -64,6 +64,7 @@ config INIT_ENV_ARG_LIMIT
 
 config LOCALVERSION
 	string "Local version - append to kernel release"
+	default "-milkymist"
 	help
 	  Append an extra string to the end of your kernel version.
 	  This will show up when you type uname, for example.
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 0f546dd..1b6ba7e 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -135,10 +135,8 @@ void local_bh_enable(void)
 	unsigned long flags;
 
 	WARN_ON_ONCE(in_irq());
-#endif
 	WARN_ON_ONCE(irqs_disabled());
 
-#ifdef CONFIG_TRACE_IRQFLAGS
 	local_irq_save(flags);
 #endif
 	/*
diff --git a/mm/memory.c b/mm/memory.c
index f82b359..c28fa69 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -50,6 +50,7 @@
 #include <linux/delayacct.h>
 #include <linux/init.h>
 #include <linux/writeback.h>
+#include <linux/vmalloc.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -416,6 +417,34 @@ struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr, pte_
 	return pfn_to_page(pfn);
 }
 
+static inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)
+{
+	/*
+	 * If the source page was a PFN mapping, we don't have
+	 * a "struct page" for it. We do a best-effort copy by
+	 * just copying from the original user address. If that
+	 * fails, we just zero-fill it. Live with it.
+	 */
+	if (unlikely(!src)) {
+		void *kaddr = kmap_atomic(dst, KM_USER0);
+		void __user *uaddr = (void __user *)(va & PAGE_MASK);
+
+		/*
+		 * This really shouldn't fail, because the page is there
+		 * in the page tables. But it might just be unreadable,
+		 * in which case we just give up and fill the result with
+		 * zeroes.
+		 */
+		if (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))
+			memset(kaddr, 0, PAGE_SIZE);
+		kunmap_atomic(kaddr, KM_USER0);
+		flush_dcache_page(dst);
+		return;
+		
+	}
+	copy_user_highpage(dst, src, va, vma);
+}
+
 /*
  * copy one vm_area from one task to the other. Assumes the page tables
  * already present in the new task to be cleared in the whole range
@@ -424,8 +453,8 @@ struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr, pte_
 
 static inline void
 copy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,
-		pte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,
-		unsigned long addr, int *rss)
+	     pte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,
+	     unsigned long addr, int *rss, struct page *uncow_page)
 {
 	unsigned long vm_flags = vma->vm_flags;
 	pte_t pte = *src_pte;
@@ -494,13 +523,16 @@ static int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,
 	pte_t *src_pte, *dst_pte;
 	spinlock_t *src_ptl, *dst_ptl;
 	int progress = 0;
+	struct page *uncow_page = NULL;
 	int rss[2];
-
 again:
 	rss[1] = rss[0] = 0;
 	dst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);
-	if (!dst_pte)
+	if (!dst_pte) {
+		if (uncow_page)
+			page_cache_release(uncow_page);
 		return -ENOMEM;
+	}
 	src_pte = pte_offset_map_nested(src_pmd, addr);
 	src_ptl = pte_lockptr(src_mm, src_pmd);
 	spin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);
@@ -522,7 +554,9 @@ again:
 			progress++;
 			continue;
 		}
-		copy_one_pte(dst_mm, src_mm, dst_pte, src_pte, vma, addr, rss);
+		copy_one_pte(dst_mm, src_mm, dst_pte,
+			     src_pte, vma, addr, rss, uncow_page);
+		uncow_page = NULL;
 		progress += 8;
 	} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);
 
@@ -1586,34 +1620,6 @@ static inline pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
 	return pte;
 }
 
-static inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)
-{
-	/*
-	 * If the source page was a PFN mapping, we don't have
-	 * a "struct page" for it. We do a best-effort copy by
-	 * just copying from the original user address. If that
-	 * fails, we just zero-fill it. Live with it.
-	 */
-	if (unlikely(!src)) {
-		void *kaddr = kmap_atomic(dst, KM_USER0);
-		void __user *uaddr = (void __user *)(va & PAGE_MASK);
-
-		/*
-		 * This really shouldn't fail, because the page is there
-		 * in the page tables. But it might just be unreadable,
-		 * in which case we just give up and fill the result with
-		 * zeroes.
-		 */
-		if (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))
-			memset(kaddr, 0, PAGE_SIZE);
-		kunmap_atomic(kaddr, KM_USER0);
-		flush_dcache_page(dst);
-		return;
-
-	}
-	copy_user_highpage(dst, src, va, vma);
-}
-
 /*
  * This routine handles present pages, when users try to write
  * to a shared page. It is done by copying the page to a new address
diff --git a/net/socket.c b/net/socket.c
index b09eb90..51eae26 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -1645,6 +1645,10 @@ asmlinkage long sys_recvfrom(int fd, void __user *ubuf, size_t size,
 	if (!sock)
 		goto out_put;
 
+	err = -EFAULT;
+	if( unlikely(!access_ok(VERIFY_WRITE, ubuf, size)) )
+		goto out_put;
+
 	msg.msg_control = NULL;
 	msg.msg_controllen = 0;
 	msg.msg_iovlen = 1;
diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 1f11d84..779710b 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -31,6 +31,19 @@
 
 #define KSYM_NAME_LEN		128
 
+// FIXME memmem is not standard!
+#ifndef memmem
+void *memmem(const void* haystack, size_t hl, const void* needle, size_t nl) {
+  int i;
+  if (nl>hl) return 0;
+  for (i=hl-nl+1; i; --i) {
+    if (!memcmp(haystack,needle,nl))
+      return (char*)haystack;
+    ++haystack;
+  }
+  return 0;
+}
+#endif
 
 struct sym_entry {
 	unsigned long long addr;
diff --git a/scripts/unifdef.c b/scripts/unifdef.c
index 552025e..05a31a6 100644
--- a/scripts/unifdef.c
+++ b/scripts/unifdef.c
@@ -206,7 +206,7 @@ static void             done(void);
 static void             error(const char *);
 static int              findsym(const char *);
 static void             flushline(bool);
-static Linetype         getline(void);
+static Linetype         get_line(void);
 static Linetype         ifeval(const char **);
 static void             ignoreoff(void);
 static void             ignoreon(void);
@@ -512,7 +512,7 @@ process(void)
 
 	for (;;) {
 		linenum++;
-		lineval = getline();
+		lineval = get_line();
 		trans_table[ifstate[depth]][lineval]();
 		debug("process %s -> %s depth %d",
 		    linetype_name[lineval],
@@ -526,7 +526,7 @@ process(void)
  * help from skipcomment().
  */
 static Linetype
-getline(void)
+get_line(void)
 {
 	const char *cp;
 	int cursym;

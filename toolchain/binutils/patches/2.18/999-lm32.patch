diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 1e4c82f..89b199f 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -83,6 +83,7 @@ ALL_MACHINES = \
 	cpu-i960.lo \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
+	cpu-lm32.lo \
 	cpu-m32c.lo \
 	cpu-m32r.lo \
 	cpu-m68hc11.lo \
@@ -149,6 +150,7 @@ ALL_MACHINES_CFILES = \
 	cpu-i960.c \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
+	cpu-lm32.c \
 	cpu-m32c.c \
 	cpu-m32r.c \
 	cpu-m68hc11.c \
@@ -262,6 +264,7 @@ BFD32_BACKENDS = \
 	elf32-i960.lo \
 	elf32-ip2k.lo \
 	elf32-iq2000.lo \
+	elf32-lm32.lo \
 	elf32-m32c.lo \
 	elf32-m32r.lo \
 	elf32-m68hc11.lo \
@@ -441,6 +444,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-i960.c \
 	elf32-ip2k.c \
 	elf32-iq2000.c \
+	elf32-lm32.c \
 	elf32-m32c.c \
 	elf32-m32r.c \
 	elf32-m68k.c \
@@ -1080,6 +1084,7 @@ cpu-i860.lo: cpu-i860.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-i960.lo: cpu-i960.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-ip2k.lo: cpu-ip2k.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-iq2000.lo: cpu-iq2000.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
+cpu-lm32.lo: cpu-lm32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m32c.lo: cpu-m32c.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m32r.lo: cpu-m32r.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m68hc11.lo: cpu-m68hc11.c $(INCDIR)/filenames.h \
@@ -1403,6 +1408,10 @@ elf32-m32c.lo: elf32-m32c.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/m32c.h \
   $(INCDIR)/elf/reloc-macros.h $(INCDIR)/libiberty.h \
   elf32-target.h
+elf32-lm32.lo: elf32-lm32.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/lm32.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-m32r.lo: elf32-m32r.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/m32r.h \
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 1436aac..5533403 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -332,6 +332,7 @@ ALL_MACHINES = \
 	cpu-i960.lo \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
+	cpu-lm32.lo \
 	cpu-m32c.lo \
 	cpu-m32r.lo \
 	cpu-m68hc11.lo \
@@ -398,6 +399,7 @@ ALL_MACHINES_CFILES = \
 	cpu-i960.c \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
+	cpu-lm32.c \
 	cpu-m32c.c \
 	cpu-m32r.c \
 	cpu-m68hc11.c \
@@ -512,6 +514,7 @@ BFD32_BACKENDS = \
 	elf32-i960.lo \
 	elf32-ip2k.lo \
 	elf32-iq2000.lo \
+	elf32-lm32.lo \
 	elf32-m32c.lo \
 	elf32-m32r.lo \
 	elf32-m68hc11.lo \
@@ -691,6 +694,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-i960.c \
 	elf32-ip2k.c \
 	elf32-iq2000.c \
+	elf32-lm32.c \
 	elf32-m32c.c \
 	elf32-m32r.c \
 	elf32-m68k.c \
@@ -1660,6 +1664,7 @@ cpu-i860.lo: cpu-i860.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-i960.lo: cpu-i960.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-ip2k.lo: cpu-ip2k.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-iq2000.lo: cpu-iq2000.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
+cpu-lm32.lo: cpu-lm32.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m32c.lo: cpu-m32c.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m32r.lo: cpu-m32r.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m68hc11.lo: cpu-m68hc11.c $(INCDIR)/filenames.h \
@@ -1978,6 +1983,10 @@ elf32-iq2000.lo: elf32-iq2000.c $(INCDIR)/filenames.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
   $(INCDIR)/elf/iq2000.h $(INCDIR)/elf/reloc-macros.h \
   elf32-target.h
+elf32-lm32.lo: elf32-lm32.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/lm32.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-m32c.lo: elf32-m32c.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/m32c.h \
diff --git a/bfd/archures.c b/bfd/archures.c
index 67d1b5c..7b8505c 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -391,6 +391,8 @@ DESCRIPTION
 .   bfd_arch_maxq,     {* Dallas MAXQ 10/20 *}
 .#define bfd_mach_maxq10    10
 .#define bfd_mach_maxq20    20
+.  bfd_arch_lm32,      {* LatticeMico32 *}
+.#define bfd_mach_lm32      1
 .  bfd_arch_z80,
 .#define bfd_mach_z80strict      1 {* No undocumented opcodes.  *}
 .#define bfd_mach_z80            3 {* With ixl, ixh, iyl, and iyh.  *}
@@ -458,6 +460,7 @@ extern const bfd_arch_info_type bfd_i960_arch;
 extern const bfd_arch_info_type bfd_ia64_arch;
 extern const bfd_arch_info_type bfd_ip2k_arch;
 extern const bfd_arch_info_type bfd_iq2000_arch;
+extern const bfd_arch_info_type bfd_lm32_arch;
 extern const bfd_arch_info_type bfd_m32c_arch;
 extern const bfd_arch_info_type bfd_m32r_arch;
 extern const bfd_arch_info_type bfd_m68hc11_arch;
@@ -529,6 +532,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_ia64_arch,
     &bfd_ip2k_arch,
     &bfd_iq2000_arch,
+    &bfd_lm32_arch,
     &bfd_m32c_arch,
     &bfd_m32r_arch,
     &bfd_m68hc11_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 317d32e..d3ac16f 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -2062,6 +2062,8 @@ enum bfd_architecture
    bfd_arch_maxq,     /* Dallas MAXQ 10/20 */
 #define bfd_mach_maxq10    10
 #define bfd_mach_maxq20    20
+  bfd_arch_lm32,      /* LatticeMico32 */
+#define bfd_mach_lm32      1
   bfd_arch_z80,
 #define bfd_mach_z80strict      1 /* No undocumented opcodes.  */
 #define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
@@ -4380,7 +4382,16 @@ assembler-expanded instructions.  This is commonly used
 internally by the linker after analysis of a
 BFD_RELOC_XTENSA_ASM_EXPAND.  */
   BFD_RELOC_XTENSA_ASM_SIMPLIFY,
-
+  
+/* LatticeMico32 relocations. */
+  BFD_RELOC_LM32_CALL,
+  BFD_RELOC_LM32_BRANCH,
+  BFD_RELOC_LM32_16_GOT,
+  BFD_RELOC_LM32_COPY,
+  BFD_RELOC_LM32_GLOB_DAT,
+  BFD_RELOC_LM32_JMP_SLOT,
+  BFD_RELOC_LM32_RELATIVE,
+  
 /* 8 bit signed offset in (ix+d) or (iy+d).  */
   BFD_RELOC_Z80_DISP8,
 
@@ -4392,6 +4403,7 @@ BFD_RELOC_XTENSA_ASM_EXPAND.  */
 
 /* 4 bit value.  */
   BFD_RELOC_Z8K_IMM4L,
+
   BFD_RELOC_UNUSED };
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
 reloc_howto_type *bfd_reloc_type_lookup
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 198dfe4..da6dcf5 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -84,6 +84,7 @@ fido*)		 targ_archs=bfd_m68k_arch ;;
 hppa*)		 targ_archs=bfd_hppa_arch ;;
 i[3-7]86)	 targ_archs=bfd_i386_arch ;;
 i370)		 targ_archs=bfd_i370_arch ;;
+lm32)	         targ_archs=bfd_lm32_arch ;;
 m6811*|m68hc11*) targ_archs="bfd_m68hc11_arch bfd_m68hc12_arch" ;;
 m6812*|m68hc12*) targ_archs="bfd_m68hc12_arch bfd_m68hc11_arch" ;;
 m68*)		 targ_archs=bfd_m68k_arch ;;
@@ -703,6 +704,10 @@ case "${targ}" in
     targ_defvec=bfd_elf32_iq2000_vec
     ;;
 
+  lm32-*-*)
+    targ_defvec=bfd_elf32_lm32_vec
+    ;;
+    
   m32c-*-elf)
     targ_defvec=bfd_elf32_m32c_vec
     ;;
diff --git a/bfd/configure b/bfd/configure
index f5a6739..9eeaeab 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -19080,6 +19080,7 @@ do
     bfd_elf32_ia64_hpux_big_vec) tb="$tb elf32-ia64.lo elf32.lo $elf";;
     bfd_elf32_ip2k_vec)		tb="$tb elf32-ip2k.lo elf32.lo $elf" ;;
     bfd_elf32_iq2000_vec)       tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
+    bfd_elf32_lm32_vec)         tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     bfd_elf32_little_generic_vec) tb="$tb elf32-gen.lo elf32.lo $elf" ;;
     bfd_elf32_littlearc_vec)	tb="$tb elf32-arc.lo elf32.lo $elf" ;;
     bfd_elf32_littlearm_symbian_vec)
diff --git a/bfd/configure.in b/bfd/configure.in
index 4c3523c..72b962c 100644
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -658,6 +658,7 @@ do
     bfd_elf32_ia64_hpux_big_vec) tb="$tb elf32-ia64.lo elf32.lo $elf";;
     bfd_elf32_ip2k_vec)		tb="$tb elf32-ip2k.lo elf32.lo $elf" ;;
     bfd_elf32_iq2000_vec)       tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
+    bfd_elf32_lm32_vec)         tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     bfd_elf32_little_generic_vec) tb="$tb elf32-gen.lo elf32.lo $elf" ;;
     bfd_elf32_littlearc_vec)	tb="$tb elf32-arc.lo elf32.lo $elf" ;;
     bfd_elf32_littlearm_symbian_vec)
diff --git a/bfd/cpu-lm32.c b/bfd/cpu-lm32.c
new file mode 100644
index 0000000..2299cf4
--- /dev/null
+++ b/bfd/cpu-lm32.c
@@ -0,0 +1,40 @@
+/* BFD support for the LatticeMico32 architecture.
+   Written by Jon Beniston <jon@beniston.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_lm32_arch = 
+{
+    32,                           /* bits in word */
+    32,                           /* bits in address */
+    8,                            /* bits in byte */
+    bfd_arch_lm32,                /* enum bfd_architecture */ 
+    bfd_mach_lm32,                /* machine number */
+    "lm32",                       /* architecture name */
+    "lm32",                       /* printable name */
+    4,                            /* alignment */
+    TRUE,                         /* is this the default machine for the target */
+    bfd_default_compatible,       /* function callback to test if two files have compatible machines */
+    bfd_default_scan,
+    NULL                          /* next */
+};
+
diff --git a/bfd/elf32-lm32.c b/bfd/elf32-lm32.c
new file mode 100644
index 0000000..2411e78
--- /dev/null
+++ b/bfd/elf32-lm32.c
@@ -0,0 +1,2511 @@
+/* LatticeMico32-specific support for 32-bit ELF
+   Contributed by Jon Beniston <jon@beniston.com>
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/lm32.h"
+
+#define PLT_ENTRY_SIZE 20
+
+#define PLT0_ENTRY_WORD0  0
+#define PLT0_ENTRY_WORD1  0
+#define PLT0_ENTRY_WORD2  0
+#define PLT0_ENTRY_WORD3  0
+#define PLT0_ENTRY_WORD4  0
+
+#define PLT0_PIC_ENTRY_WORD0  0
+#define PLT0_PIC_ENTRY_WORD1  0
+#define PLT0_PIC_ENTRY_WORD2  0
+#define PLT0_PIC_ENTRY_WORD3  0
+#define PLT0_PIC_ENTRY_WORD4  0
+
+#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
+
+#define DEFAULT_STACK_SIZE 0x20000
+
+static bfd_reloc_status_type lm32_elf_gprel_reloc
+  PARAMS ((bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **));
+
+static bfd_boolean lm32_elf_relocate_section
+  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+        Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
+
+static reloc_howto_type *lm32_reloc_type_lookup
+  PARAMS ((bfd * abfd, bfd_reloc_code_real_type code));
+
+static void lm32_info_to_howto_rela
+  PARAMS ((bfd * abfd, arelent * cache_ptr, Elf_Internal_Rela * dst));
+
+static bfd_boolean lm32_elf_object_p
+  PARAMS ((bfd * abfd));
+
+static void lm32_elf_final_write_processing
+  PARAMS ((bfd *abfd, bfd_boolean linker));
+
+static asection * lm32_elf_gc_mark_hook
+  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
+	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
+
+static bfd_boolean lm32_elf_gc_sweep_hook
+  PARAMS ((bfd *, struct bfd_link_info *, asection *,
+           const Elf_Internal_Rela *));
+           
+static bfd_boolean lm32_elf_check_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, asection *,
+	   const Elf_Internal_Rela *));
+
+static bfd_boolean lm32_elf_finish_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+static bfd_boolean lm32_elf_finish_dynamic_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+	   Elf_Internal_Sym *));
+
+static bfd_boolean lm32_elf_size_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+static bfd_boolean create_got_section 
+  PARAMS ((bfd *dynobj, struct bfd_link_info *info));
+
+
+/* The linker needs to keep track of the number of relocs that it
+   decides to copy as dynamic relocs in check_relocs for each symbol.
+   This is so that it can later discard them if they are found to be
+   unnecessary.  We store the information in a field extending the
+   regular ELF linker hash table.  */
+
+struct elf_lm32_dyn_relocs
+{
+  struct elf_lm32_dyn_relocs *next;
+
+  /* The input section of the reloc.  */
+  asection *sec;
+
+  /* Total number of relocs copied for the input section.  */
+  bfd_size_type count;
+
+  /* Number of pc-relative relocs copied for the input section.  */
+  bfd_size_type pc_count;
+};
+
+/* lm32 ELF linker hash entry.  */
+
+struct elf_lm32_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_lm32_dyn_relocs *dyn_relocs;
+};
+
+/* lm32 ELF linker hash table.  */
+
+struct elf_lm32_link_hash_table
+{
+  struct elf_link_hash_table root;
+
+  /* Short-cuts to get to dynamic linker sections.  */
+  asection *sgot;
+  asection *sgotplt;
+  asection *srelgot;
+  asection *splt;
+  asection *srelplt;
+  asection *sdynbss;
+  asection *srelbss;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_sec_cache sym_sec;
+};
+
+/* Get the lm32 ELF linker hash table from a link_info structure.  */
+
+#define lm32_elf_hash_table(p) \
+  ((struct elf_lm32_link_hash_table *) ((p)->hash))
+
+/* Create an entry in an lm32 ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+lm32_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
+			    struct bfd_hash_table *table,
+			    const char *string)
+{
+  struct elf_lm32_link_hash_entry *ret =
+    (struct elf_lm32_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = bfd_hash_allocate (table,
+			     sizeof (struct elf_lm32_link_hash_entry));
+  if (ret == NULL)
+    return NULL;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_lm32_link_hash_entry *)
+         _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+                                     table, string));
+  if (ret != NULL)
+    {
+      struct elf_lm32_link_hash_entry *eh;
+
+      eh = (struct elf_lm32_link_hash_entry *) ret;
+      eh->dyn_relocs = NULL;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Create an lm32 ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+lm32_elf_link_hash_table_create (bfd *abfd)
+{
+  struct elf_lm32_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct elf_lm32_link_hash_table);
+
+  ret = bfd_malloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      lm32_elf_link_hash_newfunc,
+				      sizeof (struct elf_lm32_link_hash_entry)))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  ret->sgot = NULL;
+  ret->sgotplt = NULL;
+  ret->srelgot = NULL;
+  ret->splt = NULL;
+  ret->srelplt = NULL;
+  ret->sdynbss = NULL;
+  ret->srelbss = NULL;
+  ret->sym_sec.abfd = NULL;
+
+  return &ret->root.root;
+}
+
+/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
+   shortcuts to them in our hash table.  */
+
+static bfd_boolean
+create_got_section (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_lm32_link_hash_table *htab;
+
+  if (! _bfd_elf_create_got_section (dynobj, info))
+    return FALSE;
+
+  htab = lm32_elf_hash_table (info);
+  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
+  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
+  if (! htab->sgot || ! htab->sgotplt)
+    abort ();
+
+  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
+					       (SEC_ALLOC
+						| SEC_LOAD
+						| SEC_HAS_CONTENTS
+						| SEC_IN_MEMORY
+						| SEC_LINKER_CREATED
+						| SEC_READONLY));
+  if (htab->srelgot == NULL
+      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
+    return FALSE;
+
+  return TRUE;
+}
+
+
+static reloc_howto_type lm32_elf_howto_table [] =
+{
+
+  /* This reloc does nothing.  */
+  HOWTO (R_LM32_NONE,               /* type */
+         0,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         32,                        /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_bitfield,/* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_NONE",             /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0,                         /* dst_mask */
+         FALSE),                    /* pcrel_offset */
+
+  /* An 8 bit absolute relocation.  */
+  HOWTO (R_LM32_8,                  /* type */
+         0,                         /* rightshift */
+         0,                         /* size (0 = byte, 1 = short, 2 = long) */
+         8,                         /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_bitfield,/* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_8",                /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xff,                      /* dst_mask */
+         FALSE),                    /* pcrel_offset */
+
+  /* A 16 bit absolute relocation.  */
+  HOWTO (R_LM32_16,                 /* type */
+         0,                         /* rightshift */
+         1,                         /* size (0 = byte, 1 = short, 2 = long) */
+         16,                        /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_bitfield,/* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_16",               /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xffff,                    /* dst_mask */
+         FALSE),                    /* pcrel_offset */
+
+  /* A 32 bit absolute relocation.  */
+  HOWTO (R_LM32_32,                 /* type */
+         0,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         32,                        /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_bitfield,/* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_32",               /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xffffffff,                /* dst_mask */
+         FALSE),                    /* pcrel_offset */
+
+  HOWTO (R_LM32_HI16,               /* type */
+         16,                        /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         16,                        /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_bitfield,/* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_HI16",             /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xffff,                    /* dst_mask */
+         FALSE),                    /* pcrel_offset */
+                                    
+  HOWTO (R_LM32_LO16,               /* type */
+         0,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         16,                        /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_dont,    /* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_LO16",             /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xffff,                    /* dst_mask */
+         FALSE),                    /* pcrel_offset */
+                                                    
+  HOWTO (R_LM32_GPREL16,            /* type */
+         0,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         16,                        /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_dont,    /* complain_on_overflow */
+         lm32_elf_gprel_reloc,      /* special_function */
+         "R_LM32_GPREL16",          /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xffff,                    /* dst_mask */
+         FALSE),                    /* pcrel_offset */                   
+
+  HOWTO (R_LM32_CALL,               /* type */
+         2,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         26,                        /* bitsize */
+         TRUE,                      /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_signed,  /* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_CALL",             /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0x3ffffff,                 /* dst_mask */
+         TRUE),                     /* pcrel_offset */
+         
+  HOWTO (R_LM32_BRANCH,             /* type */
+         2,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         16,                        /* bitsize */
+         TRUE,                      /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_signed,  /* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_BRANCH",           /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xffff,                    /* dst_mask */
+         TRUE),                     /* pcrel_offset */
+
+  /* GNU extension to record C++ vtable hierarchy.  */
+  HOWTO (R_LM32_GNU_VTINHERIT,      /* type */
+         0,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         0,                         /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_dont,    /* complain_on_overflow */
+         NULL,                      /* special_function */
+         "R_LM32_GNU_VTINHERIT",    /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0,                         /* dst_mask */
+         FALSE),                    /* pcrel_offset */
+
+  /* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_LM32_GNU_VTENTRY,        /* type */
+         0,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         0,                         /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_dont,    /* complain_on_overflow */
+         _bfd_elf_rel_vtable_reloc_fn,/* special_function */
+         "R_LM32_GNU_VTENTRY",      /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0,                         /* dst_mask */
+         FALSE),                    /* pcrel_offset */             
+
+  HOWTO (R_LM32_16_GOT,             /* type */
+         0,                         /* rightshift */
+         2,                         /* size (0 = byte, 1 = short, 2 = long) */
+         16,                        /* bitsize */
+         FALSE,                     /* pc_relative */
+         0,                         /* bitpos */
+         complain_overflow_dont,    /* complain_on_overflow */
+         bfd_elf_generic_reloc,     /* special_function */
+         "R_LM32_16_GOT",           /* name */
+         FALSE,                     /* partial_inplace */
+         0,                         /* src_mask */
+         0xffff,                    /* dst_mask */
+         FALSE),                    /* pcrel_offset */                   
+
+  HOWTO (R_LM32_COPY,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LM32_COPY",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_LM32_GLOB_DAT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LM32_GLOB_DAT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_LM32_JMP_SLOT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LM32_JMP_SLOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_LM32_RELATIVE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LM32_RELATIVE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+                                 
+};
+
+/* Map BFD reloc types to lm32 ELF reloc types. */
+
+struct lm32_reloc_map
+{
+    bfd_reloc_code_real_type bfd_reloc_val;
+    unsigned char elf_reloc_val;
+};
+
+static const struct lm32_reloc_map lm32_reloc_map[] =
+{
+  { BFD_RELOC_NONE,             R_LM32_NONE },
+  { BFD_RELOC_8,                R_LM32_8 },
+  { BFD_RELOC_16,               R_LM32_16 },
+  { BFD_RELOC_32,               R_LM32_32 },
+  { BFD_RELOC_HI16,             R_LM32_HI16 },
+  { BFD_RELOC_LO16,             R_LM32_LO16 },  
+  { BFD_RELOC_GPREL16,          R_LM32_GPREL16 },
+  { BFD_RELOC_LM32_CALL,        R_LM32_CALL },
+  { BFD_RELOC_LM32_BRANCH,      R_LM32_BRANCH },
+  { BFD_RELOC_VTABLE_INHERIT,   R_LM32_GNU_VTINHERIT },
+  { BFD_RELOC_VTABLE_ENTRY,     R_LM32_GNU_VTENTRY },
+  { BFD_RELOC_LM32_16_GOT,      R_LM32_16_GOT },
+  { BFD_RELOC_LM32_COPY,        R_LM32_COPY },
+  { BFD_RELOC_LM32_GLOB_DAT,    R_LM32_GLOB_DAT },
+  { BFD_RELOC_LM32_JMP_SLOT,    R_LM32_JMP_SLOT },
+  { BFD_RELOC_LM32_RELATIVE,    R_LM32_RELATIVE },
+};
+
+static reloc_howto_type *
+lm32_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED, 
+                        bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (lm32_reloc_map) / sizeof (lm32_reloc_map[0]); i++)
+    if (lm32_reloc_map[i].bfd_reloc_val == code)
+      return &lm32_elf_howto_table[lm32_reloc_map[i].elf_reloc_val];
+  return NULL;
+}
+
+static reloc_howto_type *
+lm32_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (lm32_elf_howto_table) / sizeof (lm32_elf_howto_table[0]);
+       i++)
+    if (lm32_elf_howto_table[i].name != NULL
+	&& strcasecmp (lm32_elf_howto_table[i].name, r_name) == 0)
+      return &lm32_elf_howto_table[i];
+
+  return NULL;
+}
+
+
+/* Set the howto pointer for an LatticeMico32 ELF reloc.  */
+
+static void
+lm32_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED, 
+                         arelent *cache_ptr, 
+                         Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_LM32_max);
+  cache_ptr->howto = &lm32_elf_howto_table[r_type];
+}
+
+/* Set the right machine number for an LatticeMico32 ELF file. */
+
+static bfd_boolean
+lm32_elf_object_p (bfd *abfd)
+{
+  return bfd_default_set_arch_mach (abfd, bfd_arch_lm32, bfd_mach_lm32);
+}
+
+/* Set machine type flags just before file is written out. */
+
+static void
+lm32_elf_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  elf_elfheader (abfd)->e_machine = EM_LM32;
+  elf_elfheader (abfd)->e_flags &=~ EF_LM32_MACH;
+  switch (bfd_get_mach (abfd))
+    {
+      case bfd_mach_lm32:
+        elf_elfheader (abfd)->e_flags |= E_LM32_MACH;
+        break;
+      default:
+        abort ();        
+    }
+}
+
+/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
+   dangerous relocation.  */
+
+static bfd_boolean
+lm32_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
+{
+  unsigned int count;
+  asymbol **sym;
+  unsigned int i;
+
+  /* If we've already figured out what GP will be, just return it. */
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp)
+    return TRUE;
+
+  count = bfd_get_symcount (output_bfd);
+  sym = bfd_get_outsymbols (output_bfd);
+
+  /* The linker script will have created a symbol named `_gp' with the
+     appropriate value.  */
+  if (sym == NULL)
+    i = count;
+  else
+    {
+      for (i = 0; i < count; i++, sym++)
+	{
+	  register const char *name;
+
+	  name = bfd_asymbol_name (*sym);
+	  if (*name == '_' && strcmp (name, "_gp") == 0)
+	    {
+	      *pgp = bfd_asymbol_value (*sym);
+	      _bfd_set_gp_value (output_bfd, *pgp);
+	      break;
+	    }
+	}
+    }
+
+  if (i >= count)
+    {
+      /* Only get the error once.  */
+      *pgp = 4;
+      _bfd_set_gp_value (output_bfd, *pgp);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* We have to figure out the gp value, so that we can adjust the
+   symbol value correctly.  We look up the symbol _gp in the output
+   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
+   target data.  We don't need to adjust the symbol value for an
+   external symbol if we are producing relocatable output.  */
+
+static bfd_reloc_status_type
+lm32_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable, 
+                    char **error_message, bfd_vma *pgp)
+{
+  if (bfd_is_und_section (symbol->section) && !relocatable)
+    {
+      *pgp = 0;
+      return bfd_reloc_undefined;
+    }
+
+  *pgp = _bfd_get_gp_value (output_bfd);
+  if (*pgp == 0 && (!relocatable || (symbol->flags & BSF_SECTION_SYM) != 0))
+    {
+      if (relocatable)
+	{
+	  /* Make up a value.  */
+	  *pgp = symbol->section->output_section->vma + 0x4000;
+	  _bfd_set_gp_value (output_bfd, *pgp);
+	}
+      else if (!lm32_elf_assign_gp (output_bfd, pgp))
+	{
+	  *error_message =
+	    (char *)
+	    _("global pointer relative relocation when _gp not defined");
+	  return bfd_reloc_dangerous;
+	}
+    }
+
+  return bfd_reloc_ok;
+}
+
+static bfd_reloc_status_type
+lm32_elf_do_gprel_relocate (bfd *abfd, reloc_howto_type *howto,
+     asection *input_section ATTRIBUTE_UNUSED, bfd_byte *data,
+     bfd_vma offset, bfd_vma symbol_value, bfd_vma addend)
+{
+  return _bfd_final_link_relocate (howto, abfd, input_section,
+				   data, offset, symbol_value, addend);
+}
+
+static bfd_reloc_status_type
+lm32_elf_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+     void *data, asection *input_section, bfd *output_bfd, char **msg)
+{
+  bfd_vma relocation;
+  bfd_vma gp;
+  bfd_reloc_status_type r;
+
+  if (output_bfd != (bfd *) NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  if (output_bfd != NULL)
+    return bfd_reloc_ok;
+
+  relocation = symbol->value
+    + symbol->section->output_section->vma + symbol->section->output_offset;
+
+  if ((r =
+       lm32_elf_final_gp (abfd, symbol, FALSE, msg, &gp)) == bfd_reloc_ok)
+    {
+      relocation = relocation + reloc_entry->addend - gp;
+      reloc_entry->addend = 0;
+      if ((signed) relocation < -32768 || (signed) relocation > 32767)
+	{
+	  *msg = _("global pointer relative address out of range");
+	  r = bfd_reloc_outofrange;
+	}
+      else
+	{
+	  r = lm32_elf_do_gprel_relocate (abfd, reloc_entry->howto,
+					     input_section,
+					     data, reloc_entry->address,
+					     relocation, reloc_entry->addend);
+	}
+    }
+
+  return r;
+}
+
+/* Relocate a section */
+
+static bfd_boolean
+lm32_elf_relocate_section (bfd *output_bfd, 
+                           struct bfd_link_info *info, 
+                           bfd *input_bfd, 
+                           asection *input_section,
+                           bfd_byte *contents, 
+                           Elf_Internal_Rela *relocs, 
+                           Elf_Internal_Sym *local_syms, 
+                           asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
+  Elf_Internal_Rela *rel, *relend;
+
+  struct elf_lm32_link_hash_table *htab = lm32_elf_hash_table (info);
+  bfd *dynobj;
+  bfd_vma *local_got_offsets;
+  asection *sgot, *splt, *sreloc;
+
+  dynobj = htab->root.dynobj;
+  local_got_offsets = elf_local_got_offsets (input_bfd);
+
+  sgot = htab->sgot;
+  splt = htab->splt;
+  sreloc = NULL;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+               
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      reloc_howto_type *howto;
+      unsigned int r_type;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_vma gp;
+      bfd_reloc_status_type r;
+      const char *name = NULL;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type = ELF32_R_TYPE (rel->r_info);
+      
+      if (r_type == R_LM32_GNU_VTENTRY
+          || r_type == R_LM32_GNU_VTINHERIT )
+        continue;
+        
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+
+      howto = lm32_elf_howto_table + r_type;
+      
+      if (r_symndx < symtab_hdr->sh_info)
+        {
+          /* It's a local symbol.  */
+          sym = local_syms + r_symndx;
+          sec = local_sections[r_symndx];
+          relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+          name = bfd_elf_string_from_elf_section
+	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
+	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
+        }
+      else
+        {        
+          /* It's a global symbol.  */
+          bfd_boolean unresolved_reloc;
+	  bfd_boolean warned;
+	  	            
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned);
+	  name = h->root.root.string;            
+        }
+
+      if (sec != NULL && elf_discarded_section (sec))
+	{
+	  /* For relocs against symbols from removed linkonce sections,
+	     or sections discarded by a linker script, we just want the
+	     section contents zeroed.  Avoid any special processing.  */
+	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
+	  rel->r_info = 0;
+	  rel->r_addend = 0;
+	  continue;
+	}
+
+      if (info->relocatable)
+        {
+	  /* This is a relocatable link.  We don't have to change
+	     anything, unless the reloc is against a section symbol,
+	     in which case we have to adjust according to where the
+	     section symbol winds up in the output section.  */	     
+	  if (sym == NULL || ELF_ST_TYPE (sym->st_info) != STT_SECTION)
+	    continue;
+
+	  /* If partial_inplace, we need to store any additional addend
+	     back in the section.  */
+	  if (! howto->partial_inplace)
+	    continue;
+	  
+          /* Shouldn't reach here */  
+	  abort();  
+	  r = bfd_reloc_ok;  
+        }
+      else 
+        {  
+          switch (howto->type)
+            {
+            case R_LM32_GPREL16:
+              if (!lm32_elf_assign_gp (output_bfd, &gp))
+                r = bfd_reloc_dangerous;
+              else 
+                {
+                  relocation = relocation + rel->r_addend - gp;
+                  rel->r_addend = 0;
+                  if ((signed)relocation < -32768 || (signed)relocation > 32767)
+                    r = bfd_reloc_outofrange;
+                  else
+                    {
+                      r = _bfd_final_link_relocate (howto, input_bfd,
+                				  input_section, contents,
+               				  rel->r_offset, relocation,
+               				  rel->r_addend);
+                   }
+                }
+              break;
+            case R_LM32_16_GOT:
+              /* Relocation is to the entry for this symbol in the global
+                 offset table.  */
+              BFD_ASSERT (sgot != NULL);
+              if (h != NULL)
+                {
+                  bfd_boolean dyn;
+                  bfd_vma off;
+            
+                  off = h->got.offset;
+                  BFD_ASSERT (off != (bfd_vma) -1);
+            
+                  dyn = htab->root.dynamic_sections_created;
+                  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
+                      || (info->shared
+                          && (info->symbolic
+                              || h->dynindx == -1
+                              || h->forced_local)
+                          && h->def_regular))
+                    {
+                      /* This is actually a static link, or it is a
+                         -Bsymbolic link and the symbol is defined
+                         locally, or the symbol was forced to be local
+                         because of a version file.  We must initialize
+                         this entry in the global offset table.  Since the
+                         offset must always be a multiple of 4, we use the
+                         least significant bit to record whether we have
+                         initialized it already.
+            
+                         When doing a dynamic link, we create a .rela.got
+                         relocation entry to initialize the value.  This
+                         is done in the finish_dynamic_symbol routine.  */
+                      if ((off & 1) != 0)
+                        off &= ~1;
+                      else
+                        {
+                          bfd_put_32 (output_bfd, relocation,
+                                      sgot->contents + off);
+                          h->got.offset |= 1;
+                        }
+                    }
+            
+                  relocation = sgot->output_offset + off;
+                }
+              else
+                {
+                  bfd_vma off;
+                  bfd_byte *loc;
+            
+                  BFD_ASSERT (local_got_offsets != NULL
+                              && local_got_offsets[r_symndx] != (bfd_vma) -1);
+            
+                  off = local_got_offsets[r_symndx];
+
+                  /* Don't use addend */
+                  relocation = relocation + rel->r_addend;
+                  rel->r_addend = 0;
+            
+                  /* The offset must always be a multiple of 4.  We use
+                     the least significant bit to record whether we have
+                     already processed this entry.  */
+                  if ((off & 1) != 0)
+                    off &= ~1;
+                  else
+                    {
+                      bfd_put_32 (output_bfd, relocation, sgot->contents + off);
+            
+                      if (info->shared)
+                        {
+                          asection *srelgot;
+                          Elf_Internal_Rela outrel;
+            
+                          /* We need to generate a R_LM32_RELATIVE reloc
+                             for the dynamic linker.  */
+                          srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
+                          BFD_ASSERT (srelgot != NULL);
+            
+                          outrel.r_offset = (sgot->output_section->vma
+                                             + sgot->output_offset
+                                             + off);
+                          outrel.r_info = ELF32_R_INFO (0, R_LM32_RELATIVE);
+                          outrel.r_addend = relocation;
+                          loc = srelgot->contents;
+                          loc += srelgot->reloc_count * sizeof (Elf32_External_Rela);
+                          bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
+                          ++srelgot->reloc_count;
+                        }
+            
+                      local_got_offsets[r_symndx] |= 1;
+                    }
+            
+                  relocation = sgot->output_offset + off;                            
+                }
+              r = _bfd_final_link_relocate (howto,
+                                            input_bfd, 
+                                            input_section,
+                                            contents, 
+                                            rel->r_offset,
+                                            relocation, 
+                                            rel->r_addend);
+              break;
+            default:
+              r = _bfd_final_link_relocate (howto,
+                                            input_bfd, 
+                                            input_section,
+                                            contents, 
+                                            rel->r_offset,
+                                            relocation, 
+                                            rel->r_addend);
+              break;
+            }
+        }
+        
+      if (r != bfd_reloc_ok)
+        {
+          const char *name;
+          const char *msg = (const char *) 0;
+          arelent bfd_reloc;
+          reloc_howto_type *howto;
+
+          lm32_info_to_howto_rela (input_bfd, &bfd_reloc, rel);
+          howto = bfd_reloc.howto;
+
+          if (h != NULL)
+            name = h->root.root.string;
+          else
+            {
+              name = (bfd_elf_string_from_elf_section
+                      (input_bfd, symtab_hdr->sh_link, sym->st_name));
+              if (name == NULL || *name == '\0')
+                name = bfd_section_name (input_bfd, sec);
+            }
+
+          switch (r)
+            {
+            /* 2.15 code 
+            case bfd_reloc_overflow:
+              if (! ((*info->callbacks->reloc_overflow)
+                     (info, name, howto->name, (bfd_vma) 0,
+                      input_bfd, input_section, rel->r_offset)))
+                return FALSE;
+              break;
+            */
+	    case bfd_reloc_overflow:
+	      if ((h != NULL) 
+                 && (h->root.type == bfd_link_hash_undefweak))
+	        break;
+	      if (! ((*info->callbacks->reloc_overflow)
+		     (info, (h ? &h->root : NULL), name, howto->name,
+		      (bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
+		return FALSE;
+	      break;            
+
+            case bfd_reloc_undefined:
+              if (! ((*info->callbacks->undefined_symbol)
+                     (info, name, input_bfd, input_section,
+                      rel->r_offset, TRUE)))
+                return FALSE;
+              break;
+
+            case bfd_reloc_outofrange:
+              msg = _("internal error: out of range error");
+              goto common_error;
+
+            case bfd_reloc_notsupported:
+              msg = _("internal error: unsupported relocation error");
+              goto common_error;
+
+            case bfd_reloc_dangerous:
+              msg = _("internal error: dangerous error");
+              goto common_error;
+
+            default:
+              msg = _("internal error: unknown error");
+              /* fall through */
+
+            common_error:
+              if (!((*info->callbacks->warning)
+                    (info, msg, name, input_bfd, input_section,
+                     rel->r_offset)))
+                return FALSE;
+              break;
+            }
+        }
+    }                 
+
+  return TRUE;
+}
+
+static asection *
+lm32_elf_gc_mark_hook (asection *sec, 
+                       struct bfd_link_info *info, 
+                       Elf_Internal_Rela *rel, 
+                       struct elf_link_hash_entry *h, 
+                       Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_LM32_GNU_VTINHERIT:
+      case R_LM32_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+static bfd_boolean
+lm32_elf_gc_sweep_hook (bfd *abfd, 
+                        struct bfd_link_info *info ATTRIBUTE_UNUSED, 
+                        asection *sec, 
+                        const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
+{
+  /* Update the got entry reference counts for the section being removed.  */
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  bfd_signed_vma *local_got_refcounts;
+  const Elf_Internal_Rela *rel, *relend;
+ 
+  elf_section_data (sec)->local_dynrel = NULL;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  local_got_refcounts = elf_local_got_refcounts (abfd);
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h = NULL;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      switch (ELF32_R_TYPE (rel->r_info))
+	{
+	case R_LM32_16_GOT:
+	  if (h != NULL)
+	    {
+	      if (h->got.refcount > 0)
+		h->got.refcount--;
+	    }
+	  else
+	    {
+	      if (local_got_refcounts && local_got_refcounts[r_symndx] > 0)
+		local_got_refcounts[r_symndx]--;
+	    }
+	  break;
+
+	default:
+	  break;
+	}
+    }
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase.  */
+static bfd_boolean
+lm32_elf_check_relocs (bfd *abfd, 
+                       struct bfd_link_info *info, 
+                       asection *sec, 
+                       const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  struct elf_lm32_link_hash_table *htab;
+  bfd *dynobj;
+  bfd_vma *local_got_offsets;
+  asection *sgot, *srelgot, *sreloc;
+
+  if (info->relocatable)
+    return TRUE;
+
+  sgot = srelgot = sreloc = NULL;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
+  if (!elf_bad_symtab (abfd))
+    sym_hashes_end -= symtab_hdr->sh_info;
+
+  htab = lm32_elf_hash_table (info);
+  dynobj = htab->root.dynobj;
+  local_got_offsets = elf_local_got_offsets (abfd);
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      int r_type;
+      struct elf_link_hash_entry *h;
+      unsigned long r_symndx;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type = ELF32_R_TYPE (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+        h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+ 
+
+      /* Some relocs require a global offset table.  */
+      if (htab->sgot == NULL)
+        {
+          switch (r_type)
+            {
+            case R_LM32_16_GOT:
+              if (dynobj == NULL)
+                htab->root.dynobj = dynobj = abfd;
+              if (! create_got_section (dynobj, info))
+                return FALSE;
+              break;
+
+            default:
+              break;
+          }
+        }
+
+
+      switch (r_type)
+	{
+	case R_LM32_16_GOT:
+          if (h != NULL)
+            h->got.refcount += 1;
+          else
+            {
+              bfd_signed_vma *local_got_refcounts;
+
+              /* This is a global offset table entry for a local
+                 symbol.  */
+              local_got_refcounts = elf_local_got_refcounts (abfd);
+              if (local_got_refcounts == NULL)
+                {
+                  bfd_size_type size;
+
+                  size = symtab_hdr->sh_info;
+                  size *= sizeof (bfd_signed_vma);
+                  local_got_refcounts = bfd_zalloc (abfd, size);
+                  if (local_got_refcounts == NULL)
+                    return FALSE;
+                  elf_local_got_refcounts (abfd) = local_got_refcounts;
+                }
+              local_got_refcounts[r_symndx] += 1;
+            }
+          break;
+
+        /* This relocation describes the C++ object vtable hierarchy.
+           Reconstruct it for later use during GC.  */
+        case R_LM32_GNU_VTINHERIT:
+          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+            return FALSE;
+          break;
+
+        /* This relocation describes which C++ vtable entries are actually
+           used.  Record for later use during GC.  */
+        case R_LM32_GNU_VTENTRY:
+          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+            return FALSE;
+          break;
+
+        }
+    }
+
+  return TRUE;
+}
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+lm32_elf_finish_dynamic_sections (bfd *output_bfd,
+				  struct bfd_link_info *info)
+{
+  struct elf_lm32_link_hash_table *htab;
+  bfd *dynobj;
+  asection *sdyn;
+  asection *sgot;
+  
+  htab = lm32_elf_hash_table (info);
+  dynobj = htab->root.dynobj;
+
+  sgot = htab->sgotplt;
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  if (htab->root.dynamic_sections_created)
+    {
+      asection *splt;
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      BFD_ASSERT (sgot != NULL && sdyn != NULL);
+
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+
+      for (; dyncon < dynconend; dyncon++)
+        {
+          Elf_Internal_Dyn dyn;
+          const char *name;
+          asection *s;
+
+          bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+          switch (dyn.d_tag)
+            {
+            default:
+              break;
+
+            case DT_PLTGOT:
+              name = ".got";
+              s = htab->sgot->output_section;
+              goto get_vma;
+            case DT_JMPREL:
+              name = ".rela.plt";
+              s = htab->srelplt->output_section;
+            get_vma:
+              BFD_ASSERT (s != NULL);
+              dyn.d_un.d_ptr = s->vma;
+              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+              break;
+
+            case DT_PLTRELSZ:
+              s = htab->srelplt->output_section;
+              BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_val = s->size;
+              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+              break;
+
+            case DT_RELASZ:
+              /* My reading of the SVR4 ABI indicates that the
+                 procedure linkage table relocs (DT_JMPREL) should be
+                 included in the overall relocs (DT_RELA).  This is
+                 what Solaris does.  However, UnixWare can not handle
+                 that case.  Therefore, we override the DT_RELASZ entry
+                 here to make it not include the JMPREL relocs.  Since
+                 the linker script arranges for .rela.plt to follow all
+                 other relocation sections, we don't have to worry
+                 about changing the DT_RELA entry.  */
+              if (htab->srelplt != NULL)
+                {
+                  s = htab->srelplt->output_section;
+		  dyn.d_un.d_val -= s->size;
+                }
+              bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+              break;
+            }
+        }
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      splt = htab->splt;
+      if (splt && splt->size > 0)
+        {
+          if (info->shared)
+            {
+              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD0, splt->contents);
+              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD1, splt->contents + 4);
+              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD2, splt->contents + 8);
+              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD3, splt->contents + 12);
+              bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD4, splt->contents + 16);
+            }
+          else
+            {
+              unsigned long addr;
+              /* addr = .got + 4 */
+              addr = sgot->output_section->vma + sgot->output_offset + 4;
+              bfd_put_32 (output_bfd,
+			  PLT0_ENTRY_WORD0 | ((addr >> 16) & 0xffff),
+			  splt->contents);
+              bfd_put_32 (output_bfd,
+			  PLT0_ENTRY_WORD1 | (addr & 0xffff),
+			  splt->contents + 4);
+              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD2, splt->contents + 8);
+              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD3, splt->contents + 12);
+              bfd_put_32 (output_bfd, PLT0_ENTRY_WORD4, splt->contents + 16);
+            }
+
+          elf_section_data (splt->output_section)->this_hdr.sh_entsize =
+            PLT_ENTRY_SIZE;
+        }
+    }
+
+  /* Fill in the first three entries in the global offset table.  */
+  if (sgot && sgot->size > 0)
+    {
+      if (sdyn == NULL)
+        bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
+      else
+        bfd_put_32 (output_bfd,
+                    sdyn->output_section->vma + sdyn->output_offset,
+                    sgot->contents);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
+
+      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
+    }
+
+  return TRUE;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+lm32_elf_finish_dynamic_symbol (bfd *output_bfd,
+				struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym)
+{
+  struct elf_lm32_link_hash_table *htab;
+  bfd *dynobj;
+  bfd_byte *loc;
+
+  htab = lm32_elf_hash_table (info);
+  dynobj = htab->root.dynobj;
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      asection *splt;
+      asection *sgot;
+      asection *srela;
+
+      bfd_vma plt_index;
+      bfd_vma got_offset;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+         it up.  */
+
+      BFD_ASSERT (h->dynindx != -1);
+
+      splt = htab->splt;
+      sgot = htab->sgotplt;
+      srela = htab->srelplt;
+      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
+
+      /* Get the index in the procedure linkage table which
+         corresponds to this symbol.  This is the index of this symbol
+         in all the symbols for which we are making plt entries.  The
+         first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
+
+      /* Get the offset into the .got table of the entry that
+        corresponds to this function.  Each .got entry is 4 bytes.
+        The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+      
+      /* Fill in the entry in the procedure linkage table.  */
+      if (! info->shared)
+        {
+          /* TODO */
+        }
+      else
+        {
+          /* TODO */
+        }
+
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd,
+                  (splt->output_section->vma
+                   + splt->output_offset
+                   + h->plt.offset
+                   + 12), /* same offset */
+                  sgot->contents + got_offset);
+
+      /* Fill in the entry in the .rela.plt section.  */
+      rela.r_offset = (sgot->output_section->vma
+                       + sgot->output_offset
+                       + got_offset);
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_LM32_JMP_SLOT);
+      rela.r_addend = 0;
+      loc = srela->contents;
+      loc += plt_index * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+
+      if (!h->def_regular)
+        {
+          /* Mark the symbol as undefined, rather than as defined in
+             the .plt section.  Leave the value alone.  */
+          sym->st_shndx = SHN_UNDEF;
+        }
+               
+    }
+
+  if (h->got.offset != (bfd_vma) -1)
+    {
+      asection *sgot;
+      asection *srela;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the global offset table.  Set it
+         up.  */
+
+      sgot = htab->sgot;
+      srela = htab->srelgot;
+      BFD_ASSERT (sgot != NULL && srela != NULL);
+
+      rela.r_offset = (sgot->output_section->vma
+                       + sgot->output_offset
+                       + (h->got.offset &~ 1));
+
+      /* If this is a -Bsymbolic link, and the symbol is defined
+         locally, we just want to emit a RELATIVE reloc.  Likewise if
+         the symbol was forced to be local because of a version file.
+         The entry in the global offset table will already have been
+         initialized in the relocate_section function.  */
+      if (info->shared
+          && (info->symbolic
+	      || h->dynindx == -1
+	      || h->forced_local)
+          && h->def_regular)
+        {
+          rela.r_info = ELF32_R_INFO (0, R_LM32_RELATIVE);
+          rela.r_addend = (h->root.u.def.value
+                           + h->root.u.def.section->output_section->vma
+                           + h->root.u.def.section->output_offset);
+        }
+      else
+        {
+	  BFD_ASSERT ((h->got.offset & 1) == 0);
+          bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
+          rela.r_info = ELF32_R_INFO (h->dynindx, R_LM32_GLOB_DAT);
+          rela.r_addend = 0;
+        }
+
+      loc = srela->contents;
+      loc += srela->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++srela->reloc_count;
+    }
+
+  if (h->needs_copy)
+    {
+      asection *s;
+      Elf_Internal_Rela rela;
+
+      /* This symbols needs a copy reloc.  Set it up.  */
+
+      BFD_ASSERT (h->dynindx != -1
+                  && (h->root.type == bfd_link_hash_defined
+                      || h->root.type == bfd_link_hash_defweak));
+
+      s = bfd_get_section_by_name (h->root.u.def.section->owner,
+                                   ".rela.bss");
+      BFD_ASSERT (s != NULL);
+
+      rela.r_offset = (h->root.u.def.value
+                       + h->root.u.def.section->output_section->vma
+                       + h->root.u.def.section->output_offset);
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_LM32_COPY);
+      rela.r_addend = 0;
+      loc = s->contents;
+      loc += s->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++s->reloc_count;
+    }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || h == htab->root.hgot)
+    sym->st_shndx = SHN_ABS;
+ 
+  return TRUE;
+}
+
+static enum elf_reloc_type_class
+lm32_elf_reloc_type_class (const Elf_Internal_Rela *rela)
+{
+  switch ((int) ELF32_R_TYPE (rela->r_info))
+    {
+    case R_LM32_RELATIVE:  return reloc_class_relative;
+    case R_LM32_JMP_SLOT:  return reloc_class_plt;
+    case R_LM32_COPY:      return reloc_class_copy;
+    default:      	   return reloc_class_normal;
+    }
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+lm32_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+				struct elf_link_hash_entry *h)
+{
+  struct elf_lm32_link_hash_table *htab;
+  struct elf_lm32_link_hash_entry *eh;
+  struct elf_lm32_dyn_relocs *p;
+  bfd *dynobj;
+  asection *s;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+              && (h->needs_plt
+                  || h->u.weakdef != NULL
+                  || (h->def_dynamic
+                      && h->ref_regular
+                      && !h->def_regular)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (! info->shared
+          && !h->def_dynamic
+          && !h->ref_dynamic
+	  && h->root.type != bfd_link_hash_undefweak
+	  && h->root.type != bfd_link_hash_undefined)
+        {
+          /* This case can occur if we saw a PLT reloc in an input
+             file, but the symbol was never referred to by a dynamic
+             object.  In such a case, we don't actually need to build
+             a procedure linkage table, and we can just do a PCREL
+             reloc instead.  */
+          h->plt.offset = (bfd_vma) -1;
+          h->needs_plt = 0;
+        }
+
+      return TRUE;
+    }
+  else
+    h->plt.offset = (bfd_vma) -1;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
+                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  eh = (struct elf_lm32_link_hash_entry *) h;
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      s = p->sec->output_section;
+      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
+        break;
+    }
+
+  /* If we didn't find any dynamic relocs in sections which needs the
+     copy reloc, then we'll be keeping the dynamic relocs and avoiding
+     the copy reloc.  */
+  if (p == NULL)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  if (h->size == 0)
+    {
+      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
+			     h->root.root.string);
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  htab = lm32_elf_hash_table (info);
+  s = htab->sdynbss;
+  BFD_ASSERT (s != NULL);
+
+  /* We must generate a R_LM32_COPY reloc to tell the dynamic linker
+     to copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rela.bss section we are going to use.  */
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      asection *srel;
+
+      srel = htab->srelbss;
+      BFD_ASSERT (srel != NULL);
+      srel->size += sizeof (Elf32_External_Rela);
+      h->needs_copy = 1;
+    }
+
+  return _bfd_elf_adjust_dynamic_copy (h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bfd_boolean
+allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
+{
+  struct bfd_link_info *info;
+  struct elf_lm32_link_hash_table *htab;
+  struct elf_lm32_link_hash_entry *eh;
+  struct elf_lm32_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  if (h->root.type == bfd_link_hash_warning)
+    /* When warning symbols are created, they **replace** the "real"
+       entry in the hash table, thus we never get to see the real
+       symbol in a hash traversal.  So look at it now.  */
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  info = (struct bfd_link_info *) inf;
+  htab = lm32_elf_hash_table (info);
+
+  eh = (struct elf_lm32_link_hash_entry *) h;
+
+  if (htab->root.dynamic_sections_created
+      && h->plt.refcount > 0)
+    {
+      /* Make sure this symbol is output as a dynamic symbol.
+         Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+          && !h->forced_local)
+        {
+          if (! bfd_elf_link_record_dynamic_symbol (info, h))
+            return FALSE;
+        }
+
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
+        {
+          asection *s = htab->splt;
+
+          /* If this is the first .plt entry, make room for the special
+             first entry.  */
+          if (s->size == 0)
+            s->size += PLT_ENTRY_SIZE;
+
+          h->plt.offset = s->size;
+
+          /* If this symbol is not defined in a regular file, and we are
+             not generating a shared library, then set the symbol to this
+             location in the .plt.  This is required to make function
+             pointers compare as equal between the normal executable and
+             the shared library.  */
+          if (! info->shared
+              && !h->def_regular)
+            {
+              h->root.u.def.section = s;
+              h->root.u.def.value = h->plt.offset;
+            }
+
+          /* Make room for this entry.  */
+          s->size += PLT_ENTRY_SIZE;
+
+          /* We also need to make an entry in the .got.plt section, which
+             will be placed in the .got section by the linker script.  */
+          htab->sgotplt->size += 4;
+
+          /* We also need to make an entry in the .rel.plt section.  */
+          htab->srelplt->size += sizeof (Elf32_External_Rela);
+        }
+      else
+        {
+          h->plt.offset = (bfd_vma) -1;
+          h->needs_plt = 0;
+        }
+    }
+  else
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->needs_plt = 0;
+    }
+
+  if (h->got.refcount > 0)
+    {
+      asection *s;
+      bfd_boolean dyn;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+         Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+          && !h->forced_local)
+        {
+          if (! bfd_elf_link_record_dynamic_symbol (info, h))
+            return FALSE;
+        }
+
+      s = htab->sgot;
+
+      h->got.offset = s->size;
+      s->size += 4;
+      dyn = htab->root.dynamic_sections_created;
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
+        htab->srelgot->size += sizeof (Elf32_External_Rela);
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  if (eh->dyn_relocs == NULL)
+    return TRUE;
+
+  /* In the shared -Bsymbolic case, discard space allocated for
+     dynamic pc-relative relocs against symbols which turn out to be
+     defined in regular objects.  For the normal shared case, discard
+     space for pc-relative relocs that have become local due to symbol
+     visibility changes.  */
+
+  if (info->shared)
+    {
+      if (h->def_regular
+          && (h->forced_local
+              || info->symbolic))
+        {
+          struct elf_lm32_dyn_relocs **pp;
+
+          for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)
+            {
+              p->count -= p->pc_count;
+              p->pc_count = 0;
+              if (p->count == 0)
+                *pp = p->next;
+              else
+                pp = &p->next;
+            }
+        }
+
+      /* Also discard relocs on undefined weak syms with non-default
+	 visibility.  */
+      if (eh->dyn_relocs != NULL
+	  && h->root.type == bfd_link_hash_undefweak)
+	{
+	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
+	    eh->dyn_relocs = NULL;
+
+	  /* Make sure undefined weak symbols are output as a dynamic
+	     symbol in PIEs.  */
+	  else if (h->dynindx == -1
+		   && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+	}
+    }
+  else
+    {
+      /* For the non-shared case, discard space for relocs against
+         symbols which turn out to need copy relocs or are not
+         dynamic.  */
+
+      if (!h->non_got_ref
+          && ((h->def_dynamic
+               && !h->def_regular)
+              || (htab->root.dynamic_sections_created
+                  && (h->root.type == bfd_link_hash_undefweak
+                      || h->root.type == bfd_link_hash_undefined))))
+        {
+          /* Make sure this symbol is output as a dynamic symbol.
+             Undefined weak syms won't yet be marked as dynamic.  */
+          if (h->dynindx == -1
+              && !h->forced_local)
+            {
+              if (! bfd_elf_link_record_dynamic_symbol (info, h))
+                return FALSE;
+            }
+
+          /* If that succeeded, we know we'll be keeping all the
+             relocs.  */
+          if (h->dynindx != -1)
+            goto keep;
+        }
+
+      eh->dyn_relocs = NULL;
+
+    keep: ;
+    }
+
+  /* Finally, allocate space.  */
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (Elf32_External_Rela);
+    }
+
+  return TRUE;
+}
+
+/* Find any dynamic relocs that apply to read-only sections.  */
+
+static bfd_boolean
+readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
+{
+  struct elf_lm32_link_hash_entry *eh;
+  struct elf_lm32_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  eh = (struct elf_lm32_link_hash_entry *) h;
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+        {
+          struct bfd_link_info *info = (struct bfd_link_info *) inf;
+
+          info->flags |= DF_TEXTREL;
+
+          /* Not an error, just cut short the traversal.  */
+          return FALSE;
+        }
+    }
+  return TRUE;
+}
+
+/* Set the sizes of the dynamic sections.  */
+static bfd_boolean
+lm32_elf_always_size_sections (bfd *output_bfd,
+				 struct bfd_link_info *info)
+{
+  if (!info->relocatable)
+    {
+      struct elf_link_hash_entry *h;
+      asection *sec;
+      /* Force a PT_GNU_STACK segment to be created.  */
+      if (! elf_tdata (output_bfd)->stack_flags)
+	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;
+
+      /* Define __stacksize if it's not defined yet.  */
+      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
+				FALSE, FALSE, FALSE);
+      if (! h || h->root.type != bfd_link_hash_defined
+	  || h->type != STT_OBJECT
+	  || !h->def_regular)
+	{
+	  struct bfd_link_hash_entry *bh = NULL;
+
+	  if (!(_bfd_generic_link_add_one_symbol
+		(info, output_bfd, "__stacksize",
+		 BSF_GLOBAL, bfd_abs_section_ptr, DEFAULT_STACK_SIZE,
+		 (const char *) NULL, FALSE,
+		 get_elf_backend_data (output_bfd)->collect, &bh)))
+	    return FALSE;
+
+	  h = (struct elf_link_hash_entry *) bh;
+	  h->def_regular = 1;
+	  h->type = STT_OBJECT;
+	  /* This one must NOT be hidden.  */
+	}
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+lm32_elf_modify_segment_map (bfd *output_bfd,
+			       struct bfd_link_info *info)
+{
+  struct elf_segment_map *m;
+
+  /* objcopy and strip preserve what's already there using
+     elf32_frvfdpic_copy_private_bfd_data ().  */
+  if (! info)
+    return TRUE;
+
+  for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
+    if (m->p_type == PT_GNU_STACK)
+      break;
+
+  if (m)
+    {
+      asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
+      struct elf_link_hash_entry *h;
+
+      if (sec)
+	{
+	  /* Obtain the pointer to the __stacksize symbol.  */
+	  h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
+				    FALSE, FALSE, FALSE);
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
+	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
+
+	  /* Set the section size from the symbol value.  We
+	     intentionally ignore the symbol section.  */
+	  if (h->root.type == bfd_link_hash_defined)
+	    sec->size = h->root.u.def.value;
+	  else
+	    sec->size = DEFAULT_STACK_SIZE;
+
+	  /* Add the stack section to the PT_GNU_STACK segment,
+	     such that its size and alignment requirements make it
+	     to the segment.  */
+	  m->sections[m->count] = sec;
+	  m->count++;
+	}
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+lm32_elf_modify_program_headers (bfd *output_bfd,
+				       struct bfd_link_info *info)
+{
+  struct elf_obj_tdata *tdata = elf_tdata (output_bfd);
+  struct elf_segment_map *m;
+  Elf_Internal_Phdr *p;
+
+  if (! info)
+    return TRUE;
+
+  for (p = tdata->phdr, m = tdata->segment_map; m != NULL; m = m->next, p++)
+    if (m->p_type == PT_GNU_STACK)
+      break;
+
+  if (m)
+    {
+      struct elf_link_hash_entry *h;
+
+      /* Obtain the pointer to the __stacksize symbol.  */
+      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
+				FALSE, FALSE, FALSE);
+      if (h)
+	{
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
+	}
+
+      /* Set the header p_memsz from the symbol value.  We
+	 intentionally ignore the symbol section.  */
+      if (h && h->root.type == bfd_link_hash_defined)
+	p->p_memsz = h->root.u.def.value;
+      else
+	p->p_memsz = DEFAULT_STACK_SIZE;
+
+      p->p_align = 8;
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+lm32_elf_copy_private_bfd_data (ibfd, obfd)
+     bfd *ibfd;
+     bfd *obfd;
+{
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  BFD_ASSERT (!elf_flags_init (obfd)
+	      || elf_elfheader (obfd)->e_flags == elf_elfheader (ibfd)->e_flags);
+
+  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
+  elf_flags_init (obfd) = TRUE;
+
+  /* Copy object attributes.  */
+  _bfd_elf_copy_obj_attributes (ibfd, obfd);
+
+  return TRUE;
+}
+
+static bfd_boolean
+lm32_elf_fdpic_copy_private_bfd_data (ibfd, obfd)
+     bfd *ibfd;
+     bfd *obfd;
+{
+  unsigned i;
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  if (! lm32_elf_copy_private_bfd_data (ibfd, obfd))
+    return FALSE;
+
+  if (! elf_tdata (ibfd) || ! elf_tdata (ibfd)->phdr
+      || ! elf_tdata (obfd) || ! elf_tdata (obfd)->phdr)
+    return TRUE;
+
+  /* Copy the stack size.  */
+  for (i = 0; i < elf_elfheader (ibfd)->e_phnum; i++)
+    if (elf_tdata (ibfd)->phdr[i].p_type == PT_GNU_STACK)
+      {
+	Elf_Internal_Phdr *iphdr = &elf_tdata (ibfd)->phdr[i];
+
+	for (i = 0; i < elf_elfheader (obfd)->e_phnum; i++)
+	  if (elf_tdata (obfd)->phdr[i].p_type == PT_GNU_STACK)
+	    {
+	      memcpy (&elf_tdata (obfd)->phdr[i], iphdr, sizeof (*iphdr));
+
+	      /* Rewrite the phdrs, since we're only called after they
+		 were first written.  */
+	      if (bfd_seek (obfd, (bfd_signed_vma) get_elf_backend_data (obfd)
+			    ->s->sizeof_ehdr, SEEK_SET) != 0
+		  || get_elf_backend_data (obfd)->s
+		  ->write_out_phdrs (obfd, elf_tdata (obfd)->phdr,
+				     elf_elfheader (obfd)->e_phnum) != 0)
+		return FALSE;
+	      break;
+	    }
+
+	break;
+      }
+
+  return TRUE;
+}
+
+static bfd_boolean
+lm32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED, 
+                                struct bfd_link_info *info)
+{
+  struct elf_lm32_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean relocs;
+  bfd *ibfd;
+
+  htab = lm32_elf_hash_table (info);
+  dynobj = htab->root.dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (info->executable)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
+	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      asection *srel;
+
+      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
+        continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+        {
+          struct elf_lm32_dyn_relocs *p;
+
+          for (p = ((struct elf_lm32_dyn_relocs *)
+                    elf_section_data (s)->local_dynrel);
+               p != NULL;
+               p = p->next)
+            {
+              if (! bfd_is_abs_section (p->sec)
+                  && bfd_is_abs_section (p->sec->output_section))
+                {
+                  /* Input section has been discarded, either because
+                     it is a copy of a linkonce section or due to
+                     linker script /DISCARD/, so we'll be discarding
+                     the relocs too.  */
+                }
+              else if (p->count != 0)
+                {
+                  srel = elf_section_data (p->sec)->sreloc;
+                  srel->size += p->count * sizeof (Elf32_External_Rela);
+                  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+                    info->flags |= DF_TEXTREL;
+                }
+            }
+        }
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+        continue;
+
+      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      s = htab->sgot;
+      srel = htab->srelgot;
+      for (; local_got < end_local_got; ++local_got)
+        {
+          if (*local_got > 0)
+            {
+              *local_got = s->size;
+              s->size += 4;
+              if (info->shared)
+                srel->size += sizeof (Elf32_External_Rela);
+            }
+          else
+            *local_got = (bfd_vma) -1;
+        }
+    }
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);
+
+  /* We now have determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  relocs = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+        continue;
+
+      if (s == htab->splt
+          || s == htab->sgot
+          || s == htab->sgotplt
+	  || s == htab->sdynbss)
+        {
+          /* Strip this section if we don't need it; see the
+             comment below.  */
+        }
+      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
+        {
+          if (s->size != 0 && s != htab->srelplt)
+            relocs = TRUE;
+
+          /* We use the reloc_count field as a counter if we need
+             to copy relocs into the output file.  */
+          s->reloc_count = 0;
+        }
+      else
+	/* It's not one of our sections, so don't allocate space.  */
+	continue;
+
+      if (s->size == 0)
+        {
+          /* If we don't need this section, strip it from the
+             output file.  This is mostly to handle .rela.bss and
+             .rela.plt.  We must create both sections in
+             create_dynamic_sections, because they must be created
+             before the linker maps input sections to output
+             sections.  The linker does that before
+             adjust_dynamic_symbol is called, and it is that
+             function which decides whether anything needs to go
+             into these sections.  */
+          s->flags |= SEC_EXCLUDE;
+          continue;
+        }
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  We use bfd_zalloc
+         here in case unused entries are not reclaimed before the
+         section's contents are written out.  This should not happen,
+         but this way if it does, we get a R_LM32_NONE reloc instead
+         of garbage.  */
+      s->contents = bfd_zalloc (dynobj, s->size);
+      if (s->contents == NULL)
+        return FALSE;
+    }
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in lm32_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+     if (info->executable)
+	{
+	  if (! add_dynamic_entry (DT_DEBUG, 0))
+	    return FALSE;
+	}
+
+      if (htab->splt->size != 0)
+        {
+          if (! add_dynamic_entry (DT_PLTGOT, 0)
+              || ! add_dynamic_entry (DT_PLTRELSZ, 0)
+              || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
+              || ! add_dynamic_entry (DT_JMPREL, 0))
+            return FALSE;
+        }
+
+      if (relocs)
+        {
+          if (! add_dynamic_entry (DT_RELA, 0)
+              || ! add_dynamic_entry (DT_RELASZ, 0)
+              || ! add_dynamic_entry (DT_RELAENT,
+                                      sizeof (Elf32_External_Rela)))
+            return FALSE;
+
+          /* If any dynamic relocs apply to a read-only section,
+             then we need a DT_TEXTREL entry.  */
+          if ((info->flags & DF_TEXTREL) == 0)
+            elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
+                                    info);
+
+          if ((info->flags & DF_TEXTREL) != 0)
+            {
+              if (! add_dynamic_entry (DT_TEXTREL, 0))
+                return FALSE;
+            }
+        }
+    }
+#undef add_dynamic_entry
+
+  return TRUE;
+}
+
+/* Create dynamic sections when linking against a dynamic object.  */
+
+static bfd_boolean
+lm32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
+{
+  struct elf_lm32_link_hash_table *htab;
+  flagword flags, pltflags;
+  asection *s;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  int ptralign = 2; /* 32bit */
+
+  htab = lm32_elf_hash_table (info);
+
+  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
+     .rel[a].bss sections.  */
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+           | SEC_LINKER_CREATED);
+
+  pltflags = flags;
+  pltflags |= SEC_CODE;
+  if (bed->plt_not_loaded)
+    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
+  if (bed->plt_readonly)
+    pltflags |= SEC_READONLY;
+
+  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
+  htab->splt = s;
+  if (s == NULL
+      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
+    return FALSE;
+
+  if (bed->want_plt_sym)
+    {
+      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
+         .plt section.  */
+      struct bfd_link_hash_entry *bh = NULL;
+      struct elf_link_hash_entry *h;
+
+      if (! (_bfd_generic_link_add_one_symbol
+             (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
+              (bfd_vma) 0, NULL, FALSE,
+              get_elf_backend_data (abfd)->collect, &bh)))
+        return FALSE;
+      h = (struct elf_link_hash_entry *) bh;
+      h->def_regular = 1;
+      h->type = STT_OBJECT;
+      htab->root.hplt = h;
+
+      if (info->shared
+          && ! bfd_elf_link_record_dynamic_symbol (info, h))
+        return FALSE;
+    }
+
+  s = bfd_make_section_with_flags (abfd,
+				   bed->default_use_rela_p ? ".rela.plt" : ".rel.plt",
+				   flags | SEC_READONLY);
+  htab->srelplt = s;
+  if (s == NULL
+      || ! bfd_set_section_alignment (abfd, s, ptralign))
+    return FALSE;
+
+  if (htab->sgot == NULL
+      && ! create_got_section (abfd, info))
+    return FALSE;
+
+  {
+    const char *secname;
+    char *relname;
+    flagword secflags;
+    asection *sec;
+
+    for (sec = abfd->sections; sec; sec = sec->next)
+      {
+        secflags = bfd_get_section_flags (abfd, sec);
+        if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))
+            || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))
+          continue;
+        secname = bfd_get_section_name (abfd, sec);
+        relname = bfd_malloc ((bfd_size_type) strlen (secname) + 6);
+        strcpy (relname, ".rela");
+        strcat (relname, secname);
+        if (bfd_get_section_by_name (abfd, secname))
+          continue;
+        s = bfd_make_section_with_flags (abfd, relname,
+					 flags | SEC_READONLY);
+        if (s == NULL
+            || ! bfd_set_section_alignment (abfd, s, ptralign))
+          return FALSE;
+      }
+  }
+
+  if (bed->want_dynbss)
+    {
+      /* The .dynbss section is a place to put symbols which are defined
+         by dynamic objects, are referenced by regular objects, and are
+         not functions.  We must allocate space for them in the process
+         image and use a R_*_COPY reloc to tell the dynamic linker to
+         initialize them at run time.  The linker script puts the .dynbss
+         section into the .bss section of the final image.  */
+      s = bfd_make_section_with_flags (abfd, ".dynbss",
+				       SEC_ALLOC | SEC_LINKER_CREATED);
+      htab->sdynbss = s;
+      if (s == NULL)
+        return FALSE;
+      /* The .rel[a].bss section holds copy relocs.  This section is not
+         normally needed.  We need to create it here, though, so that the
+         linker will map it to an output section.  We can't just create it
+         only if we need it, because we will not know whether we need it
+         until we have seen all the input files, and the first time the
+         main linker code calls BFD after examining all the input files
+         (size_dynamic_sections) the input sections have already been
+         mapped to the output sections.  If the section turns out not to
+         be needed, we can discard it later.  We will never need this
+         section when generating a shared object, since they do not use
+         copy relocs.  */
+      if (! info->shared)
+        {
+          s = bfd_make_section_with_flags (abfd,
+					   (bed->default_use_rela_p
+					    ? ".rela.bss" : ".rel.bss"),
+					   flags | SEC_READONLY);
+          htab->srelbss = s;
+          if (s == NULL
+              || ! bfd_set_section_alignment (abfd, s, ptralign))
+            return FALSE;
+        }
+    }
+
+  return TRUE;
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+lm32_elf_copy_indirect_symbol (struct bfd_link_info *info,
+                               struct elf_link_hash_entry *dir,
+                               struct elf_link_hash_entry *ind)
+{
+  struct elf_lm32_link_hash_entry * edir;
+  struct elf_lm32_link_hash_entry * eind;
+
+  edir = (struct elf_lm32_link_hash_entry *) dir;
+  eind = (struct elf_lm32_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+        {
+          struct elf_lm32_dyn_relocs **pp;
+          struct elf_lm32_dyn_relocs *p;
+
+          /* Add reloc counts against the indirect sym to the direct sym
+             list.  Merge any entries against the same section.  */
+          for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
+            {
+              struct elf_lm32_dyn_relocs *q;
+
+              for (q = edir->dyn_relocs; q != NULL; q = q->next)
+                if (q->sec == p->sec)
+                  {
+                    q->pc_count += p->pc_count;
+                    q->count += p->count;
+                    *pp = p->next;
+                    break;
+                  }
+              if (q == NULL)
+                pp = &p->next;
+            }
+          *pp = edir->dyn_relocs;
+        }
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+#define ELF_ARCH                bfd_arch_lm32
+#define ELF_MACHINE_CODE        EM_LM32
+#define ELF_MAXPAGESIZE         0x1000
+
+#define TARGET_BIG_SYM          bfd_elf32_lm32_vec
+#define TARGET_BIG_NAME         "elf32-lm32"
+
+#define bfd_elf32_bfd_reloc_type_lookup         lm32_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup         lm32_reloc_name_lookup
+#define elf_info_to_howto                       lm32_info_to_howto_rela
+#define elf_info_to_howto_rel                   0
+#define elf_backend_rela_normal                 1
+#define elf_backend_object_p                    lm32_elf_object_p
+#define elf_backend_final_write_processing      lm32_elf_final_write_processing
+#define elf_backend_can_gc_sections             1
+#define elf_backend_can_refcount                1
+#define elf_backend_gc_mark_hook                lm32_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook               lm32_elf_gc_sweep_hook
+#define elf_backend_plt_readonly                1
+#define elf_backend_want_got_plt                1
+#define elf_backend_want_plt_sym                0
+#define elf_backend_got_header_size             12
+#define bfd_elf32_bfd_link_hash_table_create    lm32_elf_link_hash_table_create
+#define elf_backend_check_relocs                lm32_elf_check_relocs
+#define elf_backend_reloc_type_class            lm32_elf_reloc_type_class
+#define elf_backend_copy_indirect_symbol        lm32_elf_copy_indirect_symbol
+#define elf_backend_size_dynamic_sections       lm32_elf_size_dynamic_sections
+#define elf_backend_omit_section_dynsym         ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
+#define elf_backend_create_dynamic_sections     lm32_elf_create_dynamic_sections
+#define elf_backend_finish_dynamic_sections     lm32_elf_finish_dynamic_sections
+#define elf_backend_adjust_dynamic_symbol       lm32_elf_adjust_dynamic_symbol
+#define elf_backend_finish_dynamic_symbol       lm32_elf_finish_dynamic_symbol
+#define elf_backend_relocate_section            lm32_elf_relocate_section
+
+#undef elf_backend_always_size_sections
+#define elf_backend_always_size_sections        lm32_elf_always_size_sections
+#define elf_backend_modify_segment_map          lm32_elf_modify_segment_map
+#define elf_backend_modify_program_headers      lm32_elf_modify_program_headers
+#define bfd_elf32_bfd_copy_private_bfd_data     lm32_elf_fdpic_copy_private_bfd_data
+
+#include "elf32-target.h"
diff --git a/bfd/targets.c b/bfd/targets.c
index d408a21..a16bd3d 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -598,6 +598,7 @@ extern const bfd_target bfd_elf32_ia64_big_vec;
 extern const bfd_target bfd_elf32_ia64_hpux_big_vec;
 extern const bfd_target bfd_elf32_ip2k_vec;
 extern const bfd_target bfd_elf32_iq2000_vec;
+extern const bfd_target bfd_elf32_lm32_vec;
 extern const bfd_target bfd_elf32_little_generic_vec;
 extern const bfd_target bfd_elf32_littlearc_vec;
 extern const bfd_target bfd_elf32_littlearm_vec;
@@ -927,6 +928,7 @@ static const bfd_target * const _bfd_target_vector[] =
 #endif
 	&bfd_elf32_ip2k_vec,
 	&bfd_elf32_iq2000_vec,
+	&bfd_elf32_lm32_vec,
 	&bfd_elf32_little_generic_vec,
 	&bfd_elf32_littlearc_vec,
 	&bfd_elf32_littlearm_vec,
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 9fc8e0c..1927591 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -126,6 +126,7 @@
 #include "elf/i960.h"
 #include "elf/ia64.h"
 #include "elf/ip2k.h"
+#include "elf/lm32.h"
 #include "elf/iq2000.h"
 #include "elf/m32c.h"
 #include "elf/m32r.h"
@@ -631,6 +632,7 @@ guess_is_rela (unsigned long e_machine)
     case EM_IP2K:
     case EM_IP2K_OLD:
     case EM_IQ2000:
+    case EM_LM32:
     case EM_M32C:
     case EM_M32R:
     case EM_MCORE:
@@ -1176,6 +1178,10 @@ dump_relocations (FILE *file,
 	  rtype = elf_xtensa_reloc_type (type);
 	  break;
 
+	case EM_LM32:
+	  rtype = elf_lm32_reloc_type (type);
+	  break;
+
 	case EM_M32C:
 	  rtype = elf_m32c_reloc_type (type);
 	  break;
@@ -1784,6 +1790,7 @@ get_machine_name (unsigned e_machine)
     case EM_IQ2000:       	return "Vitesse IQ2000";
     case EM_XTENSA_OLD:
     case EM_XTENSA:		return "Tensilica Xtensa Processor";
+    case EM_LM32:		return "LatticeMico32";
     case EM_M32C:	        return "Renesas M32c";
     case EM_MT:                 return "Morpho Techologies MT processor";
     case EM_BLACKFIN:		return "Analog Devices Blackfin";
diff --git a/config.sub b/config.sub
index c060f44..97f9a65 100755
--- a/config.sub
+++ b/config.sub
@@ -249,6 +249,7 @@ case $basic_machine in
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
 	| maxq | mb | microblaze | mcore | mep \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
@@ -329,6 +330,7 @@ case $basic_machine in
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
+	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
 	| m88110-* | m88k-* | maxq-* | mcore-* \
@@ -668,6 +670,9 @@ case $basic_machine in
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	lm32)
+		basic_machine=lm32
+		;;
 	m88k-omron*)
 		basic_machine=m88k-omron
 		;;
diff --git a/cpu/lm32.cpu b/cpu/lm32.cpu
new file mode 100644
index 0000000..8c203f4
--- /dev/null
+++ b/cpu/lm32.cpu
@@ -0,0 +1,842 @@
+; LatticeMico32 CPU description.  -*- Scheme -*-
+; Contributed by Jon Beniston <jon@beniston.com>
+;
+; This file is part of the GNU Binutils.
+;
+; This program is free software; you can redistribute it and/or modify
+; it under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 2 of the License, or
+; (at your option) any later version.
+;
+; This program is distributed in the hope that it will be useful,
+; but WITHOUT ANY WARRANTY; without even the implied warranty of
+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+; GNU General Public License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with this program; if not, write to the Free Software
+; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+(include "simplify.inc")
+
+(define-arch
+  (name lm32) ; name of cpu family
+  (comment "LatticeMico32")
+  (default-alignment aligned)
+  (insn-lsb0? #t)
+  (machs lm32)
+  (isas lm32)
+)
+
+
+; Instruction sets.
+
+(define-isa
+  (name lm32)
+  (comment "LatticeMico32 ISA")
+  (default-insn-word-bitsize 32)
+  (default-insn-bitsize 32)
+  (base-insn-bitsize 32)
+  (decode-assist (31 30 29 28 27 26))
+)
+
+
+; Cpu family definitions.
+
+(define-cpu
+  ; cpu names must be distinct from the architecture name and machine name
+  (name lm32bf)
+  (comment "LatticeMico32 CPU")
+  (endian big)
+  (word-bitsize 32)
+)
+
+(define-mach
+  (name lm32)
+  (comment "LatticeMico32 MACH")
+  (cpu lm32bf)
+)
+
+(define-model
+  (name lm32)
+  (comment "LatticeMico32 reference implementation")
+  (mach lm32)
+  (unit u-exec "Execution unit" ()
+    1 1 () () () ())
+) 
+
+
+; Hardware elements.
+
+(dnh h-pc "Program counter" (PC) (pc) () () ())
+
+(dnh h-gr "General purpose registers"
+  ()
+  (register SI (32))
+  (keyword "" ( 
+               (gp 26) (fp 27) (sp 28) (ra 29) (ea 30) (ba 31)
+               (r0 0) (r1 1) (r2 2) (r3 3)
+               (r4 4) (r5 5) (r6 6) (r7 7)
+               (r8 8) (r9 9) (r10 10) (r11 11)
+               (r12 12) (r13 13) (r14 14) (r15 15)
+               (r16 16) (r17 17) (r18 18) (r19 19)
+               (r20 20) (r21 21) (r22 22) (r23 23)
+               (r24 24) (r25 25) (r26 26) (r27 27)
+               (r28 28) (r29 29) (r30 30) (r31 31)                
+              )
+  )
+  () ()
+)
+  
+(dnh h-csr "Control and status registers"
+  ()
+  (register SI (32))
+  (keyword "" (
+               (IE 0) (IM 1) (IP 2) 
+               (ICC 3) (DCC 4)
+               (CC 5)
+               (CFG 6)
+               (EBA 7)
+               (DC 8)
+               (DEBA 9)
+               (JTX 14) (JRX 15)          
+               (BP0 16) (BP1 17) (BP2 18) (BP3 19)
+               (WP0 24) (WP1 25) (WP2 26) (WP3 27)     
+              )
+  )
+  () ()
+)              
+  
+
+; Instruction fields.
+
+(dnf f-opcode   "opcode field"                () 31  6)
+(dnf f-r0       "register index 0 field"      () 25  5)
+(dnf f-r1       "register index 1 field"      () 20  5)
+(dnf f-r2       "register index 2 field"      () 15  5)
+(dnf f-resv0    "reserved"                    (RESERVED) 10 11)
+(dnf f-shift    "shift amount field"          ()  4  5)
+(df  f-imm      "signed immediate field"      () 15 16 INT #f #f)
+(dnf f-uimm     "unsigned immediate field"    () 15 16)
+(dnf f-csr      "csr field"                   () 25  5)
+(dnf f-user     "user defined field"          () 10 11)
+(dnf f-exception "exception field"            () 25 26)
+
+(df f-branch "branch offset field" (PCREL-ADDR) 15 16 INT
+        ((value pc) (sra SI (sub SI value pc) 2))
+        ((value pc) (add SI pc (sra SI (sll SI value 16) 14)))
+)
+(df f-call "call offset field" (PCREL-ADDR) 25 26 INT 
+        ((value pc) (sra SI (sub SI value pc) 2))
+        ((value pc) (add SI pc (sra SI (sll SI value 6) 4)))
+)
+
+
+; Operands.
+
+(dnop r0        "register 0"            () h-gr         f-r0)
+(dnop r1        "register 1"            () h-gr         f-r1)
+(dnop r2        "register 2"            () h-gr         f-r2)
+(dnop shift     "shift amout"           () h-uint       f-shift)
+(dnop imm       "signed immediate"      () h-sint       f-imm)
+(dnop uimm      "unsigned immediate"    () h-uint       f-uimm)
+(dnop branch    "branch offset"         () h-iaddr      f-branch)
+(dnop call      "call offset"           () h-iaddr      f-call)
+(dnop csr       "csr"                   () h-csr        f-csr)
+(dnop user      "user"                  () h-uint       f-user)
+(dnop exception "exception"             () h-uint       f-exception)
+            
+(define-operand
+  (name hi16)
+  (comment "high 16-bit immediate")
+  (attrs)
+  (type h-uint)
+  (index f-uimm)
+  (handlers (parse "hi16"))
+)
+
+(define-operand
+  (name lo16)
+  (comment "low 16-bit immediate")
+  (attrs)
+  (type h-uint)
+  (index f-uimm)
+  (handlers (parse "lo16"))
+)
+
+(define-operand
+  (name gp16)
+  (comment "gp relative 16-bit immediate")
+  (attrs)
+  (type h-sint)
+  (index f-imm)
+  (handlers (parse "gp16"))
+)
+
+(define-operand
+  (name got16)
+  (comment "got relative 16-bit immediate")
+  (attrs)
+  (type h-sint)
+  (index f-imm)
+  (handlers (parse "got16"))
+)
+
+
+; Enumerations.
+
+(define-normal-insn-enum
+  opcodes "opcodes" () OP_ f-opcode
+  (("ADD"       45)      
+   ("ADDI"      13)      
+   ("AND"       40)
+   ("ANDI"      8)
+   ("ANDHI"     24)
+   ("B"         48)
+   ("BI"        56)
+   ("BE"        17)
+   ("BG"        18)
+   ("BGE"       19)
+   ("BGEU"      20)
+   ("BGU"       21)
+   ("BNE"       23)
+   ("CALL"      54)
+   ("CALLI"     62)
+   ("CMPE"      57)
+   ("CMPEI"     25)
+   ("CMPG"      58)
+   ("CMPGI"     26)
+   ("CMPGE"     59)
+   ("CMPGEI"    27)
+   ("CMPGEU"    60)
+   ("CMPGEUI"   28)
+   ("CMPGU"     61)
+   ("CMPGUI"    29)
+   ("CMPNE"     63)
+   ("CMPNEI"    31)
+   ("DIVU"      35)
+   ("LB"        4)
+   ("LBU"       16)
+   ("LH"        7)
+   ("LHU"       11)
+   ("LW"        10)
+   ("MODU"      49)
+   ("MUL"       34)
+   ("MULI"      2)
+   ("NOR"       33)
+   ("NORI"      1)
+   ("OR"        46)
+   ("ORI"       14)
+   ("ORHI"      30)
+   ("RAISE"     43)
+   ("RCSR"      36)
+   ("SB"        12)
+   ("SEXTB"     44)
+   ("SEXTH"     55)
+   ("SH"        3)
+   ("SL"        47)
+   ("SLI"       15)
+   ("SR"        37)
+   ("SRI"       5)
+   ("SRU"       32)
+   ("SRUI"      0)
+   ("SUB"       50)
+   ("SW"        22)
+   ("USER"      51)
+   ("WCSR"      52)
+   ("XNOR"      41)
+   ("XNORI"     9)
+   ("XOR"       38)
+   ("XORI"      6)
+  )
+)
+ 
+
+; Instructions. Note: Reg-reg must come before reg-imm.
+
+(dni add "add" ()
+        "add $r2,$r0,$r1"
+        (+ OP_ADD r0 r1 r2 (f-resv0 0))
+        (set r2 (add r0 r1))
+        ()
+)
+
+(dni addi "add immediate" ()
+        "addi $r1,$r0,$imm"  
+        (+ OP_ADDI r0 r1 imm)
+        (set r1 (add r0 (ext SI (trunc HI imm))))
+        ()
+)
+
+(dni and "and" ()
+        "and $r2,$r0,$r1"
+        (+ OP_AND r0 r1 r2 (f-resv0 0))
+        (set r2 (and r0 r1))
+        ()
+)
+
+(dni andi "and immediate" ()
+        "andi $r1,$r0,$uimm"  
+        (+ OP_ANDI r0 r1 uimm)
+        (set r1 (and r0 (zext SI uimm)))
+        ()
+)
+
+(dni andhii "and high immediate" ()
+        "andhi $r1,$r0,$hi16"  
+        (+ OP_ANDHI r0 r1 hi16)
+        (set r1 (and r0 (sll SI hi16 16)))
+        ()
+)
+
+(dni b "branch" ()
+        "b $r0"
+        (+ OP_B r0 (f-r1 0) (f-r2 0) (f-resv0 0))
+        (set pc (c-call USI "@cpu@_b_insn" r0 f-r0))
+        ()
+)
+
+(dni bi "branch immediate" ()
+        "bi $call"
+        (+ OP_BI call)
+        (set pc (ext SI call))
+        ()
+)
+
+(dni be "branch equal" ()
+        "be $r0,$r1,$branch"
+        (+ OP_BE r0 r1 branch)
+        (if (eq r0 r1)
+            (set pc branch)
+        )
+        ()
+)
+
+(dni bg "branch greater" ()
+        "bg $r0,$r1,$branch"
+        (+ OP_BG r0 r1 branch)
+        (if (gt r0 r1)
+            (set pc branch)
+        )
+        ()
+)
+
+(dni bge "branch greater or equal" ()
+        "bge $r0,$r1,$branch"
+        (+ OP_BGE r0 r1 branch)
+        (if (ge r0 r1)
+            (set pc branch)
+        )
+        ()
+)
+
+(dni bgeu "branch greater or equal unsigned" ()
+        "bgeu $r0,$r1,$branch"
+        (+ OP_BGEU r0 r1 branch)
+        (if (geu r0 r1)
+            (set pc branch)
+        )
+        ()
+)
+
+(dni bgu "branch greater unsigned" ()
+        "bgu $r0,$r1,$branch"
+        (+ OP_BGU r0 r1 branch)
+        (if (gtu r0 r1)
+            (set pc branch)
+        )
+        ()
+)
+
+(dni bne "branch not equal" ()
+        "bne $r0,$r1,$branch"
+        (+ OP_BNE r0 r1 branch)
+        (if (ne r0 r1)
+            (set pc branch)
+        )
+        ()
+)
+
+(dni call "call" ()
+        "call $r0"
+        (+ OP_CALL r0 (f-r1 0) (f-r2 0) (f-resv0 0))
+        (sequence ()
+                (set (reg h-gr 29) (add pc 4))
+                (set pc r0) 
+        )
+        ()
+)
+
+(dni calli "call immediate" ()
+        "calli $call"
+        (+ OP_CALLI call)
+        (sequence ()
+                (set (reg h-gr 29) (add pc 4))
+                (set pc (ext SI call)) 
+        )
+        ()
+)
+
+(dni cmpe "compare equal" ()
+        "cmpe $r2,$r0,$r1"  
+        (+ OP_CMPE r0 r1 r2 (f-resv0 0))
+        (set r2 (eq SI r0 r1))
+        ()
+)
+
+(dni cmpei "compare equal immediate" ()
+        "cmpei $r1,$r0,$imm"  
+        (+ OP_CMPEI r0 r1 imm)
+        (set r1 (eq SI r0 (ext SI (trunc HI imm))))
+        ()
+)
+
+(dni cmpg "compare greater than" ()
+        "cmpg $r2,$r0,$r1"  
+        (+ OP_CMPG r0 r1 r2 (f-resv0 0))
+        (set r2 (gt SI r0 r1))
+        ()
+)
+
+(dni cmpgi "compare greater than immediate" ()
+        "cmpgi $r1,$r0,$imm"  
+        (+ OP_CMPGI r0 r1 imm)
+        (set r1 (gt SI r0 (ext SI (trunc HI imm))))
+        ()
+)
+
+(dni cmpge "compare greater or equal" ()
+        "cmpge $r2,$r0,$r1"  
+        (+ OP_CMPGE r0 r1 r2 (f-resv0 0))
+        (set r2 (ge SI r0 r1))
+        ()
+)
+
+(dni cmpgei "compare greater or equal immediate" ()
+        "cmpgei $r1,$r0,$imm"  
+        (+ OP_CMPGEI r0 r1 imm)
+        (set r1 (ge SI r0 (ext SI (trunc HI imm))))
+        ()
+)
+
+(dni cmpgeu "compare greater or equal unsigned" ()
+        "cmpgeu $r2,$r0,$r1"  
+        (+ OP_CMPGEU r0 r1 r2 (f-resv0 0))
+        (set r2 (geu SI r0 r1))
+        ()
+)
+
+(dni cmpgeui "compare greater or equal unsigned immediate" ()
+        "cmpgeui $r1,$r0,$uimm"  
+        (+ OP_CMPGEUI r0 r1 uimm)
+        (set r1 (geu SI r0 (zext SI uimm)))
+        ()
+)
+
+(dni cmpgu "compare greater than unsigned" ()
+        "cmpgu $r2,$r0,$r1"  
+        (+ OP_CMPGU r0 r1 r2 (f-resv0 0))
+        (set r2 (gtu SI r0 r1))
+        ()
+)
+
+(dni cmpgui "compare greater than unsigned immediate" ()
+        "cmpgui $r1,$r0,$uimm"  
+        (+ OP_CMPGUI r0 r1 uimm)
+        (set r1 (gtu SI r0 (zext SI uimm)))
+        ()
+)
+
+(dni cmpne "compare not equal" ()
+        "cmpne $r2,$r0,$r1"  
+        (+ OP_CMPNE r0 r1 r2 (f-resv0 0))
+        (set r2 (ne SI r0 r1))
+        ()
+)
+
+(dni cmpnei "compare not equal immediate" ()
+        "cmpnei $r1,$r0,$imm"  
+        (+ OP_CMPNEI r0 r1 imm)
+        (set r1 (ne SI r0 (ext SI (trunc HI imm))))
+        ()
+)
+
+(dni divu "unsigned divide" ()
+        "divu $r2,$r0,$r1"
+        (+ OP_DIVU r0 r1 r2 (f-resv0 0))
+        (set pc (c-call USI "@cpu@_divu_insn" pc f-r0 f-r1 f-r2))
+        ()
+)
+
+(dni lb "load byte" ()
+        "lb $r1,($r0+$imm)"
+        (+ OP_LB r0 r1 imm)
+        (set r1 (ext SI (mem QI (add r0 (ext SI (trunc HI imm))))))
+        ()
+)
+
+(dni lbu "load byte unsigned" ()
+        "lbu $r1,($r0+$imm)"
+        (+ OP_LBU r0 r1 imm)
+        (set r1 (zext SI (mem QI (add r0 (ext SI (trunc HI imm))))))
+        ()
+)
+
+(dni lh "load halfword" ()
+        "lh $r1,($r0+$imm)"
+        (+ OP_LH r0 r1 imm)
+        (set r1 (ext SI (mem HI (add r0 (ext SI (trunc HI imm))))))
+        ()
+)
+
+(dni lhu "load halfword unsigned" ()
+        "lhu $r1,($r0+$imm)"
+        (+ OP_LHU r0 r1 imm)
+        (set r1 (zext SI (mem HI (add r0 (ext SI (trunc HI imm))))))
+        ()
+)
+
+(dni lw "load word" ()
+        "lw $r1,($r0+$imm)"
+        (+ OP_LW r0 r1 imm)
+        (set r1 (mem SI (add r0 (ext SI (trunc HI imm)))))
+        ()
+)
+
+(dni modu "unsigned modulus" ()
+        "modu $r2,$r0,$r1"
+        (+ OP_MODU r0 r1 r2 (f-resv0 0))
+        (set pc (c-call USI "@cpu@_modu_insn" pc f-r0 f-r1 f-r2))
+        ()
+)
+
+(dni mul "mulitply" ()
+        "mul $r2,$r0,$r1"
+        (+ OP_MUL r0 r1 r2 (f-resv0 0))
+        (set r2 (mul r0 r1))
+        ()
+)
+
+(dni muli "multiply immediate" ()
+        "muli $r1,$r0,$imm"  
+        (+ OP_MULI r0 r1 imm)
+        (set r1 (mul r0 (ext SI (trunc HI imm))))
+        ()
+)
+
+(dni nor "nor" ()
+        "nor $r2,$r0,$r1"
+        (+ OP_NOR r0 r1 r2 (f-resv0 0))
+        (set r2 (inv (or r0 r1)))
+        ()
+)
+
+(dni nori "nor immediate" ()
+        "nori $r1,$r0,$uimm"  
+        (+ OP_NORI r0 r1 uimm)
+        (set r1 (inv (or r0 (zext SI uimm))))
+        ()
+)
+
+(dni or "or" ()
+        "or $r2,$r0,$r1"
+        (+ OP_OR r0 r1 r2 (f-resv0 0))
+        (set r2 (or r0 r1))
+        ()
+)
+
+(dni ori "or immediate" ()
+        "ori $r1,$r0,$lo16"  
+        (+ OP_ORI r0 r1 lo16)
+        (set r1 (or r0 (zext SI lo16)))
+        ()
+)
+
+(dni orhii "or high immediate" ()
+        "orhi $r1,$r0,$hi16"  
+        (+ OP_ORHI r0 r1 hi16)
+        (set r1 (or r0 (sll SI hi16 16)))
+        ()
+)
+
+(dni rcsr "read control or status register" ()
+        "rcsr $r2,$csr"
+        (+ OP_RCSR csr (f-r1 0) r2 (f-resv0 0))
+        (set r2 csr) 
+        ()
+)
+
+(dni sb "store byte" ()
+        "sb ($r0+$imm),$r1"
+        (+ OP_SB r0 r1 imm)
+        (set (mem QI (add r0 (ext SI (trunc HI imm)))) r1)
+        ()
+)
+
+(dni sextb "sign extend byte" ()
+        "sextb $r2,$r0"
+        (+ OP_SEXTB r0 (f-r1 0) r2 (f-resv0 0))
+        (set r2 (ext SI (trunc QI r0)))
+        ()
+)
+
+(dni sexth "sign extend half-word" ()
+        "sexth $r2,$r0"
+        (+ OP_SEXTH r0 (f-r1 0) r2 (f-resv0 0))
+        (set r2 (ext SI (trunc HI r0)))
+        ()
+)
+
+(dni sh "store halfword" ()
+        "sh ($r0+$imm),$r1"
+        (+ OP_SH r0 r1 imm)
+        (set (mem HI (add r0 (ext SI (trunc HI imm)))) r1)
+        ()
+)
+
+(dni sl "shift left" ()
+        "sl $r2,$r0,$r1"
+        (+ OP_SL r0 r1 r2 (f-resv0 0))
+        (set r2 (sll SI r0 r1))
+        ()
+)
+
+(dni sli "shift left immediate" ()
+        "sli $r1,$r0,$imm"  
+        (+ OP_SLI r0 r1 imm)
+        (set r1 (sll SI r0 imm))
+        ()
+)
+
+(dni sr "shift right" ()
+        "sr $r2,$r0,$r1"
+        (+ OP_SR r0 r1 r2 (f-resv0 0))
+        (set r2 (sra SI r0 r1))
+        ()
+)
+
+(dni sri "shift right immediate" ()
+        "sri $r1,$r0,$imm"  
+        (+ OP_SRI r0 r1 imm)
+        (set r1 (sra SI r0 imm))
+        ()
+)
+
+(dni sru "shift right unsigned" ()
+        "sru $r2,$r0,$r1"
+        (+ OP_SRU r0 r1 r2 (f-resv0 0))
+        (set r2 (srl SI r0 r1))
+        ()
+)
+
+(dni srui "shift right unsigned immediate" ()
+        "srui $r1,$r0,$imm"  
+        (+ OP_SRUI r0 r1 imm)
+        (set r1 (srl SI r0 imm))
+        ()
+)
+
+(dni sub "subtract" ()
+        "sub $r2,$r0,$r1"
+        (+ OP_SUB r0 r1 r2 (f-resv0 0))
+        (set r2 (sub r0 r1))
+        ()
+)
+
+(dni sw "store word" ()
+        "sw ($r0+$imm),$r1"
+        (+ OP_SW r0 r1 imm)
+        (set (mem SI (add r0 (ext SI (trunc HI imm)))) r1)
+        ()
+)
+
+(dni user "user defined instruction" ()
+        "user $r2,$r0,$r1,$user"
+        (+ OP_USER r0 r1 r2 user)
+        (set r2 (c-call SI "@cpu@_user_insn" r0 r1 user))
+        ()
+)
+
+(dni wcsr "write control or status register" ()
+        "wcsr $csr,$r1"
+        (+ OP_WCSR csr r1 (f-r2 0) (f-resv0 0))
+        (c-call VOID "@cpu@_wcsr_insn" f-csr r1) 
+        ()
+)
+    
+(dni xor "xor" ()
+        "xor $r2,$r0,$r1"
+        (+ OP_XOR r0 r1 r2 (f-resv0 0))
+        (set r2 (xor r0 r1))
+        ()
+)
+
+(dni xori "xor immediate" ()
+        "xori $r1,$r0,$uimm"  
+        (+ OP_XORI r0 r1 uimm)
+        (set r1 (xor r0 (zext SI uimm)))
+        ()
+)
+
+(dni xnor "xnor" ()
+        "xnor $r2,$r0,$r1"
+        (+ OP_XNOR r0 r1 r2 (f-resv0 0))
+        (set r2 (inv (xor r0 r1)))
+        ()
+)
+
+(dni xnori "xnor immediate" ()
+        "xnori $r1,$r0,$uimm"  
+        (+ OP_XNORI r0 r1 uimm)
+        (set r1 (inv (xor r0 (zext SI uimm))))
+        ()
+)
+
+; Pseudo instructions
+
+(dni break "breakpoint" ()
+        "break"
+        (+ OP_RAISE (f-exception 2))
+        (set pc (c-call USI "@cpu@_break_insn" pc))
+        ()
+)
+
+(dni scall "system call" ()
+        "scall"
+        (+ OP_RAISE (f-exception 7))
+        (set pc (c-call USI "@cpu@_scall_insn" pc))
+        ()
+)
+
+(dni bret "return from breakpoint" (ALIAS)
+        "bret"
+        (+ OP_B (f-r0 31) (f-r1 0) (f-r2 0) (f-resv0 0))
+        (set pc (c-call USI "@cpu@_bret_insn" r0))
+        ()
+)
+
+(dni eret "return from exception" (ALIAS)
+        "eret"
+        (+ OP_B (f-r0 30) (f-r1 0) (f-r2 0) (f-resv0 0))
+        (set pc (c-call USI "@cpu@_eret_insn" r0))
+        ()
+)
+    
+(dni ret "return" (ALIAS)
+        "ret"
+        (+ OP_B (f-r0 29) (f-r1 0) (f-r2 0) (f-resv0 0))
+        (set pc r0)
+        ()
+)
+
+(dni mv "move" (ALIAS)
+        "mv $r2,$r0"
+        (+ OP_OR r0 (f-r1 0) r2 (f-resv0 0))
+        (set r2 r0)
+        ()
+)
+
+(dni mvi "move immediate" (ALIAS)
+        "mvi $r1,$imm"
+        (+ OP_ADDI (f-r0 0) r1 imm)
+        (set r1 (add r0 (ext SI (trunc HI imm))))
+        ()
+)
+
+(dni mvui "move unsigned immediate" (ALIAS)
+        "mvu $r1,$lo16"
+        (+ OP_ORI (f-r0 0) r1 lo16)
+        (set r1 (zext SI lo16))
+        ()
+)
+
+(dni mvhi "move high immediate" (ALIAS)
+        "mvhi $r1,$hi16"
+        (+ OP_ORHI (f-r0 0) r1 hi16)
+        (set r1 (or r0 (sll SI hi16 16)))
+        ()
+)
+
+(dni mva "move address" (ALIAS)
+        "mva $r1,$gp16"
+        (+ OP_ADDI (f-r0 26) r1 gp16)
+        (set r1 (add r0 (ext SI (trunc HI gp16))))
+        ()
+)
+
+(dni not "not" (ALIAS)
+        "not $r2,$r0"
+        (+ OP_XNOR r0 (f-r1 0) r2 (f-resv0 0))
+        (set r2 (inv r0))
+        ()
+)
+
+(dni nop "nop" (ALIAS)
+        "nop"
+        (+ OP_ADDI (f-r0 0) (f-r1 0) (f-imm 0))
+        (set r0 r0)
+        ()
+)
+
+(dni lbgprel "load byte gp relative" (ALIAS)
+        "lb $r1,$gp16"
+        (+ OP_LB (f-r0 26) r1 gp16)
+        (set r1 (ext SI (mem QI (add r0 (ext SI (trunc HI gp16))))))
+        ()
+)
+
+(dni lbugprel "load byte unsigned gp relative" (ALIAS)
+        "lbu $r1,$gp16"
+        (+ OP_LBU (f-r0 26) r1 gp16)
+        (set r1 (zext SI (mem QI (add r0 (ext SI (trunc HI gp16))))))
+        ()
+)
+
+(dni lhgprel "load halfword gp relative" (ALIAS)
+        "lh $r1,$gp16"
+        (+ OP_LH (f-r0 26) r1 gp16)
+        (set r1 (ext SI (mem HI (add r0 (ext SI (trunc HI gp16))))))
+        ()
+)
+
+(dni lhugprel "load halfword unsigned gp relative" (ALIAS)
+        "lhu $r1,$gp16"
+        (+ OP_LHU (f-r0 26) r1 gp16)
+        (set r1 (zext SI (mem HI (add r0 (ext SI (trunc HI gp16))))))
+        ()
+)
+
+(dni lwgprel "load word gp relative" (ALIAS)
+        "lw $r1,$gp16"
+        (+ OP_LW (f-r0 26) r1 gp16)
+        (set r1 (mem SI (add r0 (ext SI (trunc HI gp16)))))
+        ()
+)
+
+(dni sbgprel "store byte gp relative" (ALIAS)
+        "sb $gp16,$r1"
+        (+ OP_SB (f-r0 26) r1 gp16)
+        (set (mem QI (add r0 (ext SI (trunc HI gp16)))) r1)
+        ()
+)
+
+(dni shgprel "store halfword gp relative" (ALIAS)
+        "sh $gp16,$r1"
+        (+ OP_SH (f-r0 26) r1 gp16)
+        (set (mem HI (add r0 (ext SI (trunc HI gp16)))) r1)
+        ()
+)
+
+(dni swgprel "store word gp relative" (ALIAS)
+        "sw $gp16,$r1"
+        (+ OP_SW (f-r0 26) r1 gp16)
+        (set (mem SI (add r0 (ext SI (trunc HI gp16)))) r1)
+        ()
+)
+
+(dni lwgotrel "load word got relative" (ALIAS)
+        "lw $r1,(gp+$got16)"
+        (+ OP_LW (f-r0 26) r1 gp16)
+        (set r1 (mem SI (add r0 (ext SI (trunc HI gp16)))))
+        ()
+)
diff --git a/cpu/lm32.opc b/cpu/lm32.opc
new file mode 100644
index 0000000..8fd3f32
--- /dev/null
+++ b/cpu/lm32.opc
@@ -0,0 +1,186 @@
+/* LatticeMico32 opcode support.  -*- C -*-
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+/* -- opc.h */
+
+/* Allows reason codes to be output when assembler errors occur.  */
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+#define CGEN_DIS_HASH_SIZE 64
+#define CGEN_DIS_HASH(buf,value) ((value >> 26) & 0x3f) 
+
+/* -- asm.c */
+
+static const char * parse_imm  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
+static const char * parse_hi16 PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
+static const char * parse_lo16 PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
+static const char * parse_gp16 PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
+static const char * parse_got16 PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
+
+/* Handle signed/unsigned literal.  */
+
+static const char *
+parse_imm (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     unsigned long *valuep;
+{
+  const char *errmsg;
+  unsigned long value;
+
+  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
+  if (errmsg == NULL)
+    {
+      unsigned long x = value & 0xFFFF0000;
+      if (x != 0 && x != 0xFFFF0000)
+        errmsg = _("immediate value out of range");
+      else
+        *valuep = (value & 0xFFFF);
+    }
+  return errmsg;
+}
+
+/* Handle hi() */
+
+static const char *
+parse_hi16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     unsigned long *valuep;
+{
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+      const char *errmsg;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value >>= 16;
+      *valuep = value;
+
+      return errmsg;
+    }
+
+  return parse_imm (cd, strp, opindex, valuep);
+}
+
+/* Handle lo() */
+
+static const char *
+parse_lo16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     long *valuep;
+{
+  if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      const char *errmsg;
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+
+  return parse_imm (cd, strp, opindex, valuep);
+}
+
+/* Handle gp() */
+
+static const char *
+parse_gp16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     long *valuep;
+{
+  if (strncasecmp (*strp, "gp(", 3) == 0)
+    {
+      const char *errmsg;
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_GPREL16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+
+  return _("expecting gp relative address: gp(symbol)");
+}
+
+/* Handle got() */
+
+static const char *
+parse_got16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     long *valuep;
+{
+  if (strncasecmp (*strp, "got(", 4) == 0)
+    {
+      const char *errmsg;
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LM32_16_GOT,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+
+  return _("expecting got relative address: got(symbol)");
+}
diff --git a/gas/Makefile.am b/gas/Makefile.am
index f2a3611..3173e61 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -64,6 +64,7 @@ CPU_TYPES = \
 	i960 \
 	ia64 \
 	ip2k \
+	lm32 \
 	m32c \
 	m32r \
 	m68hc11 \
@@ -258,6 +259,7 @@ TARGET_CPU_CFILES = \
 	config/tc-i860.c \
 	config/tc-i960.c \
 	config/tc-ip2k.c \
+	config/tc-lm32.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
 	config/tc-m68hc11.c \
@@ -313,6 +315,7 @@ TARGET_CPU_HFILES = \
 	config/tc-i860.h \
 	config/tc-i960.h \
 	config/tc-ip2k.h \
+	config/tc-lm32.h \
 	config/tc-m32c.h \
 	config/tc-m32r.h \
 	config/tc-m68hc11.h \
@@ -1171,6 +1174,13 @@ DEPTC_ip2k_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/opcode/cgen-bitset.h $(srcdir)/../opcodes/ip2k-opc.h \
   cgen.h $(INCDIR)/elf/common.h $(INCDIR)/elf/ip2k.h \
   $(INCDIR)/elf/reloc-macros.h $(BFDDIR)/libbfd.h $(INCDIR)/hashtab.h
+DEPTC_lm32_elf = $(INCDIR)/symcat.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-lm32.h \
+  $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
+  $(srcdir)/../opcodes/lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  $(srcdir)/../opcodes/lm32-opc.h cgen.h $(INCDIR)/elf/lm32.h \
+  $(INCDIR)/elf/reloc-macros.h
 DEPTC_m32c_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-m32c.h dwarf2dbg.h \
@@ -1597,6 +1607,11 @@ DEPOBJ_ip2k_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-ip2k.h dwarf2dbg.h \
   $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
   $(INCDIR)/obstack.h struc-symbol.h dwarf2dbg.h $(INCDIR)/aout/aout64.h
+DEPOBJ_lm32_elf = $(INCDIR)/symcat.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-lm32.h \
+  $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
+  struc-symbol.h dwarf2dbg.h $(INCDIR)/aout/aout64.h
 DEPOBJ_m32c_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-m32c.h dwarf2dbg.h \
@@ -1942,6 +1957,9 @@ DEP_ip2k_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-ip2k.h dwarf2dbg.h \
   $(srcdir)/config/obj-coff.h $(INCDIR)/coff/internal.h \
   $(BFDDIR)/libcoff.h
+DEP_lm32_elf = $(srcdir)/config/obj-elf.h $(INCDIR)/symcat.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-lm32.h
 DEP_m32c_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-m32c.h dwarf2dbg.h \
diff --git a/gas/Makefile.in b/gas/Makefile.in
index 1c5958d..5548cdb 100644
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -309,6 +309,7 @@ CPU_TYPES = \
 	i960 \
 	ia64 \
 	ip2k \
+	lm32 \
 	m32c \
 	m32r \
 	m68hc11 \
@@ -501,6 +502,7 @@ TARGET_CPU_CFILES = \
 	config/tc-i860.c \
 	config/tc-i960.c \
 	config/tc-ip2k.c \
+	config/tc-lm32.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
 	config/tc-m68hc11.c \
@@ -556,6 +558,7 @@ TARGET_CPU_HFILES = \
 	config/tc-i860.h \
 	config/tc-i960.h \
 	config/tc-ip2k.h \
+	config/tc-lm32.h \
 	config/tc-m32c.h \
 	config/tc-m32r.h \
 	config/tc-m68hc11.h \
@@ -963,6 +966,14 @@ DEPTC_ip2k_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   cgen.h $(INCDIR)/elf/common.h $(INCDIR)/elf/ip2k.h \
   $(INCDIR)/elf/reloc-macros.h $(BFDDIR)/libbfd.h $(INCDIR)/hashtab.h
 
+DEPTC_lm32_elf = $(INCDIR)/symcat.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-lm32.h \
+  $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
+  $(srcdir)/../opcodes/lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  $(srcdir)/../opcodes/lm32-opc.h cgen.h $(INCDIR)/elf/lm32.h \
+  $(INCDIR)/elf/reloc-macros.h
+
 DEPTC_m32c_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-m32c.h dwarf2dbg.h \
@@ -1469,6 +1480,12 @@ DEPOBJ_ip2k_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
   $(INCDIR)/obstack.h struc-symbol.h dwarf2dbg.h $(INCDIR)/aout/aout64.h
 
+DEPOBJ_lm32_elf = $(INCDIR)/symcat.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-lm32.h \
+  $(INCDIR)/safe-ctype.h subsegs.h $(INCDIR)/obstack.h \
+  struc-symbol.h dwarf2dbg.h $(INCDIR)/aout/aout64.h
+
 DEPOBJ_m32c_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-m32c.h dwarf2dbg.h \
@@ -1894,6 +1911,10 @@ DEP_ip2k_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(srcdir)/config/obj-coff.h $(INCDIR)/coff/internal.h \
   $(BFDDIR)/libcoff.h
 
+DEP_lm32_elf = $(srcdir)/config/obj-elf.h $(INCDIR)/symcat.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-lm32.h
+
 DEP_m32c_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-m32c.h dwarf2dbg.h \
diff --git a/gas/config/tc-lm32.c b/gas/config/tc-lm32.c
new file mode 100644
index 0000000..ed26794
--- /dev/null
+++ b/gas/config/tc-lm32.c
@@ -0,0 +1,424 @@
+/* tc-lm32.c - LatticeMico32 assembler.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with GAS; see the file COPYING.  If not, write to the Free Software
+   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "bfd.h"
+#include "safe-ctype.h"
+#include "opcodes/lm32-desc.h"
+#include "opcodes/lm32-opc.h"
+#include "cgen.h"
+#include "elf/lm32.h"
+
+typedef struct
+{
+  const CGEN_INSN *insn;
+  const CGEN_INSN *orig_insn;
+  CGEN_FIELDS fields;
+#if CGEN_INT_INSN_P
+  CGEN_INSN_INT buffer [1];
+#define INSN_VALUE(buf) (*(buf))
+#else
+  unsigned char buffer[CGEN_MAX_INSN_SIZE];
+#define INSN_VALUE(buf) (buf)
+#endif
+  char *addr;
+  fragS *frag;
+  int num_fixups;
+  fixS *fixups[GAS_CGEN_MAX_FIXUPS];
+  int indices[MAX_OPERAND_INSTANCES];
+} lm32_insn;
+
+/* Configuration options */
+
+#define LM_CFG_MULTIPLIY_ENABLED        0x0001
+#define LM_CFG_DIVIDE_ENABLED           0x0002
+#define LM_CFG_BARREL_SHIFT_ENABLED     0x0004
+#define LM_CFG_SIGN_EXTEND_ENABLED      0x0008
+#define LM_CFG_USER_ENABLED             0x0010
+#define LM_CFG_ICACHE_ENABLED           0x0020
+#define LM_CFG_DCACHE_ENABLED           0x0040
+#define LM_CFG_BREAK_ENABLED            0x0080
+
+static unsigned config = 0U;
+
+/* Target specific assembler tokens / delimiters */
+
+const char comment_chars[]        = "#";      
+const char line_comment_chars[]   = "#";
+const char line_separator_chars[] = ";";
+const char EXP_CHARS[]            = "eE";
+const char FLT_CHARS[]            = "dD";
+
+/* Target specific assembly directives */ 
+
+const pseudo_typeS md_pseudo_table[] =
+{
+  { "align",   s_align_bytes,       0 },
+  { "byte",    cons,                1 },
+  { "hword",   cons,                2 },
+  { "word",    cons,                4 },
+  { "dword",   cons,                8 },
+  {(char *)0 , (void(*)(int))0,     0}
+};
+
+/* Target specific command line options */
+
+const char * md_shortopts = "";
+
+struct option md_longopts[] =
+{
+#define OPTION_MULTIPLY_ENABLED         (OPTION_MD_BASE + 1)
+  { "mmultiply-enabled",            no_argument, NULL, OPTION_MULTIPLY_ENABLED },
+#define OPTION_DIVIDE_ENABLED           (OPTION_MD_BASE + 2)
+  { "mdivide-enabled",              no_argument, NULL, OPTION_DIVIDE_ENABLED },
+#define OPTION_BARREL_SHIFT_ENABLED     (OPTION_MD_BASE + 3)
+  { "mbarrel-shift-enabled",        no_argument, NULL, OPTION_BARREL_SHIFT_ENABLED },  
+#define OPTION_SIGN_EXTEND_ENABLED      (OPTION_MD_BASE + 4)
+  { "msign-extend-enabled",         no_argument, NULL, OPTION_SIGN_EXTEND_ENABLED },  
+#define OPTION_USER_ENABLED             (OPTION_MD_BASE + 5)
+  { "muser-enabled",                no_argument, NULL, OPTION_USER_ENABLED },
+#define OPTION_ICACHE_ENABLED           (OPTION_MD_BASE + 6)
+  { "micache-enabled",              no_argument, NULL, OPTION_ICACHE_ENABLED },
+#define OPTION_DCACHE_ENABLED           (OPTION_MD_BASE + 7)
+  { "mdcache-enabled",              no_argument, NULL, OPTION_DCACHE_ENABLED },
+#define OPTION_BREAK_ENABLED            (OPTION_MD_BASE + 8)
+  { "mbreak-enabled",               no_argument, NULL, OPTION_BREAK_ENABLED },
+#define OPTION_ALL_ENABLED              (OPTION_MD_BASE + 9)
+  { "mall-enabled",                 no_argument, NULL, OPTION_ALL_ENABLED },
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+/* Display architecture specific options */
+void
+md_show_usage (fp)
+     FILE * fp;
+{
+  fprintf (fp, "LM32 specific options:\n"
+        "  -mmultiply-enabled          enable multiply instructions\n"
+        "  -mdivide-enabled            enable divide and modulus instructions\n"
+        "  -mbarrel-shift-enabled      enable multi-bit shift instructions\n"
+        "  -msign-extend-enabled       enable sign-extension instructions\n"
+        "  -muser-enabled              enable user-defined instructions\n"
+        "  -micache-enabled            enable instruction cache instructions\n"
+        "  -mdcache-enabled            enable data cache instructions\n"
+        "  -mbreak-enabled             enable the break instruction\n"
+        "  -mall-enabled               enable all optional instructions\n"
+        );
+}
+
+/* Parse command line options */
+int
+md_parse_option (c, arg)
+     int    c;
+     char * arg ATTRIBUTE_UNUSED;
+{ 
+  switch (c)
+    {    
+      case OPTION_MULTIPLY_ENABLED:
+        config |= LM_CFG_MULTIPLIY_ENABLED;
+        break;
+      case OPTION_DIVIDE_ENABLED:
+        config |= LM_CFG_DIVIDE_ENABLED;
+        break;
+      case OPTION_BARREL_SHIFT_ENABLED:
+        config |= LM_CFG_BARREL_SHIFT_ENABLED;
+        break;
+      case OPTION_SIGN_EXTEND_ENABLED:
+        config |= LM_CFG_SIGN_EXTEND_ENABLED;
+        break;
+      case OPTION_USER_ENABLED:
+        config |= LM_CFG_USER_ENABLED;
+        break;
+      case OPTION_ICACHE_ENABLED:
+        config |= LM_CFG_ICACHE_ENABLED;
+        break;
+      case OPTION_DCACHE_ENABLED:
+        config |= LM_CFG_DCACHE_ENABLED;
+        break;
+      case OPTION_BREAK_ENABLED:
+        config |= LM_CFG_BREAK_ENABLED;
+        break;
+      case OPTION_ALL_ENABLED:
+        config |= LM_CFG_MULTIPLIY_ENABLED;
+        config |= LM_CFG_DIVIDE_ENABLED;
+        config |= LM_CFG_BARREL_SHIFT_ENABLED;
+        config |= LM_CFG_SIGN_EXTEND_ENABLED;
+        config |= LM_CFG_USER_ENABLED;
+        config |= LM_CFG_ICACHE_ENABLED;
+        config |= LM_CFG_DCACHE_ENABLED;
+        config |= LM_CFG_BREAK_ENABLED;
+        break;        
+      default:
+        return 0;
+    }
+  return 1;
+}
+
+/* Do any architecture specific initialisation */
+void
+md_begin (void)
+{
+  /* Initialize the `cgen' interface.  */
+  
+  /* Set the machine number and endian.  */
+  gas_cgen_cpu_desc = lm32_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
+					   CGEN_CPU_OPEN_ENDIAN,
+					   CGEN_ENDIAN_BIG,
+					   CGEN_CPU_OPEN_END);
+  lm32_cgen_init_asm (gas_cgen_cpu_desc);
+
+  /* This is a callback from cgen to gas to parse operands.  */
+  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);
+}
+
+/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
+   for use in the a.out file, and stores them in the array pointed to by buf. */
+void
+md_number_to_chars (buf, val, n)
+     char * buf;
+     valueT val;
+     int    n;
+{
+  if (target_big_endian)
+    number_to_chars_bigendian (buf, val, n);
+  else    
+    number_to_chars_littleendian (buf, val, n);
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+   of type TYPE, and store the appropriate bytes in *LITP.  The number
+   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
+   returned, or NULL on OK.  */
+char *
+md_atof (type, litP, sizeP)
+     int type;
+     char *litP;
+     int *sizeP;
+{
+  int i;
+  int prec;
+  LITTLENUM_TYPE words[4];
+
+  char *t;
+
+  switch (type)
+    {
+    case 'f':
+      prec = 2;
+      break;
+    case 'd':
+      prec = 4;
+      break;
+    default:
+      *sizeP = 0;
+      return _("bad call to md_atof");
+    }
+
+  t = atof_ieee (input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+
+  *sizeP = prec * sizeof (LITTLENUM_TYPE);
+
+  if (target_big_endian)
+    {
+      for (i = 0; i < prec; i++)
+	{
+	  md_number_to_chars (litP, (valueT) words[i],
+			      sizeof (LITTLENUM_TYPE));
+	  litP += sizeof (LITTLENUM_TYPE);
+	}
+    }
+  else
+    {
+      for (i = prec - 1; i >= 0; i--)
+	{
+	  md_number_to_chars (litP, (valueT) words[i],
+			      sizeof (LITTLENUM_TYPE));
+	  litP += sizeof (LITTLENUM_TYPE);
+	}
+    }
+
+  return NULL;
+}
+
+/* Called for each undefined symbol. */
+symbolS *
+md_undefined_symbol (name)
+     char * name ATTRIBUTE_UNUSED;
+{
+  return 0;
+}       
+
+/* Round up a section size to the appropriate boundary.  */
+valueT
+md_section_align (seg, addr)
+     asection *seg;
+     valueT addr;
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  return ((addr + (1 << align) - 1) & (-1 << align));
+}
+
+/* This function assembles the instructions. It emits the frags/bytes to the 
+   sections and creates the relocation entries. */
+void
+md_assemble (str)
+     char * str;
+{
+  lm32_insn insn;
+  char * errmsg;
+  
+  /* Initialize GAS's cgen interface for a new instruction.  */
+  gas_cgen_init_parse ();
+
+  insn.insn = lm32_cgen_assemble_insn
+      (gas_cgen_cpu_desc, str, &insn.fields, insn.buffer, &errmsg);
+
+  if (!insn.insn)
+    {
+      as_bad ("%s", errmsg);
+      return;
+    }
+
+  gas_cgen_finish_insn (insn.insn, insn.buffer,
+			CGEN_FIELDS_BITSIZE (&insn.fields), 1, NULL);
+}
+
+/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
+   Returns BFD_RELOC_NONE if no reloc type can be found.
+   *FIXP may be modified if desired.  */
+bfd_reloc_code_real_type
+md_cgen_lookup_reloc (insn, operand, fixP)
+     const CGEN_INSN *insn ATTRIBUTE_UNUSED;
+     const CGEN_OPERAND *operand;
+     fixS *fixP ATTRIBUTE_UNUSED;
+{
+  switch (operand->type)
+    {
+    case LM32_OPERAND_GOT16:
+      return BFD_RELOC_LM32_16_GOT;
+    case LM32_OPERAND_GP16:
+      return BFD_RELOC_GPREL16;
+    case LM32_OPERAND_LO16:
+      return BFD_RELOC_LO16;
+    case LM32_OPERAND_HI16:
+      return BFD_RELOC_HI16;
+    case LM32_OPERAND_BRANCH: 
+      return BFD_RELOC_LM32_BRANCH; 
+    case LM32_OPERAND_CALL:
+      return BFD_RELOC_LM32_CALL;
+    default:    
+      break;
+    }
+  return BFD_RELOC_NONE;
+}
+
+/* Return the position from which the PC relative adjustment for a PC relative 
+   fixup should be made. */
+long 
+md_pcrel_from (fixP)
+     fixS *fixP;
+{
+  /* Shouldn't get called */
+  abort ();
+  /* Return address of current instruction */
+  return fixP->fx_where + fixP->fx_frag->fr_address;
+}
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+long
+md_pcrel_from_section (fixS * fixP, segT sec)
+{
+  if ((fixP->fx_addsy != (symbolS *) NULL)
+      && (! S_IS_DEFINED (fixP->fx_addsy)
+	  || (S_GET_SEGMENT (fixP->fx_addsy) != sec)))
+    {
+      /* The symbol is undefined (or is defined but not in this section).
+	 Let the linker figure it out.  */
+      return 0;
+    }
+
+  /*fprintf(stderr, "%s extern %d local %d\n", S_GET_NAME (fixP->fx_addsy), S_IS_EXTERN (fixP->fx_addsy), S_IS_LOCAL (fixP->fx_addsy));*/
+  /* FIXME: Weak problem? */
+  if ((fixP->fx_addsy != (symbolS *) NULL)
+      && S_IS_EXTERNAL (fixP->fx_addsy))
+    {
+      /* If the symbol is external, let the linker handle it */
+      return 0;
+    }
+
+  return fixP->fx_where + fixP->fx_frag->fr_address;
+}
+
+/* Return true if we can partially resolve a relocation now.  */
+
+bfd_boolean
+lm32_fix_adjustable (fixP)
+   fixS * fixP;
+{
+  /* We need the symbol name for the VTABLE entries */
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Relaxation isn't required/supported on this target */
+
+int
+md_estimate_size_before_relax (fragp, seg)
+     fragS *fragp ATTRIBUTE_UNUSED;
+     asection *seg ATTRIBUTE_UNUSED;
+{
+  abort ();
+  return 0;
+}
+
+void
+md_convert_frag (abfd, sec, fragP)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     asection *sec ATTRIBUTE_UNUSED;
+     fragS *fragP ATTRIBUTE_UNUSED;
+{
+  abort ();
+}
+
+void
+md_apply_fix (fixP, valP, seg)
+     fixS *   fixP;
+     valueT * valP;
+     segT     seg;
+{
+
+  /* Fix for weak symbols. Why do we have fx_addsy for weak symbols? */  
+  if (fixP->fx_addsy != NULL && S_IS_WEAK (fixP->fx_addsy))
+    *valP = 0;
+
+  gas_cgen_md_apply_fix (fixP, valP, seg);
+  return;
+}
diff --git a/gas/config/tc-lm32.h b/gas/config/tc-lm32.h
new file mode 100644
index 0000000..f095dd0
--- /dev/null
+++ b/gas/config/tc-lm32.h
@@ -0,0 +1,48 @@
+/* tc-lm32.h -- Header file for tc-lm32.c
+   Contributed by Jon Beniston <jon@beniston.com>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with GAS; see the file COPYING.  If not, write to the Free Software
+   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef TC_LM32_H
+#define TC_LM32_H
+
+#define TARGET_FORMAT "elf32-lm32"
+#define TARGET_ARCH bfd_arch_lm32
+#define TARGET_MACH bfd_mach_lm32
+
+#define TARGET_BYTES_BIG_ENDIAN 1
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+#define WORKING_DOT_WORD
+
+/* Values passed to md_apply_fix3 don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+#define md_operand(X)
+#define tc_gen_reloc gas_cgen_tc_gen_reloc
+
+/* Call md_pcrel_from_section(), not md_pcrel_from().  */
+extern long md_pcrel_from_section PARAMS ((struct fix *, segT));
+#define MD_PCREL_FROM_SECTION(FIXP, SEC) md_pcrel_from_section (FIXP, SEC)
+
+extern bfd_boolean lm32_fix_adjustable PARAMS ((struct fix *));
+#define tc_fix_adjustable(FIX) lm32_fix_adjustable (FIX)
+
+#endif /* TC_LM32_H */
+
diff --git a/gas/configure b/gas/configure
index d2cc2e7..d3e21d6 100755
--- a/gas/configure
+++ b/gas/configure
@@ -10158,7 +10158,7 @@ _ACEOF
         fi
         ;;
 
-      fr30 | ip2k | iq2000 | m32r | openrisc)
+      fr30 | ip2k | iq2000 | lm32 | m32r | openrisc)
 	using_cgen=yes
 	;;
 
diff --git a/gas/configure.in b/gas/configure.in
index 02e8e53..6f946c3 100644
--- a/gas/configure.in
+++ b/gas/configure.in
@@ -302,7 +302,7 @@ changequote([,])dnl
         fi
         ;;
 
-      fr30 | ip2k | iq2000 | m32r | openrisc)
+      fr30 | ip2k | iq2000 | lm32 | m32r | openrisc)
 	using_cgen=yes
 	;;
 
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 05603cc..92583b1 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -44,6 +44,7 @@ case ${cpu} in
   ia64)			cpu_type=ia64 ;;
   ip2k)			cpu_type=ip2k endian=big ;; 
   iq2000)		cpu_type=iq2000 endian=big ;; 
+  lm32)		        cpu_type=lm32 ;;
   m32c)			cpu_type=m32c endian=big ;;
   m32r)			cpu_type=m32r endian=big ;;
   m32rle)		cpu_type=m32r endian=little ;;
@@ -242,6 +243,8 @@ case ${generic_target} in
 
   m32c-*-elf)         			fmt=elf ;;
 
+  lm32-*-*)				fmt=elf ;;
+
   m32r-*-elf*)				fmt=elf ;;
   m32r-*-linux*)			fmt=elf em=linux;;
 
diff --git a/gas/testsuite/gas/lm32/all.exp b/gas/testsuite/gas/lm32/all.exp
new file mode 100644
index 0000000..5413680
--- /dev/null
+++ b/gas/testsuite/gas/lm32/all.exp
@@ -0,0 +1,6 @@
+# LatticeMico32 assembler testsuite.
+
+if [istarget lm32-*-*] {
+    run_dump_test "csr"
+    run_dump_test "insn"
+}
diff --git a/gas/testsuite/gas/lm32/csr.d b/gas/testsuite/gas/lm32/csr.d
new file mode 100644
index 0000000..d045b44
--- /dev/null
+++ b/gas/testsuite/gas/lm32/csr.d
@@ -0,0 +1,27 @@
+#as:
+#objdump: -d
+#name: csr
+
+dump.o:     file format elf32-lm32
+
+Disassembly of section .text:
+
+00000000 <.text>:
+   0:	d0 00 00 00 	wcsr IE,r0
+   4:	d0 1f 00 00 	wcsr IE,ba
+   8:	d0 20 00 00 	wcsr IM,r0
+   c:	d0 3f 00 00 	wcsr IM,ba
+  10:	d0 60 00 00 	wcsr ICC,r0
+  14:	d0 7f 00 00 	wcsr ICC,ba
+  18:	d0 80 00 00 	wcsr DCC,r0
+  1c:	d0 9f 00 00 	wcsr DCC,ba
+  20:	90 00 00 00 	rcsr r0,IE
+  24:	90 00 f8 00 	rcsr ba,IE
+  28:	90 20 00 00 	rcsr r0,IM
+  2c:	90 20 f8 00 	rcsr ba,IM
+  30:	90 40 00 00 	rcsr r0,IP
+  34:	90 40 f8 00 	rcsr ba,IP
+  38:	90 a0 00 00 	rcsr r0,CC
+  3c:	90 a0 f8 00 	rcsr ba,CC
+  40:	90 c0 00 00 	rcsr r0,CFG
+  44:	90 c0 f8 00 	rcsr ba,CFG
diff --git a/gas/testsuite/gas/lm32/csr.s b/gas/testsuite/gas/lm32/csr.s
new file mode 100644
index 0000000..6f3e17e
--- /dev/null
+++ b/gas/testsuite/gas/lm32/csr.s
@@ -0,0 +1,20 @@
+                
+        wcsr    IE, r0
+        wcsr    IE, r31
+        wcsr    IM, r0
+        wcsr    IM, r31
+        wcsr    ICC, r0
+        wcsr    ICC, r31
+        wcsr    DCC, r0
+        wcsr    DCC, r31
+        
+        rcsr    r0, IE
+        rcsr    r31, IE
+        rcsr    r0, IM
+        rcsr    r31, IM
+        rcsr    r0, IP
+        rcsr    r31, IP
+        rcsr    r0, CC
+        rcsr    r31, CC
+        rcsr    r0, CFG
+        rcsr    r31, CFG
diff --git a/gas/testsuite/gas/lm32/insn.d b/gas/testsuite/gas/lm32/insn.d
new file mode 100644
index 0000000..176d20f
--- /dev/null
+++ b/gas/testsuite/gas/lm32/insn.d
@@ -0,0 +1,257 @@
+#as:
+#objdump: -d
+#name: insn
+
+dump.o:     file format elf32-lm32
+
+Disassembly of section .text:
+
+00000000 <.text>:
+   0:	b4 00 f8 00 	add ba,r0,r0
+   4:	b7 e0 00 00 	add r0,ba,r0
+   8:	b4 1f 00 00 	add r0,r0,ba
+   c:	b4 43 08 00 	add r1,r2,r3
+  10:	34 00 00 00 	nop
+  14:	34 00 80 00 	mvi r0,-32768
+  18:	34 00 7f ff 	mvi r0,32767
+  1c:	37 e0 00 00 	addi r0,ba,0
+  20:	37 e0 80 00 	addi r0,ba,-32768
+  24:	37 e0 7f ff 	addi r0,ba,32767
+  28:	34 1f 00 00 	mvi ba,0
+  2c:	34 1f 80 00 	mvi ba,-32768
+  30:	34 1f 7f ff 	mvi ba,32767
+  34:	a0 00 f8 00 	and ba,r0,r0
+  38:	a3 e0 00 00 	and r0,ba,r0
+  3c:	a0 1f 00 00 	and r0,r0,ba
+  40:	a0 43 08 00 	and r1,r2,r3
+  44:	20 00 00 00 	andi r0,r0,0x0
+  48:	20 00 ff ff 	andi r0,r0,0xffff
+  4c:	23 e0 00 00 	andi r0,ba,0x0
+  50:	23 e0 ff ff 	andi r0,ba,0xffff
+  54:	20 1f 00 00 	andi ba,r0,0x0
+  58:	20 1f ff ff 	andi ba,r0,0xffff
+  5c:	60 00 00 00 	andhi r0,r0,0x0
+  60:	60 00 ff ff 	andhi r0,r0,0xffff
+  64:	63 e0 00 00 	andhi r0,ba,0x0
+  68:	63 e0 ff ff 	andhi r0,ba,0xffff
+  6c:	60 1f 00 00 	andhi ba,r0,0x0
+  70:	60 1f ff ff 	andhi ba,r0,0xffff
+  74:	60 00 00 00 	andhi r0,r0,0x0
+  78:	60 00 ff ff 	andhi r0,r0,0xffff
+  7c:	e0 00 00 00 	bi 0x7c
+  80:	c0 00 00 00 	b r0
+  84:	c3 e0 00 00 	bret
+  88:	44 00 00 00 	be r0,r0,0x88
+  8c:	44 22 00 00 	be r1,r2,0x8c
+  90:	48 00 00 00 	bg r0,r0,0x90
+  94:	48 22 00 00 	bg r1,r2,0x94
+  98:	4c 00 00 00 	bge r0,r0,0x98
+  9c:	4c 22 00 00 	bge r1,r2,0x9c
+  a0:	50 00 00 00 	bgeu r0,r0,0xa0
+  a4:	50 22 00 00 	bgeu r1,r2,0xa4
+  a8:	54 00 00 00 	bgu r0,r0,0xa8
+  ac:	54 22 00 00 	bgu r1,r2,0xac
+  b0:	5c 00 00 00 	bne r0,r0,0xb0
+  b4:	5c 22 00 00 	bne r1,r2,0xb4
+  b8:	f8 00 00 00 	calli 0xb8
+  bc:	d8 00 00 00 	call r0
+  c0:	db e0 00 00 	call ba
+  c4:	e4 00 f8 00 	cmpe ba,r0,r0
+  c8:	e7 e0 00 00 	cmpe r0,ba,r0
+  cc:	e4 1f 00 00 	cmpe r0,r0,ba
+  d0:	e4 43 08 00 	cmpe r1,r2,r3
+  d4:	64 00 00 00 	cmpei r0,r0,0
+  d8:	64 00 80 00 	cmpei r0,r0,-32768
+  dc:	64 00 7f ff 	cmpei r0,r0,32767
+  e0:	67 e0 00 00 	cmpei r0,ba,0
+  e4:	67 e0 80 00 	cmpei r0,ba,-32768
+  e8:	67 e0 7f ff 	cmpei r0,ba,32767
+  ec:	64 1f 00 00 	cmpei ba,r0,0
+  f0:	64 1f 80 00 	cmpei ba,r0,-32768
+  f4:	64 1f 7f ff 	cmpei ba,r0,32767
+  f8:	e8 00 f8 00 	cmpg ba,r0,r0
+  fc:	eb e0 00 00 	cmpg r0,ba,r0
+ 100:	e8 1f 00 00 	cmpg r0,r0,ba
+ 104:	e8 43 08 00 	cmpg r1,r2,r3
+ 108:	68 00 00 00 	cmpgi r0,r0,0
+ 10c:	68 00 80 00 	cmpgi r0,r0,-32768
+ 110:	68 00 7f ff 	cmpgi r0,r0,32767
+ 114:	6b e0 00 00 	cmpgi r0,ba,0
+ 118:	6b e0 80 00 	cmpgi r0,ba,-32768
+ 11c:	6b e0 7f ff 	cmpgi r0,ba,32767
+ 120:	68 1f 00 00 	cmpgi ba,r0,0
+ 124:	68 1f 80 00 	cmpgi ba,r0,-32768
+ 128:	68 1f 7f ff 	cmpgi ba,r0,32767
+ 12c:	ec 00 f8 00 	cmpge ba,r0,r0
+ 130:	ef e0 00 00 	cmpge r0,ba,r0
+ 134:	ec 1f 00 00 	cmpge r0,r0,ba
+ 138:	ec 43 08 00 	cmpge r1,r2,r3
+ 13c:	6c 00 00 00 	cmpgei r0,r0,0
+ 140:	6c 00 80 00 	cmpgei r0,r0,-32768
+ 144:	6c 00 7f ff 	cmpgei r0,r0,32767
+ 148:	6f e0 00 00 	cmpgei r0,ba,0
+ 14c:	6f e0 80 00 	cmpgei r0,ba,-32768
+ 150:	6f e0 7f ff 	cmpgei r0,ba,32767
+ 154:	6c 1f 00 00 	cmpgei ba,r0,0
+ 158:	6c 1f 80 00 	cmpgei ba,r0,-32768
+ 15c:	6c 1f 7f ff 	cmpgei ba,r0,32767
+ 160:	f0 00 f8 00 	cmpgeu ba,r0,r0
+ 164:	f3 e0 00 00 	cmpgeu r0,ba,r0
+ 168:	f0 1f 00 00 	cmpgeu r0,r0,ba
+ 16c:	f0 43 08 00 	cmpgeu r1,r2,r3
+ 170:	70 00 00 00 	cmpgeui r0,r0,0x0
+ 174:	70 00 ff ff 	cmpgeui r0,r0,0xffff
+ 178:	73 e0 00 00 	cmpgeui r0,ba,0x0
+ 17c:	73 e0 ff ff 	cmpgeui r0,ba,0xffff
+ 180:	70 1f 00 00 	cmpgeui ba,r0,0x0
+ 184:	70 1f ff ff 	cmpgeui ba,r0,0xffff
+ 188:	f4 00 f8 00 	cmpgu ba,r0,r0
+ 18c:	f7 e0 00 00 	cmpgu r0,ba,r0
+ 190:	f4 1f 00 00 	cmpgu r0,r0,ba
+ 194:	f4 43 08 00 	cmpgu r1,r2,r3
+ 198:	74 00 00 00 	cmpgui r0,r0,0x0
+ 19c:	74 00 ff ff 	cmpgui r0,r0,0xffff
+ 1a0:	77 e0 00 00 	cmpgui r0,ba,0x0
+ 1a4:	77 e0 ff ff 	cmpgui r0,ba,0xffff
+ 1a8:	74 1f 00 00 	cmpgui ba,r0,0x0
+ 1ac:	74 1f ff ff 	cmpgui ba,r0,0xffff
+ 1b0:	fc 00 f8 00 	cmpne ba,r0,r0
+ 1b4:	ff e0 00 00 	cmpne r0,ba,r0
+ 1b8:	fc 1f 00 00 	cmpne r0,r0,ba
+ 1bc:	fc 43 08 00 	cmpne r1,r2,r3
+ 1c0:	7c 00 00 00 	cmpnei r0,r0,0
+ 1c4:	7c 00 80 00 	cmpnei r0,r0,-32768
+ 1c8:	7c 00 7f ff 	cmpnei r0,r0,32767
+ 1cc:	7f e0 00 00 	cmpnei r0,ba,0
+ 1d0:	7f e0 80 00 	cmpnei r0,ba,-32768
+ 1d4:	7f e0 7f ff 	cmpnei r0,ba,32767
+ 1d8:	7c 1f 00 00 	cmpnei ba,r0,0
+ 1dc:	7c 1f 80 00 	cmpnei ba,r0,-32768
+ 1e0:	7c 1f 7f ff 	cmpnei ba,r0,32767
+ 1e4:	8c 00 f8 00 	divu ba,r0,r0
+ 1e8:	8f e0 00 00 	divu r0,ba,r0
+ 1ec:	8c 1f 00 00 	divu r0,r0,ba
+ 1f0:	8c 43 08 00 	divu r1,r2,r3
+ 1f4:	c4 00 f8 00 	modu ba,r0,r0
+ 1f8:	c7 e0 00 00 	modu r0,ba,r0
+ 1fc:	c4 1f 00 00 	modu r0,r0,ba
+ 200:	c4 43 08 00 	modu r1,r2,r3
+ 204:	88 00 f8 00 	mul ba,r0,r0
+ 208:	8b e0 00 00 	mul r0,ba,r0
+ 20c:	88 1f 00 00 	mul r0,r0,ba
+ 210:	88 43 08 00 	mul r1,r2,r3
+ 214:	08 00 00 00 	muli r0,r0,0
+ 218:	08 00 80 00 	muli r0,r0,-32768
+ 21c:	08 00 7f ff 	muli r0,r0,32767
+ 220:	0b e0 00 00 	muli r0,ba,0
+ 224:	0b e0 80 00 	muli r0,ba,-32768
+ 228:	0b e0 7f ff 	muli r0,ba,32767
+ 22c:	08 1f 00 00 	muli ba,r0,0
+ 230:	08 1f 80 00 	muli ba,r0,-32768
+ 234:	08 1f 7f ff 	muli ba,r0,32767
+ 238:	84 00 f8 00 	nor ba,r0,r0
+ 23c:	87 e0 00 00 	nor r0,ba,r0
+ 240:	84 1f 00 00 	nor r0,r0,ba
+ 244:	84 43 08 00 	nor r1,r2,r3
+ 248:	04 00 00 00 	nori r0,r0,0x0
+ 24c:	04 00 ff ff 	nori r0,r0,0xffff
+ 250:	07 e0 00 00 	nori r0,ba,0x0
+ 254:	07 e0 ff ff 	nori r0,ba,0xffff
+ 258:	04 1f 00 00 	nori ba,r0,0x0
+ 25c:	04 1f ff ff 	nori ba,r0,0xffff
+ 260:	b8 00 f8 00 	mv ba,r0
+ 264:	bb e0 00 00 	mv r0,ba
+ 268:	b8 1f 00 00 	or r0,r0,ba
+ 26c:	b8 43 08 00 	or r1,r2,r3
+ 270:	38 00 00 00 	mvu r0,0x0
+ 274:	38 00 ff ff 	mvu r0,0xffff
+ 278:	3b e0 00 00 	ori r0,ba,0x0
+ 27c:	3b e0 ff ff 	ori r0,ba,0xffff
+ 280:	38 1f 00 00 	mvu ba,0x0
+ 284:	38 1f ff ff 	mvu ba,0xffff
+ 288:	38 00 00 00 	mvu r0,0x0
+ 28c:	38 00 ff ff 	mvu r0,0xffff
+ 290:	78 00 00 00 	mvhi r0,0x0
+ 294:	78 00 ff ff 	mvhi r0,0xffff
+ 298:	7b e0 00 00 	orhi r0,ba,0x0
+ 29c:	7b e0 ff ff 	orhi r0,ba,0xffff
+ 2a0:	78 1f 00 00 	mvhi ba,0x0
+ 2a4:	78 1f ff ff 	mvhi ba,0xffff
+ 2a8:	78 00 00 00 	mvhi r0,0x0
+ 2ac:	78 00 ff ff 	mvhi r0,0xffff
+ 2b0:	bc 00 f8 00 	sl ba,r0,r0
+ 2b4:	bf e0 00 00 	sl r0,ba,r0
+ 2b8:	bc 1f 00 00 	sl r0,r0,ba
+ 2bc:	bc 43 08 00 	sl r1,r2,r3
+ 2c0:	94 00 f8 00 	sr ba,r0,r0
+ 2c4:	97 e0 00 00 	sr r0,ba,r0
+ 2c8:	94 1f 00 00 	sr r0,r0,ba
+ 2cc:	94 43 08 00 	sr r1,r2,r3
+ 2d0:	80 00 f8 00 	sru ba,r0,r0
+ 2d4:	83 e0 00 00 	sru r0,ba,r0
+ 2d8:	80 1f 00 00 	sru r0,r0,ba
+ 2dc:	80 43 08 00 	sru r1,r2,r3
+ 2e0:	3c 00 00 00 	sli r0,r0,0
+ 2e4:	3c 00 00 1f 	sli r0,r0,31
+ 2e8:	14 00 00 00 	sri r0,r0,0
+ 2ec:	14 00 00 1f 	sri r0,r0,31
+ 2f0:	00 00 00 00 	srui r0,r0,0
+ 2f4:	00 00 00 1f 	srui r0,r0,31
+ 2f8:	c8 00 f8 00 	sub ba,r0,r0
+ 2fc:	cb e0 00 00 	sub r0,ba,r0
+ 300:	c8 1f 00 00 	sub r0,r0,ba
+ 304:	c8 43 08 00 	sub r1,r2,r3
+ 308:	a4 00 f8 00 	not ba,r0
+ 30c:	a7 e0 00 00 	not r0,ba
+ 310:	a4 1f 00 00 	xnor r0,r0,ba
+ 314:	a4 43 08 00 	xnor r1,r2,r3
+ 318:	24 00 00 00 	xnori r0,r0,0x0
+ 31c:	24 00 ff ff 	xnori r0,r0,0xffff
+ 320:	27 e0 00 00 	xnori r0,ba,0x0
+ 324:	27 e0 ff ff 	xnori r0,ba,0xffff
+ 328:	24 1f 00 00 	xnori ba,r0,0x0
+ 32c:	24 1f ff ff 	xnori ba,r0,0xffff
+ 330:	98 00 f8 00 	xor ba,r0,r0
+ 334:	9b e0 00 00 	xor r0,ba,r0
+ 338:	98 1f 00 00 	xor r0,r0,ba
+ 33c:	98 43 08 00 	xor r1,r2,r3
+ 340:	18 00 00 00 	xori r0,r0,0x0
+ 344:	18 00 ff ff 	xori r0,r0,0xffff
+ 348:	1b e0 00 00 	xori r0,ba,0x0
+ 34c:	1b e0 ff ff 	xori r0,ba,0xffff
+ 350:	18 1f 00 00 	xori ba,r0,0x0
+ 354:	18 1f ff ff 	xori ba,r0,0xffff
+ 358:	b0 00 00 00 	sextb r0,r0
+ 35c:	b0 00 f8 00 	sextb ba,r0
+ 360:	b3 e0 00 00 	sextb r0,ba
+ 364:	b0 20 10 00 	sextb r2,r1
+ 368:	dc 00 00 00 	sexth r0,r0
+ 36c:	dc 00 f8 00 	sexth ba,r0
+ 370:	df e0 00 00 	sexth r0,ba
+ 374:	dc 20 10 00 	sexth r2,r1
+ 378:	10 00 00 00 	lb r0,\(r0\+0\)
+ 37c:	10 41 00 03 	lb r1,\(r2\+3\)
+ 380:	40 00 00 00 	lbu r0,\(r0\+0\)
+ 384:	40 41 00 03 	lbu r1,\(r2\+3\)
+ 388:	1c 00 00 00 	lh r0,\(r0\+0\)
+ 38c:	1c 41 00 03 	lh r1,\(r2\+3\)
+ 390:	2c 00 00 00 	lhu r0,\(r0\+0\)
+ 394:	2c 41 00 03 	lhu r1,\(r2\+3\)
+ 398:	28 00 00 00 	lw r0,\(r0\+0\)
+ 39c:	28 41 00 03 	lw r1,\(r2\+3\)
+ 3a0:	30 00 00 00 	sb \(r0\+0\),r0
+ 3a4:	30 23 00 02 	sb \(r1\+2\),r3
+ 3a8:	0c 00 00 00 	sh \(r0\+0\),r0
+ 3ac:	0c 23 00 02 	sh \(r1\+2\),r3
+ 3b0:	58 00 00 00 	sw \(r0\+0\),r0
+ 3b4:	58 23 00 02 	sw \(r1\+2\),r3
+ 3b8:	ac 00 00 02 	break
+ 3bc:	ac 00 00 07 	scall
+ 3c0:	c3 c0 00 00 	eret
+ 3c4:	c3 e0 00 00 	bret
+ 3c8:	c3 a0 00 00 	ret
+ 3cc:	34 00 00 00 	nop
+ 3d0:	b8 00 00 00 	mv r0,r0
+ 3d4:	78 00 00 00 	mvhi r0,0x0
+ 3d8:	78 00 00 00 	mvhi r0,0x0
+ 3dc:	a4 00 00 00 	not r0,r0
diff --git a/gas/testsuite/gas/lm32/insn.s b/gas/testsuite/gas/lm32/insn.s
new file mode 100644
index 0000000..50738c9
--- /dev/null
+++ b/gas/testsuite/gas/lm32/insn.s
@@ -0,0 +1,142 @@
+	.macro RegReg insn	
+	\insn	r31, r0, r0
+	\insn	r0, r31, r0
+	\insn	r0, r0, r31
+	\insn	r1, r2, r3
+	.endm
+
+	.macro RegImm insn
+	\insn	r0, r0, 0
+	\insn	r0, r0, -32768
+	\insn	r0, r0, 32767
+	\insn	r0, r31, 0
+	\insn 	r0, r31, -32768
+	\insn	r0, r31, 32767
+	\insn	r31, r0, 0
+	\insn	r31, r0, -32768
+	\insn	r31, r0, 32767
+	.endm
+
+	.macro RegUImm insn
+	\insn	r0, r0, 0
+	\insn	r0, r0, 65535
+	\insn	r0, r31, 0
+	\insn	r0, r31, 65535
+	\insn	r31, r0, 0
+	\insn	r31, r0, 65535
+	.endm
+
+	RegReg 	add
+	RegImm 	addi
+	RegReg 	and
+	RegUImm andi
+	RegUImm	andhi
+
+	andhi	r0, r0, hi(0x0000ffff)
+	andhi	r0, r0, hi(0xffff0000)
+
+	bi	label
+	b	r0
+	b	r31
+
+	be	r0, r0, label
+	be	r1, r2, label
+	bg	r0, r0, label
+	bg	r1, r2, label
+	bge	r0, r0, label
+	bge	r1, r2, label
+	bgeu	r0, r0, label
+	bgeu	r1, r2, label
+	bgu	r0, r0, label
+	bgu	r1, r2, label
+	bne	r0, r0, label
+	bne	r1, r2, label
+
+	calli	label
+	call	r0
+	call	r31
+
+	RegReg	cmpe
+	RegImm	cmpei
+	RegReg	cmpg
+	RegImm	cmpgi
+	RegReg	cmpge
+	RegImm	cmpgei
+	RegReg	cmpgeu
+	RegUImm	cmpgeui
+	RegReg	cmpgu
+	RegUImm	cmpgui
+	RegReg	cmpne
+	RegImm	cmpnei
+
+	RegReg	divu
+	RegReg	modu
+	RegReg	mul
+	RegImm	muli
+
+	RegReg	nor
+	RegUImm	nori
+	RegReg	or
+	RegUImm	ori
+	ori	r0, r0, lo(0xffff0000)
+	ori	r0, r0, lo(0x0000ffff)
+	RegUImm	orhi
+	orhi	r0, r0, hi(0x0000ffff)
+	orhi	r0, r0, hi(0xffff0000)
+
+	RegReg	sl
+	RegReg	sr
+	RegReg	sru
+
+	sli	r0, r0, 0
+	sli	r0, r0, 31
+	sri	r0, r0, 0
+	sri	r0, r0, 31
+	srui	r0, r0, 0
+	srui	r0, r0, 31
+
+	RegReg	sub
+
+	RegReg	xnor
+	RegUImm	xnori
+	RegReg	xor
+	RegUImm	xori
+
+    sextb   r0, r0
+    sextb   r31, r0
+    sextb   r0, r31
+    sextb   r2, r1
+    sexth   r0, r0
+    sexth   r31, r0
+    sexth   r0, r31
+    sexth   r2, r1
+
+	lb	r0, (r0+0)
+	lb	r1, (r2+3)
+	lbu	r0, (r0+0)
+ 	lbu 	r1, (r2+3)	
+	lh	r0, (r0+0)
+	lh	r1, (r2+3)
+	lhu	r0, (r0+0)
+	lhu 	r1, (r2+3)
+	lw	r0, (r0+0)
+	lw	r1, (r2+3)
+	sb	(r0+0), r0
+	sb	(r1+2), r3
+	sh	(r0+0), r0
+	sh	(r1+2), r3
+	sw	(r0+0), r0
+	sw	(r1+2), r3
+
+	break
+    scall
+
+	eret
+ 	bret
+
+	ret
+ 	mvi	r0, 0   
+	mv	r0, r0
+	mvhi   r0, 0
+	mvhi   r0, hi(0)
+	not	r0, r0
diff --git a/include/dis-asm.h b/include/dis-asm.h
index 40afe17..5477114 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -243,6 +243,7 @@ extern int print_insn_little_mips	(bfd_vma, disassemble_info *);
 extern int print_insn_little_or32	(bfd_vma, disassemble_info *);
 extern int print_insn_little_powerpc	(bfd_vma, disassemble_info *);
 extern int print_insn_little_score      (bfd_vma, disassemble_info *); 
+extern int print_insn_lm32		(bfd_vma, disassemble_info *);
 extern int print_insn_m32c	        (bfd_vma, disassemble_info *);
 extern int print_insn_m32r		(bfd_vma, disassemble_info *);
 extern int print_insn_m68hc11		(bfd_vma, disassemble_info *);
diff --git a/include/elf/common.h b/include/elf/common.h
index 5b71782..b2203c8 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -281,6 +281,9 @@
 /* NIOS magic number - no EABI available.  */
 #define EM_NIOS32		0xFEBB
 
+/* LatticeMico32 */
+#define EM_LM32                 138
+
 #define EM_CYGNUS_MEP		0xF00D  /* Toshiba MeP */
 
 /* See the above comment before you add a new EM_* value here.  */
diff --git a/include/elf/lm32.h b/include/elf/lm32.h
new file mode 100644
index 0000000..d3fc264
--- /dev/null
+++ b/include/elf/lm32.h
@@ -0,0 +1,53 @@
+/* LatticeMico32 ELF support for BFD.
+   Written by Jon Beniston <jon@beniston.com>
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software Foundation, Inc.,
+59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _ELF_LM32_H
+#define _ELF_LM32_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocations.  */
+START_RELOC_NUMBERS (elf_lm32_reloc_type)
+     RELOC_NUMBER (R_LM32_NONE,                      0)
+     RELOC_NUMBER (R_LM32_8,                         1)
+     RELOC_NUMBER (R_LM32_16,                        2)
+     RELOC_NUMBER (R_LM32_32,                        3)
+     RELOC_NUMBER (R_LM32_HI16,                      4)
+     RELOC_NUMBER (R_LM32_LO16,                      5)
+     RELOC_NUMBER (R_LM32_GPREL16,                   6)
+     RELOC_NUMBER (R_LM32_CALL,                      7)
+     RELOC_NUMBER (R_LM32_BRANCH,                    8)
+     RELOC_NUMBER (R_LM32_GNU_VTINHERIT,             9)
+     RELOC_NUMBER (R_LM32_GNU_VTENTRY,               10)
+     RELOC_NUMBER (R_LM32_16_GOT,                    11)
+     RELOC_NUMBER (R_LM32_COPY,                      12)
+     RELOC_NUMBER (R_LM32_GLOB_DAT,                  13)
+     RELOC_NUMBER (R_LM32_JMP_SLOT,                  14)
+     RELOC_NUMBER (R_LM32_RELATIVE,                  15)
+END_RELOC_NUMBERS (R_LM32_max)
+
+/* Processor specific flags for the ELF header e_flags field. */
+
+#define EF_LM32_MACH                 0x00000001
+
+/* Various CPU types */
+
+#define E_LM32_MACH                  0x1
+
+#endif /* _ELF_LM32_H */
diff --git a/ld/Makefile.am b/ld/Makefile.am
index 1f019b0..7911e0a 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -176,6 +176,7 @@ ALL_EMULATIONS = \
 	eelf32ip2k.o \
 	eelf32iq2000.o \
 	eelf32iq10.o \
+	eelf32lm32.o \
 	eelf32l4300.o \
 	eelf32lmip.o \
 	eelf32lppc.o \
@@ -911,6 +912,9 @@ eelf32iq2000.c: $(srcdir)/emulparams/elf32iq2000.sh \
 eelf32iq10.c: $(srcdir)/emulparams/elf32iq10.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32iq10 "$(tdir_iq10)"
+eelf32lm32.c: $(srcdir)/emulparams/elf32lm32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lm32 "$(tdir_elf32lm32)"
 eelf64alpha.c: $(srcdir)/emulparams/elf64alpha.sh \
   $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
diff --git a/ld/Makefile.in b/ld/Makefile.in
index 7587f27..e3c91cf 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -423,6 +423,7 @@ ALL_EMULATIONS = \
 	eelf32ip2k.o \
 	eelf32iq2000.o \
 	eelf32iq10.o \
+	eelf32lm32.o \
 	eelf32l4300.o \
 	eelf32lmip.o \
 	eelf32lppc.o \
@@ -1737,6 +1738,9 @@ eelf32iq2000.c: $(srcdir)/emulparams/elf32iq2000.sh \
 eelf32iq10.c: $(srcdir)/emulparams/elf32iq10.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32iq10 "$(tdir_iq10)"
+eelf32lm32.c: $(srcdir)/emulparams/elf32lm32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lm32 "$(tdir_elf32lm32)"
 eelf64alpha.c: $(srcdir)/emulparams/elf64alpha.sh \
   $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
diff --git a/ld/configure.tgt b/ld/configure.tgt
index d4f53ef..0d51053 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -296,6 +296,7 @@ ip2k-*-elf)		targ_emul=elf32ip2k
 			;;
 iq2000-*-elf)           targ_emul=elf32iq2000 ; targ_extra_emuls="elf32iq10"
 			;;
+lm32-*-*)               targ_emul=elf32lm32 ;;
 m32c-*-elf)		targ_emul=elf32m32c
 			;;
 m32r*le-*-elf*)         targ_emul=m32rlelf ;;
diff --git a/ld/emulparams/elf32lm32.sh b/ld/emulparams/elf32lm32.sh
new file mode 100644
index 0000000..b3fcd32
--- /dev/null
+++ b/ld/emulparams/elf32lm32.sh
@@ -0,0 +1,10 @@
+ARCH=lm32
+MACHINE=
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-lm32"
+MAXPAGESIZE=0x1000
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+TEXT_START_ADDR=0x0000
+DYNAMIC_LINK=FALSE
+ALIGNMENT=4
diff --git a/ld/scripttempl/elf.sc b/ld/scripttempl/elf.sc
index a59a884..f923c97 100644
--- a/ld/scripttempl/elf.sc
+++ b/ld/scripttempl/elf.sc
@@ -115,7 +115,11 @@ fi
 test -n "${DATA_PLT-${BSS_PLT-text}}" && TEXT_PLT=yes
 if test -z "$GOT"; then
   if test -z "$SEPARATE_GOTPLT"; then
-    GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.got) }"
+		if test "$LD_FLAG" = "r"; then
+			GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.got) }"
+		else
+			GOT=" __got_start = . ; .got          ${RELOCATING-0} : { *(.got.plt) *(.got) } __got_end = . ;"
+		fi
   else
     GOT=".got          ${RELOCATING-0} : { *(.got) }"
     GOTPLT=".got.plt      ${RELOCATING-0} : { *(.got.plt) }"
@@ -124,6 +128,13 @@ fi
 DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
 RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
 DATARELRO=".data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) }"
+
+if test "$LD_FLAG" = "r"; then 
+	DATARELRO=".data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) *(.data.rel* .gnu.linkonce.d.rel.*) }"
+else
+	DATARELRO="__data_rel_start = .; .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) *(.data.rel* .gnu.linkonce.d.rel.*) } __data_rel_end = .;"
+fi
+
 DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) }"
 if test -z "${NO_SMALL_DATA}"; then
   SBSS=".sbss         ${RELOCATING-0} :
@@ -246,12 +257,6 @@
    test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
 fi
 
-if test "$LD_FLAG" = "r"; then 
-	DATA_REL=".data.rel : { *(.data.rel) }"
-else
-	DATA_REL=" __data_rel_start = .; .data.rel : { *(.data.rel) } __data_rel_end = .;"
-fi
-
 cat <<EOF
 OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
 	      "${LITTLE_OUTPUT_FORMAT}")
@@ -429,8 +434,6 @@
 
   ${DATA_PLT+${PLT_BEFORE_GOT-${PLT}}}
 
-	${DATA_REL}
-
   .data         ${RELOCATING-0} :
   {
     ${RELOCATING+${DATA_START_SYMBOLS}}
diff --git a/ld/testsuite/ld-elf/merge.d b/ld/testsuite/ld-elf/merge.d
index bc5a7b2..ed3dfc9 100644
--- a/ld/testsuite/ld-elf/merge.d
+++ b/ld/testsuite/ld-elf/merge.d
@@ -3,7 +3,7 @@
 #objdump: -s
 #xfail: "arc-*-*" "avr-*-*" "bfin-*-*" "cris*-*-*" "crx-*-*" "d10v-*-*" "d30v-*-*"
 #xfail: "dlx-*-*" "fr30-*-*" "frv-*-*" "hppa*-*-*" "h8300-*-*" "score-*-*"
-#xfail: "i370-*-*" "i860-*-*" "i960-*-*" "ip2k-*-*" "iq2000-*-*"
+#xfail: "i370-*-*" "i860-*-*" "i960-*-*" "ip2k-*-*" "iq2000-*-*" "lm32-*-*"
 #xfail: "mcore-*-*" "mn102*-*-*" "mips*-*-*" "ms1-*-*" "msp430-*-*"
 #xfail: "or32-*-*" "pj-*-*" "sparc*-*-*" "vax-*-*" "xstormy16-*-*" "xtensa-*-*"
 
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index f2ca97f..4761264 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -440,6 +440,7 @@ CGEN_CPUS = fr30 frv ip2k m32c m32r mep mt openrisc xc16x xstormy16
 
 if CGEN_MAINT
 IP2K_DEPS = stamp-ip2k
+LM32_DEPS = stamp-lm32
 M32C_DEPS = stamp-m32c
 M32R_DEPS = stamp-m32r
 FR30_DEPS = stamp-fr30
@@ -452,6 +453,7 @@ XC16X_DEPS = stamp-xc16x
 XSTORMY16_DEPS = stamp-xstormy16
 else
 IP2K_DEPS =
+LM32_DEPS = 
 M32C_DEPS =
 M32R_DEPS =
 FR30_DEPS =
@@ -486,6 +488,12 @@ stamp-ip2k: $(CGENDEPS) $(CPUDIR)/ip2k.cpu $(CPUDIR)/ip2k.opc
 	$(MAKE) run-cgen arch=ip2k prefix=ip2k options= \
 		archfile=$(CPUDIR)/ip2k.cpu opcfile=$(CPUDIR)/ip2k.opc extrafiles=
 
+$(srcdir)lm32-desc.h $(srcdir)/lm32-desc.c $(srcdir)/lm32-opc.h $(srcdir)/lm32-opc.c $(srcdir)/lm32-ibld.c $(srcdir)/lm32-opinst.c $(srcdir)/lm32-asm.c $(srcdir)/lm32-dis.c: $(LM32_DEPS)
+	@true
+stamp-lm32: $(CGENDEPS) $(CPUDIR)/lm32.cpu $(CPUDIR)/lm32.opc
+	$(MAKE) run-cgen arch=lm32 prefix=lm32 options=opinst \
+		archfile=$(CPUDIR)/lm32.cpu opcfile=$(CPUDIR)/lm32.opc extrafiles=opinst
+
 $(srcdir)/m32c-desc.h $(srcdir)/m32c-desc.c $(srcdir)/m32c-opc.h $(srcdir)/m32c-opc.c $(srcdir)/m32c-ibld.c $(srcdir)/m32c-asm.c $(srcdir)/m32c-dis.c: $(M32C_DEPS)
 #	@true
 stamp-m32c: $(CGENDEPS) $(srcdir)/../cpu/m32c.cpu $(srcdir)/../cpu/m32c.opc
@@ -894,6 +902,26 @@ iq2000-opc.lo: iq2000-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   iq2000-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
   $(INCDIR)/symcat.h $(INCDIR)/opcode/cgen-bitset.h iq2000-opc.h \
   $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h
+lm32-asm.lo: lm32-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h opintl.h $(INCDIR)/xregex.h $(INCDIR)/xregex2.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
+lm32-desc.lo: lm32-desc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h opintl.h $(INCDIR)/libiberty.h $(INCDIR)/xregex.h \
+  $(INCDIR)/xregex2.h
+lm32-dis.lo: lm32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
+  lm32-desc.h $(INCDIR)/opcode/cgen.h lm32-opc.h opintl.h
+lm32-ibld.lo: lm32-ibld.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h \
+  $(INCDIR)/opcode/cgen.h lm32-opc.h opintl.h $(INCDIR)/safe-ctype.h
+lm32-opc.lo: lm32-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h $(INCDIR)/libiberty.h
+lm32-opinst.lo: lm32-opinst.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h
 m32c-asm.lo: m32c-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h $(INCDIR)/symcat.h \
   m32c-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index bbb5572..9d768fd 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -619,6 +619,8 @@ CGENDEPS = \
 CGEN_CPUS = fr30 frv ip2k m32c m32r mep mt openrisc xc16x xstormy16
 @CGEN_MAINT_FALSE@IP2K_DEPS = 
 @CGEN_MAINT_TRUE@IP2K_DEPS = stamp-ip2k
+@CGEN_MAINT_FALSE@LM32_DEPS = 
+@CGEN_MAINT_TRUE@LM32_DEPS = stamp-lm32
 @CGEN_MAINT_FALSE@M32C_DEPS = 
 @CGEN_MAINT_TRUE@M32C_DEPS = stamp-m32c
 @CGEN_MAINT_FALSE@M32R_DEPS = 
@@ -1038,6 +1040,12 @@ stamp-ip2k: $(CGENDEPS) $(CPUDIR)/ip2k.cpu $(CPUDIR)/ip2k.opc
 	$(MAKE) run-cgen arch=ip2k prefix=ip2k options= \
 		archfile=$(CPUDIR)/ip2k.cpu opcfile=$(CPUDIR)/ip2k.opc extrafiles=
 
+$(srcdir)lm32-desc.h $(srcdir)/lm32-desc.c $(srcdir)/lm32-opc.h $(srcdir)/lm32-opc.c $(srcdir)/lm32-ibld.c $(srcdir)/lm32-opinst.c $(srcdir)/lm32-asm.c $(srcdir)/lm32-dis.c: $(LM32_DEPS)
+	@true
+stamp-lm32: $(CGENDEPS) $(CPUDIR)/lm32.cpu $(CPUDIR)/lm32.opc
+	$(MAKE) run-cgen arch=lm32 prefix=lm32 options=opinst \
+		archfile=$(CPUDIR)/lm32.cpu opcfile=$(CPUDIR)/lm32.opc extrafiles=opinst
+
 $(srcdir)/m32c-desc.h $(srcdir)/m32c-desc.c $(srcdir)/m32c-opc.h $(srcdir)/m32c-opc.c $(srcdir)/m32c-ibld.c $(srcdir)/m32c-asm.c $(srcdir)/m32c-dis.c: $(M32C_DEPS)
 #	@true
 stamp-m32c: $(CGENDEPS) $(srcdir)/../cpu/m32c.cpu $(srcdir)/../cpu/m32c.opc
@@ -1445,6 +1453,26 @@ iq2000-opc.lo: iq2000-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   iq2000-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
   $(INCDIR)/symcat.h $(INCDIR)/opcode/cgen-bitset.h iq2000-opc.h \
   $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h
+lm32-asm.lo: lm32-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h opintl.h $(INCDIR)/xregex.h $(INCDIR)/xregex2.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
+lm32-desc.lo: lm32-desc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h opintl.h $(INCDIR)/libiberty.h $(INCDIR)/xregex.h \
+  $(INCDIR)/xregex2.h
+lm32-dis.lo: lm32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
+  lm32-desc.h $(INCDIR)/opcode/cgen.h lm32-opc.h opintl.h
+lm32-ibld.lo: lm32-ibld.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h \
+  $(INCDIR)/opcode/cgen.h lm32-opc.h opintl.h $(INCDIR)/safe-ctype.h
+lm32-opc.lo: lm32-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h $(INCDIR)/libiberty.h
+lm32-opinst.lo: lm32-opinst.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h lm32-desc.h $(INCDIR)/opcode/cgen.h \
+  lm32-opc.h
 m32c-asm.lo: m32c-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h $(INCDIR)/symcat.h \
   m32c-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
diff --git a/opcodes/configure b/opcodes/configure
index 97c6757..8107ee3 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -11437,6 +11437,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ia64_arch)		ta="$ta ia64-dis.lo ia64-opc.lo" ;;
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
         bfd_iq2000_arch)        ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+	bfd_lm32_arch)          ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
diff --git a/opcodes/configure.in b/opcodes/configure.in
index 104653f..2fdb330 100644
--- a/opcodes/configure.in
+++ b/opcodes/configure.in
@@ -177,6 +177,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ia64_arch)		ta="$ta ia64-dis.lo ia64-opc.lo" ;;
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
         bfd_iq2000_arch)        ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+	bfd_lm32_arch)          ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 66850a7..61d1ed7 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -46,6 +46,7 @@
 #define ARCH_ia64
 #define ARCH_ip2k
 #define ARCH_iq2000
+#define ARCH_lm32
 #define ARCH_m32c
 #define ARCH_m32r
 #define ARCH_m68hc11
@@ -223,6 +224,11 @@ disassembler (abfd)
       disassemble = print_insn_fr30;
       break;
 #endif
+#ifdef ARCH_lm32
+    case bfd_arch_lm32:
+      disassemble = print_insn_lm32;
+      break;
+#endif
 #ifdef ARCH_m32r
     case bfd_arch_m32r:
       disassemble = print_insn_m32r;
diff --git a/opcodes/lm32-asm.c b/opcodes/lm32-asm.c
new file mode 100644
index 0000000..5e6bc1a
--- /dev/null
+++ b/opcodes/lm32-asm.c
@@ -0,0 +1,692 @@
+/* Assembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-asm.in isn't
+
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2005, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "lm32-desc.h"
+#include "lm32-opc.h"
+#include "opintl.h"
+#include "xregex.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+static const char * parse_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, const char **, CGEN_FIELDS *);
+
+/* -- assembler routines inserted here.  */
+
+/* -- asm.c */
+
+static const char * parse_imm  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
+static const char * parse_hi16 PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
+static const char * parse_lo16 PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
+static const char * parse_gp16 PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
+static const char * parse_got16 PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
+
+/* Handle signed/unsigned literal.  */
+
+static const char *
+parse_imm (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     unsigned long *valuep;
+{
+  const char *errmsg;
+  unsigned long value;
+
+  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
+  if (errmsg == NULL)
+    {
+      unsigned long x = value & 0xFFFF0000;
+      if (x != 0 && x != 0xFFFF0000)
+        errmsg = _("immediate value out of range");
+      else
+        *valuep = (value & 0xFFFF);
+    }
+  return errmsg;
+}
+
+/* Handle hi() */
+
+static const char *
+parse_hi16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     unsigned long *valuep;
+{
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+      const char *errmsg;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value >>= 16;
+      *valuep = value;
+
+      return errmsg;
+    }
+
+  return parse_imm (cd, strp, opindex, valuep);
+}
+
+/* Handle lo() */
+
+static const char *
+parse_lo16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     long *valuep;
+{
+  if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      const char *errmsg;
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+
+  return parse_imm (cd, strp, opindex, valuep);
+}
+
+/* Handle gp() */
+
+static const char *
+parse_gp16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     long *valuep;
+{
+  if (strncasecmp (*strp, "gp(", 3) == 0)
+    {
+      const char *errmsg;
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_GPREL16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+
+  return _("expecting gp relative address: gp(symbol)");
+}
+
+/* Handle got() */
+
+static const char *
+parse_got16 (cd, strp, opindex, valuep)
+     CGEN_CPU_DESC cd;
+     const char **strp;
+     int opindex;
+     long *valuep;
+{
+  if (strncasecmp (*strp, "got(", 4) == 0)
+    {
+      const char *errmsg;
+      enum cgen_parse_operand_result result_type;
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LM32_16_GOT,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return _("missing `)'");
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+
+  return _("expecting got relative address: got(symbol)");
+}
+
+const char * lm32_cgen_parse_operand
+  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);
+
+/* Main entry point for operand parsing.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  */
+
+const char *
+lm32_cgen_parse_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   const char ** strp,
+			   CGEN_FIELDS * fields)
+{
+  const char * errmsg = NULL;
+  /* Used by scalar operands that still need to be parsed.  */
+  long junk ATTRIBUTE_UNUSED;
+
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      {
+        bfd_vma value = 0;
+        errmsg = cgen_parse_address (cd, strp, LM32_OPERAND_BRANCH, 0, NULL,  & value);
+        fields->f_branch = value;
+      }
+      break;
+    case LM32_OPERAND_CALL :
+      {
+        bfd_vma value = 0;
+        errmsg = cgen_parse_address (cd, strp, LM32_OPERAND_CALL, 0, NULL,  & value);
+        fields->f_call = value;
+      }
+      break;
+    case LM32_OPERAND_CSR :
+      errmsg = cgen_parse_keyword (cd, strp, & lm32_cgen_opval_h_csr, & fields->f_csr);
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_EXCEPTION, (unsigned long *) (& fields->f_exception));
+      break;
+    case LM32_OPERAND_GOT16 :
+      errmsg = parse_got16 (cd, strp, LM32_OPERAND_GOT16, (long *) (& fields->f_imm));
+      break;
+    case LM32_OPERAND_GP16 :
+      errmsg = parse_gp16 (cd, strp, LM32_OPERAND_GP16, (long *) (& fields->f_imm));
+      break;
+    case LM32_OPERAND_HI16 :
+      errmsg = parse_hi16 (cd, strp, LM32_OPERAND_HI16, (unsigned long *) (& fields->f_uimm));
+      break;
+    case LM32_OPERAND_IMM :
+      errmsg = cgen_parse_signed_integer (cd, strp, LM32_OPERAND_IMM, (long *) (& fields->f_imm));
+      break;
+    case LM32_OPERAND_LO16 :
+      errmsg = parse_lo16 (cd, strp, LM32_OPERAND_LO16, (unsigned long *) (& fields->f_uimm));
+      break;
+    case LM32_OPERAND_R0 :
+      errmsg = cgen_parse_keyword (cd, strp, & lm32_cgen_opval_h_gr, & fields->f_r0);
+      break;
+    case LM32_OPERAND_R1 :
+      errmsg = cgen_parse_keyword (cd, strp, & lm32_cgen_opval_h_gr, & fields->f_r1);
+      break;
+    case LM32_OPERAND_R2 :
+      errmsg = cgen_parse_keyword (cd, strp, & lm32_cgen_opval_h_gr, & fields->f_r2);
+      break;
+    case LM32_OPERAND_SHIFT :
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_SHIFT, (unsigned long *) (& fields->f_shift));
+      break;
+    case LM32_OPERAND_UIMM :
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_UIMM, (unsigned long *) (& fields->f_uimm));
+      break;
+    case LM32_OPERAND_USER :
+      errmsg = cgen_parse_unsigned_integer (cd, strp, LM32_OPERAND_USER, (unsigned long *) (& fields->f_user));
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while parsing.\n"), opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+cgen_parse_fn * const lm32_cgen_parse_handlers[] = 
+{
+  parse_insn_normal,
+};
+
+void
+lm32_cgen_init_asm (CGEN_CPU_DESC cd)
+{
+  lm32_cgen_init_opcode_table (cd);
+  lm32_cgen_init_ibld_table (cd);
+  cd->parse_handlers = & lm32_cgen_parse_handlers[0];
+  cd->parse_operand = lm32_cgen_parse_operand;
+#ifdef CGEN_ASM_INIT_HOOK
+CGEN_ASM_INIT_HOOK
+#endif
+}
+
+
+
+/* Regex construction routine.
+
+   This translates an opcode syntax string into a regex string,
+   by replacing any non-character syntax element (such as an
+   opcode) with the pattern '.*'
+
+   It then compiles the regex and stores it in the opcode, for
+   later use by lm32_cgen_assemble_insn
+
+   Returns NULL for success, an error message for failure.  */
+
+char * 
+lm32_cgen_build_insn_regex (CGEN_INSN *insn)
+{  
+  CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
+  const char *mnem = CGEN_INSN_MNEMONIC (insn);
+  char rxbuf[CGEN_MAX_RX_ELEMENTS];
+  char *rx = rxbuf;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+  int reg_err;
+
+  syn = CGEN_SYNTAX_STRING (CGEN_OPCODE_SYNTAX (opc));
+
+  /* Mnemonics come first in the syntax string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    return _("missing mnemonic in syntax string");
+  ++syn;
+
+  /* Generate a case sensitive regular expression that emulates case
+     insensitive matching in the "C" locale.  We cannot generate a case
+     insensitive regular expression because in Turkish locales, 'i' and 'I'
+     are not equal modulo case conversion.  */
+
+  /* Copy the literal mnemonic out of the insn.  */
+  for (; *mnem; mnem++)
+    {
+      char c = *mnem;
+
+      if (ISALPHA (c))
+	{
+	  *rx++ = '[';
+	  *rx++ = TOLOWER (c);
+	  *rx++ = TOUPPER (c);
+	  *rx++ = ']';
+	}
+      else
+	*rx++ = c;
+    }
+
+  /* Copy any remaining literals from the syntax string into the rx.  */
+  for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
+    {
+      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+	{
+	  char c = CGEN_SYNTAX_CHAR (* syn);
+
+	  switch (c) 
+	    {
+	      /* Escape any regex metacharacters in the syntax.  */
+	    case '.': case '[': case '\\': 
+	    case '*': case '^': case '$': 
+
+#ifdef CGEN_ESCAPE_EXTENDED_REGEX
+	    case '?': case '{': case '}': 
+	    case '(': case ')': case '*':
+	    case '|': case '+': case ']':
+#endif
+	      *rx++ = '\\';
+	      *rx++ = c;
+	      break;
+
+	    default:
+	      if (ISALPHA (c))
+		{
+		  *rx++ = '[';
+		  *rx++ = TOLOWER (c);
+		  *rx++ = TOUPPER (c);
+		  *rx++ = ']';
+		}
+	      else
+		*rx++ = c;
+	      break;
+	    }
+	}
+      else
+	{
+	  /* Replace non-syntax fields with globs.  */
+	  *rx++ = '.';
+	  *rx++ = '*';
+	}
+    }
+
+  /* Trailing whitespace ok.  */
+  * rx++ = '['; 
+  * rx++ = ' '; 
+  * rx++ = '\t'; 
+  * rx++ = ']'; 
+  * rx++ = '*'; 
+
+  /* But anchor it after that.  */
+  * rx++ = '$'; 
+  * rx = '\0';
+
+  CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
+  reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
+
+  if (reg_err == 0) 
+    return NULL;
+  else
+    {
+      static char msg[80];
+
+      regerror (reg_err, (regex_t *) CGEN_INSN_RX (insn), msg, 80);
+      regfree ((regex_t *) CGEN_INSN_RX (insn));
+      free (CGEN_INSN_RX (insn));
+      (CGEN_INSN_RX (insn)) = NULL;
+      return msg;
+    }
+}
+
+
+/* Default insn parser.
+
+   The syntax string is scanned and operands are parsed and stored in FIELDS.
+   Relocs are queued as we go via other callbacks.
+
+   ??? Note that this is currently an all-or-nothing parser.  If we fail to
+   parse the instruction, we return 0 and the caller will start over from
+   the beginning.  Backtracking will be necessary in parsing subexpressions,
+   but that can be handled there.  Not handling backtracking here may get
+   expensive in the case of the m68k.  Deal with later.
+
+   Returns NULL for success, an error message for failure.  */
+
+static const char *
+parse_insn_normal (CGEN_CPU_DESC cd,
+		   const CGEN_INSN *insn,
+		   const char **strp,
+		   CGEN_FIELDS *fields)
+{
+  /* ??? Runtime added insns not handled yet.  */
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const char *str = *strp;
+  const char *errmsg;
+  const char *p;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+#ifdef CGEN_MNEMONIC_OPERANDS
+  /* FIXME: wip */
+  int past_opcode_p;
+#endif
+
+  /* For now we assume the mnemonic is first (there are no leading operands).
+     We can parse it without needing to set up operand parsing.
+     GAS's input scrubber will ensure mnemonics are lowercase, but we may
+     not be called from GAS.  */
+  p = CGEN_INSN_MNEMONIC (insn);
+  while (*p && TOLOWER (*p) == TOLOWER (*str))
+    ++p, ++str;
+
+  if (* p)
+    return _("unrecognized instruction");
+
+#ifndef CGEN_MNEMONIC_OPERANDS
+  if (* str && ! ISSPACE (* str))
+    return _("unrecognized instruction");
+#endif
+
+  CGEN_INIT_PARSE (cd);
+  cgen_init_parse_operand (cd);
+#ifdef CGEN_MNEMONIC_OPERANDS
+  past_opcode_p = 0;
+#endif
+
+  /* We don't check for (*str != '\0') here because we want to parse
+     any trailing fake arguments in the syntax string.  */
+  syn = CGEN_SYNTAX_STRING (syntax);
+
+  /* Mnemonics come first for now, ensure valid string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    abort ();
+
+  ++syn;
+
+  while (* syn != 0)
+    {
+      /* Non operand chars must match exactly.  */
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	{
+	  /* FIXME: While we allow for non-GAS callers above, we assume the
+	     first char after the mnemonic part is a space.  */
+	  /* FIXME: We also take inappropriate advantage of the fact that
+	     GAS's input scrubber will remove extraneous blanks.  */
+	  if (TOLOWER (*str) == TOLOWER (CGEN_SYNTAX_CHAR (* syn)))
+	    {
+#ifdef CGEN_MNEMONIC_OPERANDS
+	      if (CGEN_SYNTAX_CHAR(* syn) == ' ')
+		past_opcode_p = 1;
+#endif
+	      ++ syn;
+	      ++ str;
+	    }
+	  else if (*str)
+	    {
+	      /* Syntax char didn't match.  Can't be this insn.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found `%c')"),
+		       CGEN_SYNTAX_CHAR(*syn), *str);
+	      return msg;
+	    }
+	  else
+	    {
+	      /* Ran out of input.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found end of instruction)"),
+		       CGEN_SYNTAX_CHAR(*syn));
+	      return msg;
+	    }
+	  continue;
+	}
+
+      /* We have an operand of some sort.  */
+      errmsg = cd->parse_operand (cd, CGEN_SYNTAX_FIELD (*syn),
+					  &str, fields);
+      if (errmsg)
+	return errmsg;
+
+      /* Done with this operand, continue with next one.  */
+      ++ syn;
+    }
+
+  /* If we're at the end of the syntax string, we're done.  */
+  if (* syn == 0)
+    {
+      /* FIXME: For the moment we assume a valid `str' can only contain
+	 blanks now.  IE: We needn't try again with a longer version of
+	 the insn and it is assumed that longer versions of insns appear
+	 before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
+      while (ISSPACE (* str))
+	++ str;
+
+      if (* str != '\0')
+	return _("junk at end of line"); /* FIXME: would like to include `str' */
+
+      return NULL;
+    }
+
+  /* We couldn't parse it.  */
+  return _("unrecognized instruction");
+}
+
+/* Main entry point.
+   This routine is called for each instruction to be assembled.
+   STR points to the insn to be assembled.
+   We assume all necessary tables have been initialized.
+   The assembled instruction, less any fixups, is stored in BUF.
+   Remember that if CGEN_INT_INSN_P then BUF is an int and thus the value
+   still needs to be converted to target byte order, otherwise BUF is an array
+   of bytes in target byte order.
+   The result is a pointer to the insn's entry in the opcode table,
+   or NULL if an error occured (an error message will have already been
+   printed).
+
+   Note that when processing (non-alias) macro-insns,
+   this function recurses.
+
+   ??? It's possible to make this cpu-independent.
+   One would have to deal with a few minor things.
+   At this point in time doing so would be more of a curiosity than useful
+   [for example this file isn't _that_ big], but keeping the possibility in
+   mind helps keep the design clean.  */
+
+const CGEN_INSN *
+lm32_cgen_assemble_insn (CGEN_CPU_DESC cd,
+			   const char *str,
+			   CGEN_FIELDS *fields,
+			   CGEN_INSN_BYTES_PTR buf,
+			   char **errmsg)
+{
+  const char *start;
+  CGEN_INSN_LIST *ilist;
+  const char *parse_errmsg = NULL;
+  const char *insert_errmsg = NULL;
+  int recognized_mnemonic = 0;
+
+  /* Skip leading white space.  */
+  while (ISSPACE (* str))
+    ++ str;
+
+  /* The instructions are stored in hashed lists.
+     Get the first in the list.  */
+  ilist = CGEN_ASM_LOOKUP_INSN (cd, str);
+
+  /* Keep looking until we find a match.  */
+  start = str;
+  for ( ; ilist != NULL ; ilist = CGEN_ASM_NEXT_INSN (ilist))
+    {
+      const CGEN_INSN *insn = ilist->insn;
+      recognized_mnemonic = 1;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+      /* Not usually needed as unsupported opcodes
+	 shouldn't be in the hash lists.  */
+      /* Is this insn supported by the selected cpu?  */
+      if (! lm32_cgen_insn_supported (cd, insn))
+	continue;
+#endif
+      /* If the RELAXED attribute is set, this is an insn that shouldn't be
+	 chosen immediately.  Instead, it is used during assembler/linker
+	 relaxation if possible.  */
+      if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED) != 0)
+	continue;
+
+      str = start;
+
+      /* Skip this insn if str doesn't look right lexically.  */
+      if (CGEN_INSN_RX (insn) != NULL &&
+	  regexec ((regex_t *) CGEN_INSN_RX (insn), str, 0, NULL, 0) == REG_NOMATCH)
+	continue;
+
+      /* Allow parse/insert handlers to obtain length of insn.  */
+      CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+      parse_errmsg = CGEN_PARSE_FN (cd, insn) (cd, insn, & str, fields);
+      if (parse_errmsg != NULL)
+	continue;
+
+      /* ??? 0 is passed for `pc'.  */
+      insert_errmsg = CGEN_INSERT_FN (cd, insn) (cd, insn, fields, buf,
+						 (bfd_vma) 0);
+      if (insert_errmsg != NULL)
+        continue;
+
+      /* It is up to the caller to actually output the insn and any
+         queued relocs.  */
+      return insn;
+    }
+
+  {
+    static char errbuf[150];
+#ifdef CGEN_VERBOSE_ASSEMBLER_ERRORS
+    const char *tmp_errmsg;
+
+    /* If requesting verbose error messages, use insert_errmsg.
+       Failing that, use parse_errmsg.  */
+    tmp_errmsg = (insert_errmsg ? insert_errmsg :
+		  parse_errmsg ? parse_errmsg :
+		  recognized_mnemonic ?
+		  _("unrecognized form of instruction") :
+		  _("unrecognized instruction"));
+
+    if (strlen (start) > 50)
+      /* xgettext:c-format */
+      sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
+    else 
+      /* xgettext:c-format */
+      sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
+#else
+    if (strlen (start) > 50)
+      /* xgettext:c-format */
+      sprintf (errbuf, _("bad instruction `%.50s...'"), start);
+    else 
+      /* xgettext:c-format */
+      sprintf (errbuf, _("bad instruction `%.50s'"), start);
+#endif
+      
+    *errmsg = errbuf;
+    return NULL;
+  }
+}
diff --git a/opcodes/lm32-desc.c b/opcodes/lm32-desc.c
new file mode 100644
index 0000000..8eb0104
--- /dev/null
+++ b/opcodes/lm32-desc.c
@@ -0,0 +1,1125 @@
+/* CPU data for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2007 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include <stdio.h>
+#include <stdarg.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "lm32-desc.h"
+#include "lm32-opc.h"
+#include "opintl.h"
+#include "libiberty.h"
+#include "xregex.h"
+
+/* Attributes.  */
+
+static const CGEN_ATTR_ENTRY bool_attr[] =
+{
+  { "#f", 0 },
+  { "#t", 1 },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =
+{
+  { "base", MACH_BASE },
+  { "lm32", MACH_LM32 },
+  { "max", MACH_MAX },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =
+{
+  { "lm32", ISA_LM32 },
+  { "max", ISA_MAX },
+  { 0, 0 }
+};
+
+const CGEN_ATTR_TABLE lm32_cgen_ifield_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "RESERVED", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE lm32_cgen_hardware_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "CACHE-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "PC", &bool_attr[0], &bool_attr[0] },
+  { "PROFILE", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE lm32_cgen_operand_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { "NEGATIVE", &bool_attr[0], &bool_attr[0] },
+  { "RELAX", &bool_attr[0], &bool_attr[0] },
+  { "SEM-ONLY", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE lm32_cgen_insn_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "ALIAS", &bool_attr[0], &bool_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "UNCOND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "COND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "SKIP-CTI", &bool_attr[0], &bool_attr[0] },
+  { "DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
+  { "RELAXABLE", &bool_attr[0], &bool_attr[0] },
+  { "RELAXED", &bool_attr[0], &bool_attr[0] },
+  { "NO-DIS", &bool_attr[0], &bool_attr[0] },
+  { "PBB", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+/* Instruction set variants.  */
+
+static const CGEN_ISA lm32_cgen_isa_table[] = {
+  { "lm32", 32, 32, 32, 32 },
+  { 0, 0, 0, 0, 0 }
+};
+
+/* Machine variants.  */
+
+static const CGEN_MACH lm32_cgen_mach_table[] = {
+  { "lm32", "lm32", MACH_LM32, 0 },
+  { 0, 0, 0, 0 }
+};
+
+static CGEN_KEYWORD_ENTRY lm32_cgen_opval_h_gr_entries[] =
+{
+  { "gp", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "ra", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "ea", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "ba", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD lm32_cgen_opval_h_gr =
+{
+  & lm32_cgen_opval_h_gr_entries[0],
+  38,
+  0, 0, 0, 0, ""
+};
+
+static CGEN_KEYWORD_ENTRY lm32_cgen_opval_h_csr_entries[] =
+{
+  { "IE", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "IM", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "IP", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "ICC", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "DCC", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "CC", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "CFG", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "EBA", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "DC", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "DEBA", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "JTX", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "JRX", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "BP0", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "BP1", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "BP2", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "BP3", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "WP0", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "WP1", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "WP2", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "WP3", 27, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD lm32_cgen_opval_h_csr =
+{
+  & lm32_cgen_opval_h_csr_entries[0],
+  20,
+  0, 0, 0, 0, ""
+};
+
+
+/* The hardware table.  */
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define A(a) (1 << CGEN_HW_##a)
+#else
+#define A(a) (1 << CGEN_HW_/**/a)
+#endif
+
+const CGEN_HW_ENTRY lm32_cgen_hw_table[] =
+{
+  { "h-memory", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-sint", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uint", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-addr", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-iaddr", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-pc", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PC), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-gr", HW_H_GR, CGEN_ASM_KEYWORD, (PTR) & lm32_cgen_opval_h_gr, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-csr", HW_H_CSR, CGEN_ASM_KEYWORD, (PTR) & lm32_cgen_opval_h_csr, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction field table.  */
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define A(a) (1 << CGEN_IFLD_##a)
+#else
+#define A(a) (1 << CGEN_IFLD_/**/a)
+#endif
+
+const CGEN_IFLD lm32_cgen_ifld_table[] =
+{
+  { LM32_F_NIL, "f-nil", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_ANYOF, "f-anyof", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_OPCODE, "f-opcode", 0, 32, 31, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_R0, "f-r0", 0, 32, 25, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_R1, "f-r1", 0, 32, 20, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_R2, "f-r2", 0, 32, 15, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_RESV0, "f-resv0", 0, 32, 10, 11, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_SHIFT, "f-shift", 0, 32, 4, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_IMM, "f-imm", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_UIMM, "f-uimm", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_CSR, "f-csr", 0, 32, 25, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_USER, "f-user", 0, 32, 10, 11, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_EXCEPTION, "f-exception", 0, 32, 25, 26, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_BRANCH, "f-branch", 0, 32, 15, 16, { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+  { LM32_F_CALL, "f-call", 0, 32, 25, 26, { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+  { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+
+/* multi ifield declarations */
+
+
+
+/* multi ifield definitions */
+
+
+/* The operand table.  */
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define A(a) (1 << CGEN_OPERAND_##a)
+#else
+#define A(a) (1 << CGEN_OPERAND_/**/a)
+#endif
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define OPERAND(op) LM32_OPERAND_##op
+#else
+#define OPERAND(op) LM32_OPERAND_/**/op
+#endif
+
+const CGEN_OPERAND lm32_cgen_operand_table[] =
+{
+/* pc: program counter */
+  { "pc", LM32_OPERAND_PC, HW_H_PC, 0, 0,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_NIL] } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* r0: register 0 */
+  { "r0", LM32_OPERAND_R0, HW_H_GR, 25, 5,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R0] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* r1: register 1 */
+  { "r1", LM32_OPERAND_R1, HW_H_GR, 20, 5,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R1] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* r2: register 2 */
+  { "r2", LM32_OPERAND_R2, HW_H_GR, 15, 5,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R2] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* shift: shift amout */
+  { "shift", LM32_OPERAND_SHIFT, HW_H_UINT, 4, 5,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_SHIFT] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* imm: signed immediate */
+  { "imm", LM32_OPERAND_IMM, HW_H_SINT, 15, 16,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* uimm: unsigned immediate */
+  { "uimm", LM32_OPERAND_UIMM, HW_H_UINT, 15, 16,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* branch: branch offset */
+  { "branch", LM32_OPERAND_BRANCH, HW_H_IADDR, 15, 16,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_BRANCH] } }, 
+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+/* call: call offset */
+  { "call", LM32_OPERAND_CALL, HW_H_IADDR, 25, 26,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_CALL] } }, 
+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+/* csr: csr */
+  { "csr", LM32_OPERAND_CSR, HW_H_CSR, 25, 5,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_CSR] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* user: user */
+  { "user", LM32_OPERAND_USER, HW_H_UINT, 10, 11,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_USER] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* exception: exception */
+  { "exception", LM32_OPERAND_EXCEPTION, HW_H_UINT, 25, 26,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_EXCEPTION] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* hi16: high 16-bit immediate */
+  { "hi16", LM32_OPERAND_HI16, HW_H_UINT, 15, 16,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* lo16: low 16-bit immediate */
+  { "lo16", LM32_OPERAND_LO16, HW_H_UINT, 15, 16,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* gp16: gp relative 16-bit immediate */
+  { "gp16", LM32_OPERAND_GP16, HW_H_SINT, 15, 16,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* got16: got relative 16-bit immediate */
+  { "got16", LM32_OPERAND_GOT16, HW_H_SINT, 15, 16,
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* sentinel */
+  { 0, 0, 0, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction table.  */
+
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define A(a) (1 << CGEN_INSN_##a)
+#else
+#define A(a) (1 << CGEN_INSN_/**/a)
+#endif
+
+static const CGEN_IBASE lm32_cgen_insn_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+/* add $r2,$r0,$r1 */
+  {
+    LM32_INSN_ADD, "add", "add", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* addi $r1,$r0,$imm */
+  {
+    LM32_INSN_ADDI, "addi", "addi", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* and $r2,$r0,$r1 */
+  {
+    LM32_INSN_AND, "and", "and", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* andi $r1,$r0,$uimm */
+  {
+    LM32_INSN_ANDI, "andi", "andi", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* andhi $r1,$r0,$hi16 */
+  {
+    LM32_INSN_ANDHII, "andhii", "andhi", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* b $r0 */
+  {
+    LM32_INSN_B, "b", "b", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bi $call */
+  {
+    LM32_INSN_BI, "bi", "bi", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* be $r0,$r1,$branch */
+  {
+    LM32_INSN_BE, "be", "be", 32,
+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bg $r0,$r1,$branch */
+  {
+    LM32_INSN_BG, "bg", "bg", 32,
+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bge $r0,$r1,$branch */
+  {
+    LM32_INSN_BGE, "bge", "bge", 32,
+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bgeu $r0,$r1,$branch */
+  {
+    LM32_INSN_BGEU, "bgeu", "bgeu", 32,
+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bgu $r0,$r1,$branch */
+  {
+    LM32_INSN_BGU, "bgu", "bgu", 32,
+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bne $r0,$r1,$branch */
+  {
+    LM32_INSN_BNE, "bne", "bne", 32,
+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* call $r0 */
+  {
+    LM32_INSN_CALL, "call", "call", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* calli $call */
+  {
+    LM32_INSN_CALLI, "calli", "calli", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpe $r2,$r0,$r1 */
+  {
+    LM32_INSN_CMPE, "cmpe", "cmpe", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpei $r1,$r0,$imm */
+  {
+    LM32_INSN_CMPEI, "cmpei", "cmpei", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpg $r2,$r0,$r1 */
+  {
+    LM32_INSN_CMPG, "cmpg", "cmpg", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpgi $r1,$r0,$imm */
+  {
+    LM32_INSN_CMPGI, "cmpgi", "cmpgi", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpge $r2,$r0,$r1 */
+  {
+    LM32_INSN_CMPGE, "cmpge", "cmpge", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpgei $r1,$r0,$imm */
+  {
+    LM32_INSN_CMPGEI, "cmpgei", "cmpgei", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpgeu $r2,$r0,$r1 */
+  {
+    LM32_INSN_CMPGEU, "cmpgeu", "cmpgeu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpgeui $r1,$r0,$uimm */
+  {
+    LM32_INSN_CMPGEUI, "cmpgeui", "cmpgeui", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpgu $r2,$r0,$r1 */
+  {
+    LM32_INSN_CMPGU, "cmpgu", "cmpgu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpgui $r1,$r0,$uimm */
+  {
+    LM32_INSN_CMPGUI, "cmpgui", "cmpgui", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpne $r2,$r0,$r1 */
+  {
+    LM32_INSN_CMPNE, "cmpne", "cmpne", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmpnei $r1,$r0,$imm */
+  {
+    LM32_INSN_CMPNEI, "cmpnei", "cmpnei", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* divu $r2,$r0,$r1 */
+  {
+    LM32_INSN_DIVU, "divu", "divu", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lb $r1,($r0+$imm) */
+  {
+    LM32_INSN_LB, "lb", "lb", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lbu $r1,($r0+$imm) */
+  {
+    LM32_INSN_LBU, "lbu", "lbu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lh $r1,($r0+$imm) */
+  {
+    LM32_INSN_LH, "lh", "lh", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lhu $r1,($r0+$imm) */
+  {
+    LM32_INSN_LHU, "lhu", "lhu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lw $r1,($r0+$imm) */
+  {
+    LM32_INSN_LW, "lw", "lw", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* modu $r2,$r0,$r1 */
+  {
+    LM32_INSN_MODU, "modu", "modu", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mul $r2,$r0,$r1 */
+  {
+    LM32_INSN_MUL, "mul", "mul", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* muli $r1,$r0,$imm */
+  {
+    LM32_INSN_MULI, "muli", "muli", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* nor $r2,$r0,$r1 */
+  {
+    LM32_INSN_NOR, "nor", "nor", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* nori $r1,$r0,$uimm */
+  {
+    LM32_INSN_NORI, "nori", "nori", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* or $r2,$r0,$r1 */
+  {
+    LM32_INSN_OR, "or", "or", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ori $r1,$r0,$lo16 */
+  {
+    LM32_INSN_ORI, "ori", "ori", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* orhi $r1,$r0,$hi16 */
+  {
+    LM32_INSN_ORHII, "orhii", "orhi", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* rcsr $r2,$csr */
+  {
+    LM32_INSN_RCSR, "rcsr", "rcsr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sb ($r0+$imm),$r1 */
+  {
+    LM32_INSN_SB, "sb", "sb", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sextb $r2,$r0 */
+  {
+    LM32_INSN_SEXTB, "sextb", "sextb", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sexth $r2,$r0 */
+  {
+    LM32_INSN_SEXTH, "sexth", "sexth", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sh ($r0+$imm),$r1 */
+  {
+    LM32_INSN_SH, "sh", "sh", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sl $r2,$r0,$r1 */
+  {
+    LM32_INSN_SL, "sl", "sl", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sli $r1,$r0,$imm */
+  {
+    LM32_INSN_SLI, "sli", "sli", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sr $r2,$r0,$r1 */
+  {
+    LM32_INSN_SR, "sr", "sr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sri $r1,$r0,$imm */
+  {
+    LM32_INSN_SRI, "sri", "sri", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sru $r2,$r0,$r1 */
+  {
+    LM32_INSN_SRU, "sru", "sru", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* srui $r1,$r0,$imm */
+  {
+    LM32_INSN_SRUI, "srui", "srui", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sub $r2,$r0,$r1 */
+  {
+    LM32_INSN_SUB, "sub", "sub", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sw ($r0+$imm),$r1 */
+  {
+    LM32_INSN_SW, "sw", "sw", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* user $r2,$r0,$r1,$user */
+  {
+    LM32_INSN_USER, "user", "user", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* wcsr $csr,$r1 */
+  {
+    LM32_INSN_WCSR, "wcsr", "wcsr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xor $r2,$r0,$r1 */
+  {
+    LM32_INSN_XOR, "xor", "xor", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xori $r1,$r0,$uimm */
+  {
+    LM32_INSN_XORI, "xori", "xori", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xnor $r2,$r0,$r1 */
+  {
+    LM32_INSN_XNOR, "xnor", "xnor", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xnori $r1,$r0,$uimm */
+  {
+    LM32_INSN_XNORI, "xnori", "xnori", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* break */
+  {
+    LM32_INSN_BREAK, "break", "break", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* scall */
+  {
+    LM32_INSN_SCALL, "scall", "scall", 32,
+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bret */
+  {
+    -1, "bret", "bret", 32,
+    { 0|A(ALIAS)|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* eret */
+  {
+    -1, "eret", "eret", 32,
+    { 0|A(ALIAS)|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ret */
+  {
+    -1, "ret", "ret", 32,
+    { 0|A(ALIAS)|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mv $r2,$r0 */
+  {
+    -1, "mv", "mv", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mvi $r1,$imm */
+  {
+    -1, "mvi", "mvi", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mvu $r1,$lo16 */
+  {
+    -1, "mvui", "mvu", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mvhi $r1,$hi16 */
+  {
+    -1, "mvhi", "mvhi", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mva $r1,$gp16 */
+  {
+    -1, "mva", "mva", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* not $r2,$r0 */
+  {
+    -1, "not", "not", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* nop */
+  {
+    -1, "nop", "nop", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lb $r1,$gp16 */
+  {
+    -1, "lbgprel", "lb", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lbu $r1,$gp16 */
+  {
+    -1, "lbugprel", "lbu", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lh $r1,$gp16 */
+  {
+    -1, "lhgprel", "lh", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lhu $r1,$gp16 */
+  {
+    -1, "lhugprel", "lhu", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lw $r1,$gp16 */
+  {
+    -1, "lwgprel", "lw", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sb $gp16,$r1 */
+  {
+    -1, "sbgprel", "sb", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sh $gp16,$r1 */
+  {
+    -1, "shgprel", "sh", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sw $gp16,$r1 */
+  {
+    -1, "swgprel", "sw", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lw $r1,(gp+$got16) */
+  {
+    -1, "lwgotrel", "lw", 32,
+    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
+  },
+};
+
+#undef OP
+#undef A
+
+/* Initialize anything needed to be done once, before any cpu_open call.  */
+
+static void
+init_tables (void)
+{
+}
+
+static const CGEN_MACH * lookup_mach_via_bfd_name (const CGEN_MACH *, const char *);
+static void build_hw_table      (CGEN_CPU_TABLE *);
+static void build_ifield_table  (CGEN_CPU_TABLE *);
+static void build_operand_table (CGEN_CPU_TABLE *);
+static void build_insn_table    (CGEN_CPU_TABLE *);
+static void lm32_cgen_rebuild_tables (CGEN_CPU_TABLE *);
+
+/* Subroutine of lm32_cgen_cpu_open to look up a mach via its bfd name.  */
+
+static const CGEN_MACH *
+lookup_mach_via_bfd_name (const CGEN_MACH *table, const char *name)
+{
+  while (table->name)
+    {
+      if (strcmp (name, table->bfd_name) == 0)
+	return table;
+      ++table;
+    }
+  abort ();
+}
+
+/* Subroutine of lm32_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_hw_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_HW_ENTRY *init = & lm32_cgen_hw_table[0];
+  /* MAX_HW is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_HW_ENTRY **selected =
+    (const CGEN_HW_ENTRY **) xmalloc (MAX_HW * sizeof (CGEN_HW_ENTRY *));
+
+  cd->hw_table.init_entries = init;
+  cd->hw_table.entry_size = sizeof (CGEN_HW_ENTRY);
+  memset (selected, 0, MAX_HW * sizeof (CGEN_HW_ENTRY *));
+  /* ??? For now we just use machs to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_HW_ATTR_VALUE (&init[i], CGEN_HW_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->hw_table.entries = selected;
+  cd->hw_table.num_entries = MAX_HW;
+}
+
+/* Subroutine of lm32_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_ifield_table (CGEN_CPU_TABLE *cd)
+{
+  cd->ifld_table = & lm32_cgen_ifld_table[0];
+}
+
+/* Subroutine of lm32_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_operand_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_OPERAND *init = & lm32_cgen_operand_table[0];
+  /* MAX_OPERANDS is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_OPERAND **selected = xmalloc (MAX_OPERANDS * sizeof (* selected));
+
+  cd->operand_table.init_entries = init;
+  cd->operand_table.entry_size = sizeof (CGEN_OPERAND);
+  memset (selected, 0, MAX_OPERANDS * sizeof (CGEN_OPERAND *));
+  /* ??? For now we just use mach to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_OPERAND_ATTR_VALUE (&init[i], CGEN_OPERAND_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->operand_table.entries = selected;
+  cd->operand_table.num_entries = MAX_OPERANDS;
+}
+
+/* Subroutine of lm32_cgen_cpu_open to build the hardware table.
+   ??? This could leave out insns not supported by the specified mach/isa,
+   but that would cause errors like "foo only supported by bar" to become
+   "unknown insn", so for now we include all insns and require the app to
+   do the checking later.
+   ??? On the other hand, parsing of such insns may require their hardware or
+   operand elements to be in the table [which they mightn't be].  */
+
+static void
+build_insn_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  const CGEN_IBASE *ib = & lm32_cgen_insn_table[0];
+  CGEN_INSN *insns = xmalloc (MAX_INSNS * sizeof (CGEN_INSN));
+
+  memset (insns, 0, MAX_INSNS * sizeof (CGEN_INSN));
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].base = &ib[i];
+  cd->insn_table.init_entries = insns;
+  cd->insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->insn_table.num_init_entries = MAX_INSNS;
+}
+
+/* Subroutine of lm32_cgen_cpu_open to rebuild the tables.  */
+
+static void
+lm32_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  CGEN_BITSET *isas = cd->isas;
+  unsigned int machs = cd->machs;
+
+  cd->int_insn_p = CGEN_INT_INSN_P;
+
+  /* Data derived from the isa spec.  */
+#define UNSET (CGEN_SIZE_UNKNOWN + 1)
+  cd->default_insn_bitsize = UNSET;
+  cd->base_insn_bitsize = UNSET;
+  cd->min_insn_bitsize = 65535; /* Some ridiculously big number.  */
+  cd->max_insn_bitsize = 0;
+  for (i = 0; i < MAX_ISAS; ++i)
+    if (cgen_bitset_contains (isas, i))
+      {
+	const CGEN_ISA *isa = & lm32_cgen_isa_table[i];
+
+	/* Default insn sizes of all selected isas must be
+	   equal or we set the result to 0, meaning "unknown".  */
+	if (cd->default_insn_bitsize == UNSET)
+	  cd->default_insn_bitsize = isa->default_insn_bitsize;
+	else if (isa->default_insn_bitsize == cd->default_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->default_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Base insn sizes of all selected isas must be equal
+	   or we set the result to 0, meaning "unknown".  */
+	if (cd->base_insn_bitsize == UNSET)
+	  cd->base_insn_bitsize = isa->base_insn_bitsize;
+	else if (isa->base_insn_bitsize == cd->base_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Set min,max insn sizes.  */
+	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	  cd->min_insn_bitsize = isa->min_insn_bitsize;
+	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+      }
+
+  /* Data derived from the mach spec.  */
+  for (i = 0; i < MAX_MACHS; ++i)
+    if (((1 << i) & machs) != 0)
+      {
+	const CGEN_MACH *mach = & lm32_cgen_mach_table[i];
+
+	if (mach->insn_chunk_bitsize != 0)
+	{
+	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	    {
+	      fprintf (stderr, "lm32_cgen_rebuild_tables: conflicting insn-chunk-bitsize values: `%d' vs. `%d'\n",
+		       cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
+	      abort ();
+	    }
+
+ 	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
+	}
+      }
+
+  /* Determine which hw elements are used by MACH.  */
+  build_hw_table (cd);
+
+  /* Build the ifield table.  */
+  build_ifield_table (cd);
+
+  /* Determine which operands are used by MACH/ISA.  */
+  build_operand_table (cd);
+
+  /* Build the instruction table.  */
+  build_insn_table (cd);
+}
+
+/* Initialize a cpu table and return a descriptor.
+   It's much like opening a file, and must be the first function called.
+   The arguments are a set of (type/value) pairs, terminated with
+   CGEN_CPU_OPEN_END.
+
+   Currently supported values:
+   CGEN_CPU_OPEN_ISAS:    bitmap of values in enum isa_attr
+   CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr
+   CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name
+   CGEN_CPU_OPEN_ENDIAN:  specify endian choice
+   CGEN_CPU_OPEN_END:     terminates arguments
+
+   ??? Simultaneous multiple isas might not make sense, but it's not (yet)
+   precluded.
+
+   ??? We only support ISO C stdargs here, not K&R.
+   Laziness, plus experiment to see if anything requires K&R - eventually
+   K&R will no longer be supported - e.g. GDB is currently trying this.  */
+
+CGEN_CPU_DESC
+lm32_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
+{
+  CGEN_CPU_TABLE *cd = (CGEN_CPU_TABLE *) xmalloc (sizeof (CGEN_CPU_TABLE));
+  static int init_p;
+  CGEN_BITSET *isas = 0;  /* 0 = "unspecified" */
+  unsigned int machs = 0; /* 0 = "unspecified" */
+  enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;
+  va_list ap;
+
+  if (! init_p)
+    {
+      init_tables ();
+      init_p = 1;
+    }
+
+  memset (cd, 0, sizeof (*cd));
+
+  va_start (ap, arg_type);
+  while (arg_type != CGEN_CPU_OPEN_END)
+    {
+      switch (arg_type)
+	{
+	case CGEN_CPU_OPEN_ISAS :
+	  isas = va_arg (ap, CGEN_BITSET *);
+	  break;
+	case CGEN_CPU_OPEN_MACHS :
+	  machs = va_arg (ap, unsigned int);
+	  break;
+	case CGEN_CPU_OPEN_BFDMACH :
+	  {
+	    const char *name = va_arg (ap, const char *);
+	    const CGEN_MACH *mach =
+	      lookup_mach_via_bfd_name (lm32_cgen_mach_table, name);
+
+	    machs |= 1 << mach->num;
+	    break;
+	  }
+	case CGEN_CPU_OPEN_ENDIAN :
+	  endian = va_arg (ap, enum cgen_endian);
+	  break;
+	default :
+	  fprintf (stderr, "lm32_cgen_cpu_open: unsupported argument `%d'\n",
+		   arg_type);
+	  abort (); /* ??? return NULL? */
+	}
+      arg_type = va_arg (ap, enum cgen_cpu_open_arg);
+    }
+  va_end (ap);
+
+  /* Mach unspecified means "all".  */
+  if (machs == 0)
+    machs = (1 << MAX_MACHS) - 1;
+  /* Base mach is always selected.  */
+  machs |= 1;
+  if (endian == CGEN_ENDIAN_UNKNOWN)
+    {
+      /* ??? If target has only one, could have a default.  */
+      fprintf (stderr, "lm32_cgen_cpu_open: no endianness specified\n");
+      abort ();
+    }
+
+  cd->isas = cgen_bitset_copy (isas);
+  cd->machs = machs;
+  cd->endian = endian;
+  /* FIXME: for the sparc case we can determine insn-endianness statically.
+     The worry here is where both data and insn endian can be independently
+     chosen, in which case this function will need another argument.
+     Actually, will want to allow for more arguments in the future anyway.  */
+  cd->insn_endian = endian;
+
+  /* Table (re)builder.  */
+  cd->rebuild_tables = lm32_cgen_rebuild_tables;
+  lm32_cgen_rebuild_tables (cd);
+
+  /* Default to not allowing signed overflow.  */
+  cd->signed_overflow_ok_p = 0;
+  
+  return (CGEN_CPU_DESC) cd;
+}
+
+/* Cover fn to lm32_cgen_cpu_open to handle the simple case of 1 isa, 1 mach.
+   MACH_NAME is the bfd name of the mach.  */
+
+CGEN_CPU_DESC
+lm32_cgen_cpu_open_1 (const char *mach_name, enum cgen_endian endian)
+{
+  return lm32_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,
+			       CGEN_CPU_OPEN_ENDIAN, endian,
+			       CGEN_CPU_OPEN_END);
+}
+
+/* Close a cpu table.
+   ??? This can live in a machine independent file, but there's currently
+   no place to put this file (there's no libcgen).  libopcodes is the wrong
+   place as some simulator ports use this but they don't use libopcodes.  */
+
+void
+lm32_cgen_cpu_close (CGEN_CPU_DESC cd)
+{
+  unsigned int i;
+  const CGEN_INSN *insns;
+
+  if (cd->macro_insn_table.init_entries)
+    {
+      insns = cd->macro_insn_table.init_entries;
+      for (i = 0; i < cd->macro_insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX ((insns)))
+	  regfree (CGEN_INSN_RX (insns));
+    }
+
+  if (cd->insn_table.init_entries)
+    {
+      insns = cd->insn_table.init_entries;
+      for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX (insns))
+	  regfree (CGEN_INSN_RX (insns));
+    }  
+
+  if (cd->macro_insn_table.init_entries)
+    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
+
+  if (cd->insn_table.init_entries)
+    free ((CGEN_INSN *) cd->insn_table.init_entries);
+
+  if (cd->hw_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);
+
+  if (cd->operand_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);
+
+  free (cd);
+}
+
diff --git a/opcodes/lm32-desc.h b/opcodes/lm32-desc.h
new file mode 100644
index 0000000..24d3a28
--- /dev/null
+++ b/opcodes/lm32-desc.h
@@ -0,0 +1,246 @@
+/* CPU data header for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2007 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef LM32_CPU_H
+#define LM32_CPU_H
+
+#include "opcode/cgen-bitset.h"
+
+#define CGEN_ARCH lm32
+
+/* Given symbol S, return lm32_cgen_<S>.  */
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define CGEN_SYM(s) lm32##_cgen_##s
+#else
+#define CGEN_SYM(s) lm32/**/_cgen_/**/s
+#endif
+
+
+/* Selected cpu families.  */
+#define HAVE_CPU_LM32BF
+
+#define CGEN_INSN_LSB0_P 1
+
+/* Minimum size of any insn (in bytes).  */
+#define CGEN_MIN_INSN_SIZE 4
+
+/* Maximum size of any insn (in bytes).  */
+#define CGEN_MAX_INSN_SIZE 4
+
+#define CGEN_INT_INSN_P 1
+
+/* Maximum number of syntax elements in an instruction.  */
+#define CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS 15
+
+/* CGEN_MNEMONIC_OPERANDS is defined if mnemonics have operands.
+   e.g. In "b,a foo" the ",a" is an operand.  If mnemonics have operands
+   we can't hash on everything up to the space.  */
+#define CGEN_MNEMONIC_OPERANDS
+
+/* Maximum number of fields in an instruction.  */
+#define CGEN_ACTUAL_MAX_IFMT_OPERANDS 5
+
+/* Enums.  */
+
+/* Enum declaration for opcodes.  */
+typedef enum opcodes {
+  OP_ADD = 45, OP_ADDI = 13, OP_AND = 40, OP_ANDI = 8
+ , OP_ANDHI = 24, OP_B = 48, OP_BI = 56, OP_BE = 17
+ , OP_BG = 18, OP_BGE = 19, OP_BGEU = 20, OP_BGU = 21
+ , OP_BNE = 23, OP_CALL = 54, OP_CALLI = 62, OP_CMPE = 57
+ , OP_CMPEI = 25, OP_CMPG = 58, OP_CMPGI = 26, OP_CMPGE = 59
+ , OP_CMPGEI = 27, OP_CMPGEU = 60, OP_CMPGEUI = 28, OP_CMPGU = 61
+ , OP_CMPGUI = 29, OP_CMPNE = 63, OP_CMPNEI = 31, OP_DIVU = 35
+ , OP_LB = 4, OP_LBU = 16, OP_LH = 7, OP_LHU = 11
+ , OP_LW = 10, OP_MODU = 49, OP_MUL = 34, OP_MULI = 2
+ , OP_NOR = 33, OP_NORI = 1, OP_OR = 46, OP_ORI = 14
+ , OP_ORHI = 30, OP_RAISE = 43, OP_RCSR = 36, OP_SB = 12
+ , OP_SEXTB = 44, OP_SEXTH = 55, OP_SH = 3, OP_SL = 47
+ , OP_SLI = 15, OP_SR = 37, OP_SRI = 5, OP_SRU = 32
+ , OP_SRUI = 0, OP_SUB = 50, OP_SW = 22, OP_USER = 51
+ , OP_WCSR = 52, OP_XNOR = 41, OP_XNORI = 9, OP_XOR = 38
+ , OP_XORI = 6
+} OPCODES;
+
+/* Attributes.  */
+
+/* Enum declaration for machine type selection.  */
+typedef enum mach_attr {
+  MACH_BASE, MACH_LM32, MACH_MAX
+} MACH_ATTR;
+
+/* Enum declaration for instruction set selection.  */
+typedef enum isa_attr {
+  ISA_LM32, ISA_MAX
+} ISA_ATTR;
+
+/* Number of architecture variants.  */
+#define MAX_ISAS  1
+#define MAX_MACHS ((int) MACH_MAX)
+
+/* Ifield support.  */
+
+/* Ifield attribute indices.  */
+
+/* Enum declaration for cgen_ifld attrs.  */
+typedef enum cgen_ifld_attr {
+  CGEN_IFLD_VIRTUAL, CGEN_IFLD_PCREL_ADDR, CGEN_IFLD_ABS_ADDR, CGEN_IFLD_RESERVED
+ , CGEN_IFLD_SIGN_OPT, CGEN_IFLD_SIGNED, CGEN_IFLD_END_BOOLS, CGEN_IFLD_START_NBOOLS = 31
+ , CGEN_IFLD_MACH, CGEN_IFLD_END_NBOOLS
+} CGEN_IFLD_ATTR;
+
+/* Number of non-boolean elements in cgen_ifld_attr.  */
+#define CGEN_IFLD_NBOOL_ATTRS (CGEN_IFLD_END_NBOOLS - CGEN_IFLD_START_NBOOLS - 1)
+
+/* cgen_ifld attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_IFLD_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_IFLD_MACH-CGEN_IFLD_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_IFLD_VIRTUAL_VALUE(attrs) (((attrs)->bool & (1 << CGEN_IFLD_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_PCREL_ADDR_VALUE(attrs) (((attrs)->bool & (1 << CGEN_IFLD_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_ABS_ADDR_VALUE(attrs) (((attrs)->bool & (1 << CGEN_IFLD_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_RESERVED_VALUE(attrs) (((attrs)->bool & (1 << CGEN_IFLD_RESERVED)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGN_OPT_VALUE(attrs) (((attrs)->bool & (1 << CGEN_IFLD_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGNED_VALUE(attrs) (((attrs)->bool & (1 << CGEN_IFLD_SIGNED)) != 0)
+
+/* Enum declaration for lm32 ifield types.  */
+typedef enum ifield_type {
+  LM32_F_NIL, LM32_F_ANYOF, LM32_F_OPCODE, LM32_F_R0
+ , LM32_F_R1, LM32_F_R2, LM32_F_RESV0, LM32_F_SHIFT
+ , LM32_F_IMM, LM32_F_UIMM, LM32_F_CSR, LM32_F_USER
+ , LM32_F_EXCEPTION, LM32_F_BRANCH, LM32_F_CALL, LM32_F_MAX
+} IFIELD_TYPE;
+
+#define MAX_IFLD ((int) LM32_F_MAX)
+
+/* Hardware attribute indices.  */
+
+/* Enum declaration for cgen_hw attrs.  */
+typedef enum cgen_hw_attr {
+  CGEN_HW_VIRTUAL, CGEN_HW_CACHE_ADDR, CGEN_HW_PC, CGEN_HW_PROFILE
+ , CGEN_HW_END_BOOLS, CGEN_HW_START_NBOOLS = 31, CGEN_HW_MACH, CGEN_HW_END_NBOOLS
+} CGEN_HW_ATTR;
+
+/* Number of non-boolean elements in cgen_hw_attr.  */
+#define CGEN_HW_NBOOL_ATTRS (CGEN_HW_END_NBOOLS - CGEN_HW_START_NBOOLS - 1)
+
+/* cgen_hw attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_HW_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_HW_MACH-CGEN_HW_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_HW_VIRTUAL_VALUE(attrs) (((attrs)->bool & (1 << CGEN_HW_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_HW_CACHE_ADDR_VALUE(attrs) (((attrs)->bool & (1 << CGEN_HW_CACHE_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_HW_PC_VALUE(attrs) (((attrs)->bool & (1 << CGEN_HW_PC)) != 0)
+#define CGEN_ATTR_CGEN_HW_PROFILE_VALUE(attrs) (((attrs)->bool & (1 << CGEN_HW_PROFILE)) != 0)
+
+/* Enum declaration for lm32 hardware types.  */
+typedef enum cgen_hw_type {
+  HW_H_MEMORY, HW_H_SINT, HW_H_UINT, HW_H_ADDR
+ , HW_H_IADDR, HW_H_PC, HW_H_GR, HW_H_CSR
+ , HW_MAX
+} CGEN_HW_TYPE;
+
+#define MAX_HW ((int) HW_MAX)
+
+/* Operand attribute indices.  */
+
+/* Enum declaration for cgen_operand attrs.  */
+typedef enum cgen_operand_attr {
+  CGEN_OPERAND_VIRTUAL, CGEN_OPERAND_PCREL_ADDR, CGEN_OPERAND_ABS_ADDR, CGEN_OPERAND_SIGN_OPT
+ , CGEN_OPERAND_SIGNED, CGEN_OPERAND_NEGATIVE, CGEN_OPERAND_RELAX, CGEN_OPERAND_SEM_ONLY
+ , CGEN_OPERAND_END_BOOLS, CGEN_OPERAND_START_NBOOLS = 31, CGEN_OPERAND_MACH, CGEN_OPERAND_END_NBOOLS
+} CGEN_OPERAND_ATTR;
+
+/* Number of non-boolean elements in cgen_operand_attr.  */
+#define CGEN_OPERAND_NBOOL_ATTRS (CGEN_OPERAND_END_NBOOLS - CGEN_OPERAND_START_NBOOLS - 1)
+
+/* cgen_operand attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_OPERAND_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_OPERAND_MACH-CGEN_OPERAND_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_OPERAND_VIRTUAL_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_PCREL_ADDR_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_ABS_ADDR_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGN_OPT_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGNED_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_SIGNED)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_NEGATIVE_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_NEGATIVE)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_RELAX_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_RELAX)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SEM_ONLY_VALUE(attrs) (((attrs)->bool & (1 << CGEN_OPERAND_SEM_ONLY)) != 0)
+
+/* Enum declaration for lm32 operand types.  */
+typedef enum cgen_operand_type {
+  LM32_OPERAND_PC, LM32_OPERAND_R0, LM32_OPERAND_R1, LM32_OPERAND_R2
+ , LM32_OPERAND_SHIFT, LM32_OPERAND_IMM, LM32_OPERAND_UIMM, LM32_OPERAND_BRANCH
+ , LM32_OPERAND_CALL, LM32_OPERAND_CSR, LM32_OPERAND_USER, LM32_OPERAND_EXCEPTION
+ , LM32_OPERAND_HI16, LM32_OPERAND_LO16, LM32_OPERAND_GP16, LM32_OPERAND_GOT16
+ , LM32_OPERAND_MAX
+} CGEN_OPERAND_TYPE;
+
+/* Number of operands types.  */
+#define MAX_OPERANDS 16
+
+/* Maximum number of operands referenced by any insn.  */
+#define MAX_OPERAND_INSTANCES 5
+
+/* Insn attribute indices.  */
+
+/* Enum declaration for cgen_insn attrs.  */
+typedef enum cgen_insn_attr {
+  CGEN_INSN_ALIAS, CGEN_INSN_VIRTUAL, CGEN_INSN_UNCOND_CTI, CGEN_INSN_COND_CTI
+ , CGEN_INSN_SKIP_CTI, CGEN_INSN_DELAY_SLOT, CGEN_INSN_RELAXABLE, CGEN_INSN_RELAXED
+ , CGEN_INSN_NO_DIS, CGEN_INSN_PBB, CGEN_INSN_END_BOOLS, CGEN_INSN_START_NBOOLS = 31
+ , CGEN_INSN_MACH, CGEN_INSN_END_NBOOLS
+} CGEN_INSN_ATTR;
+
+/* Number of non-boolean elements in cgen_insn_attr.  */
+#define CGEN_INSN_NBOOL_ATTRS (CGEN_INSN_END_NBOOLS - CGEN_INSN_START_NBOOLS - 1)
+
+/* cgen_insn attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_INSN_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_INSN_MACH-CGEN_INSN_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_ALIAS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_VIRTUAL_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_INSN_UNCOND_CTI_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_UNCOND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_COND_CTI_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_COND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_SKIP_CTI_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_SKIP_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_DELAY_SLOT)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXABLE_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_RELAXABLE)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXED_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_RELAXED)) != 0)
+#define CGEN_ATTR_CGEN_INSN_NO_DIS_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_NO_DIS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_PBB_VALUE(attrs) (((attrs)->bool & (1 << CGEN_INSN_PBB)) != 0)
+
+/* cgen.h uses things we just defined.  */
+#include "opcode/cgen.h"
+
+extern const struct cgen_ifld lm32_cgen_ifld_table[];
+
+/* Attributes.  */
+extern const CGEN_ATTR_TABLE lm32_cgen_hardware_attr_table[];
+extern const CGEN_ATTR_TABLE lm32_cgen_ifield_attr_table[];
+extern const CGEN_ATTR_TABLE lm32_cgen_operand_attr_table[];
+extern const CGEN_ATTR_TABLE lm32_cgen_insn_attr_table[];
+
+/* Hardware decls.  */
+
+extern CGEN_KEYWORD lm32_cgen_opval_h_gr;
+extern CGEN_KEYWORD lm32_cgen_opval_h_csr;
+
+extern const CGEN_HW_ENTRY lm32_cgen_hw_table[];
+
+
+
+#endif /* LM32_CPU_H */
diff --git a/opcodes/lm32-dis.c b/opcodes/lm32-dis.c
new file mode 100644
index 0000000..e664e7d
--- /dev/null
+++ b/opcodes/lm32-dis.c
@@ -0,0 +1,570 @@
+/* Disassembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-dis.in isn't
+
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "dis-asm.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "libiberty.h"
+#include "lm32-desc.h"
+#include "lm32-opc.h"
+#include "opintl.h"
+
+/* Default text to print if an instruction isn't recognized.  */
+#define UNKNOWN_INSN_MSG _("*unknown*")
+
+static void print_normal
+  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+static void print_address
+  (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
+static void print_keyword
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+static void print_insn_normal
+  (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
+static int print_insn
+  (CGEN_CPU_DESC, bfd_vma,  disassemble_info *, bfd_byte *, unsigned);
+static int default_print_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
+static int read_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
+   unsigned long *);
+
+/* -- disassembler routines inserted here.  */
+
+
+void lm32_cgen_print_operand
+  (CGEN_CPU_DESC, int, PTR, CGEN_FIELDS *, void const *, bfd_vma, int);
+
+/* Main entry point for printing operands.
+   XINFO is a `void *' and not a `disassemble_info *' to not put a requirement
+   of dis-asm.h on cgen.h.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+void
+lm32_cgen_print_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   void * xinfo,
+			   CGEN_FIELDS *fields,
+			   void const *attrs ATTRIBUTE_UNUSED,
+			   bfd_vma pc,
+			   int length)
+{
+  disassemble_info *info = (disassemble_info *) xinfo;
+
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      print_address (cd, info, fields->f_branch, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
+      break;
+    case LM32_OPERAND_CALL :
+      print_address (cd, info, fields->f_call, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
+      break;
+    case LM32_OPERAND_CSR :
+      print_keyword (cd, info, & lm32_cgen_opval_h_csr, fields->f_csr, 0);
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      print_normal (cd, info, fields->f_exception, 0, pc, length);
+      break;
+    case LM32_OPERAND_GOT16 :
+      print_normal (cd, info, fields->f_imm, 0|(1<<CGEN_OPERAND_SIGNED), pc, length);
+      break;
+    case LM32_OPERAND_GP16 :
+      print_normal (cd, info, fields->f_imm, 0|(1<<CGEN_OPERAND_SIGNED), pc, length);
+      break;
+    case LM32_OPERAND_HI16 :
+      print_normal (cd, info, fields->f_uimm, 0, pc, length);
+      break;
+    case LM32_OPERAND_IMM :
+      print_normal (cd, info, fields->f_imm, 0|(1<<CGEN_OPERAND_SIGNED), pc, length);
+      break;
+    case LM32_OPERAND_LO16 :
+      print_normal (cd, info, fields->f_uimm, 0, pc, length);
+      break;
+    case LM32_OPERAND_R0 :
+      print_keyword (cd, info, & lm32_cgen_opval_h_gr, fields->f_r0, 0);
+      break;
+    case LM32_OPERAND_R1 :
+      print_keyword (cd, info, & lm32_cgen_opval_h_gr, fields->f_r1, 0);
+      break;
+    case LM32_OPERAND_R2 :
+      print_keyword (cd, info, & lm32_cgen_opval_h_gr, fields->f_r2, 0);
+      break;
+    case LM32_OPERAND_SHIFT :
+      print_normal (cd, info, fields->f_shift, 0, pc, length);
+      break;
+    case LM32_OPERAND_UIMM :
+      print_normal (cd, info, fields->f_uimm, 0, pc, length);
+      break;
+    case LM32_OPERAND_USER :
+      print_normal (cd, info, fields->f_user, 0, pc, length);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while printing insn.\n"),
+	       opindex);
+    abort ();
+  }
+}
+
+cgen_print_fn * const lm32_cgen_print_handlers[] = 
+{
+  print_insn_normal,
+};
+
+
+void
+lm32_cgen_init_dis (CGEN_CPU_DESC cd)
+{
+  lm32_cgen_init_opcode_table (cd);
+  lm32_cgen_init_ibld_table (cd);
+  cd->print_handlers = & lm32_cgen_print_handlers[0];
+  cd->print_operand = lm32_cgen_print_operand;
+}
+
+
+/* Default print handler.  */
+
+static void
+print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	      void *dis_info,
+	      long value,
+	      unsigned int attrs,
+	      bfd_vma pc ATTRIBUTE_UNUSED,
+	      int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+#ifdef CGEN_PRINT_NORMAL
+  CGEN_PRINT_NORMAL (cd, info, value, attrs, pc, length);
+#endif
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* nothing to do */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", value);
+}
+
+/* Default address handler.  */
+
+static void
+print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       bfd_vma value,
+	       unsigned int attrs,
+	       bfd_vma pc ATTRIBUTE_UNUSED,
+	       int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+#ifdef CGEN_PRINT_ADDRESS
+  CGEN_PRINT_ADDRESS (cd, info, value, attrs, pc, length);
+#endif
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* Nothing to do.  */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_PCREL_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+}
+
+/* Keyword print handler.  */
+
+static void
+print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       CGEN_KEYWORD *keyword_table,
+	       long value,
+	       unsigned int attrs ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_KEYWORD_ENTRY *ke;
+
+  ke = cgen_keyword_lookup_value (keyword_table, value);
+  if (ke != NULL)
+    (*info->fprintf_func) (info->stream, "%s", ke->name);
+  else
+    (*info->fprintf_func) (info->stream, "???");
+}
+
+/* Default insn printer.
+
+   DIS_INFO is defined as `void *' so the disassembler needn't know anything
+   about disassemble_info.  */
+
+static void
+print_insn_normal (CGEN_CPU_DESC cd,
+		   void *dis_info,
+		   const CGEN_INSN *insn,
+		   CGEN_FIELDS *fields,
+		   bfd_vma pc,
+		   int length)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_INIT_PRINT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      if (CGEN_SYNTAX_MNEMONIC_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%s", CGEN_INSN_MNEMONIC (insn));
+	  continue;
+	}
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%c", CGEN_SYNTAX_CHAR (*syn));
+	  continue;
+	}
+
+      /* We have an operand.  */
+      lm32_cgen_print_operand (cd, CGEN_SYNTAX_FIELD (*syn), info,
+				 fields, CGEN_INSN_ATTRS (insn), pc, length);
+    }
+}
+
+/* Subroutine of print_insn. Reads an insn into the given buffers and updates
+   the extract info.
+   Returns 0 if all is well, non-zero otherwise.  */
+
+static int
+read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	   bfd_vma pc,
+	   disassemble_info *info,
+	   bfd_byte *buf,
+	   int buflen,
+	   CGEN_EXTRACT_INFO *ex_info,
+	   unsigned long *insn_value)
+{
+  int status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  ex_info->dis_info = info;
+  ex_info->valid = (1 << buflen) - 1;
+  ex_info->insn_bytes = buf;
+
+  *insn_value = bfd_get_bits (buf, buflen * 8, info->endian == BFD_ENDIAN_BIG);
+  return 0;
+}
+
+/* Utility to print an insn.
+   BUF is the base part of the insn, target byte order, BUFLEN bytes long.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+print_insn (CGEN_CPU_DESC cd,
+	    bfd_vma pc,
+	    disassemble_info *info,
+	    bfd_byte *buf,
+	    unsigned int buflen)
+{
+  CGEN_INSN_INT insn_value;
+  const CGEN_INSN_LIST *insn_list;
+  CGEN_EXTRACT_INFO ex_info;
+  int basesize;
+
+  /* Extract base part of instruction, just in case CGEN_DIS_* uses it. */
+  basesize = cd->base_insn_bitsize < buflen * 8 ?
+                                     cd->base_insn_bitsize : buflen * 8;
+  insn_value = cgen_get_insn_value (cd, buf, basesize);
+
+
+  /* Fill in ex_info fields like read_insn would.  Don't actually call
+     read_insn, since the incoming buffer is already read (and possibly
+     modified a la m32r).  */
+  ex_info.valid = (1 << buflen) - 1;
+  ex_info.dis_info = info;
+  ex_info.insn_bytes = buf;
+
+  /* The instructions are stored in hash lists.
+     Pick the first one and keep trying until we find the right one.  */
+
+  insn_list = CGEN_DIS_LOOKUP_INSN (cd, (char *) buf, insn_value);
+  while (insn_list != NULL)
+    {
+      const CGEN_INSN *insn = insn_list->insn;
+      CGEN_FIELDS fields;
+      int length;
+      unsigned long insn_value_cropped;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+      /* Not needed as insn shouldn't be in hash lists if not supported.  */
+      /* Supported by this cpu?  */
+      if (! lm32_cgen_insn_supported (cd, insn))
+        {
+          insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+	  continue;
+        }
+#endif
+
+      /* Basic bit mask must be correct.  */
+      /* ??? May wish to allow target to defer this check until the extract
+	 handler.  */
+
+      /* Base size may exceed this instruction's size.  Extract the
+         relevant part from the buffer. */
+      if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+					   info->endian == BFD_ENDIAN_BIG);
+      else
+	insn_value_cropped = insn_value;
+
+      if ((insn_value_cropped & CGEN_INSN_BASE_MASK (insn))
+	  == CGEN_INSN_BASE_VALUE (insn))
+	{
+	  /* Printing is handled in two passes.  The first pass parses the
+	     machine insn and extracts the fields.  The second pass prints
+	     them.  */
+
+	  /* Make sure the entire insn is loaded into insn_value, if it
+	     can fit.  */
+	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	    {
+	      unsigned long full_insn_value;
+	      int rc = read_insn (cd, pc, info, buf,
+				  CGEN_INSN_BITSIZE (insn) / 8,
+				  & ex_info, & full_insn_value);
+	      if (rc != 0)
+		return rc;
+	      length = CGEN_EXTRACT_FN (cd, insn)
+		(cd, insn, &ex_info, full_insn_value, &fields, pc);
+	    }
+	  else
+	    length = CGEN_EXTRACT_FN (cd, insn)
+	      (cd, insn, &ex_info, insn_value_cropped, &fields, pc);
+
+	  /* Length < 0 -> error.  */
+	  if (length < 0)
+	    return length;
+	  if (length > 0)
+	    {
+	      CGEN_PRINT_FN (cd, insn) (cd, info, insn, &fields, pc, length);
+	      /* Length is in bits, result is in bytes.  */
+	      return length / 8;
+	    }
+	}
+
+      insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+    }
+
+  return 0;
+}
+
+/* Default value for CGEN_PRINT_INSN.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occured fetching bytes.  */
+
+#ifndef CGEN_PRINT_INSN
+#define CGEN_PRINT_INSN default_print_insn
+#endif
+
+static int
+default_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
+{
+  bfd_byte buf[CGEN_MAX_INSN_SIZE];
+  int buflen;
+  int status;
+
+  /* Attempt to read the base part of the insn.  */
+  buflen = cd->base_insn_bitsize / 8;
+  status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  /* Try again with the minimum part, if min < base.  */
+  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))
+    {
+      buflen = cd->min_insn_bitsize / 8;
+      status = (*info->read_memory_func) (pc, buf, buflen, info);
+    }
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  return print_insn (cd, pc, info, buf, buflen);
+}
+
+/* Main entry point.
+   Print one instruction from PC on INFO->STREAM.
+   Return the size of the instruction (in bytes).  */
+
+typedef struct cpu_desc_list
+{
+  struct cpu_desc_list *next;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian;
+  CGEN_CPU_DESC cd;
+} cpu_desc_list;
+
+int
+print_insn_lm32 (bfd_vma pc, disassemble_info *info)
+{
+  static cpu_desc_list *cd_list = 0;
+  cpu_desc_list *cl = 0;
+  static CGEN_CPU_DESC cd = 0;
+  static CGEN_BITSET *prev_isa;
+  static int prev_mach;
+  static int prev_endian;
+  int length;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian = (info->endian == BFD_ENDIAN_BIG
+		? CGEN_ENDIAN_BIG
+		: CGEN_ENDIAN_LITTLE);
+  enum bfd_architecture arch;
+
+  /* ??? gdb will set mach but leave the architecture as "unknown" */
+#ifndef CGEN_BFD_ARCH
+#define CGEN_BFD_ARCH bfd_arch_lm32
+#endif
+  arch = info->arch;
+  if (arch == bfd_arch_unknown)
+    arch = CGEN_BFD_ARCH;
+   
+  /* There's no standard way to compute the machine or isa number
+     so we leave it to the target.  */
+#ifdef CGEN_COMPUTE_MACH
+  mach = CGEN_COMPUTE_MACH (info);
+#else
+  mach = info->mach;
+#endif
+
+#ifdef CGEN_COMPUTE_ISA
+  {
+    static CGEN_BITSET *permanent_isa;
+
+    if (!permanent_isa)
+      permanent_isa = cgen_bitset_create (MAX_ISAS);
+    isa = permanent_isa;
+    cgen_bitset_clear (isa);
+    cgen_bitset_add (isa, CGEN_COMPUTE_ISA (info));
+  }
+#else
+  isa = info->insn_sets;
+#endif
+
+  /* If we've switched cpu's, try to find a handle we've used before */
+  if (cd
+      && (cgen_bitset_compare (isa, prev_isa) != 0
+	  || mach != prev_mach
+	  || endian != prev_endian))
+    {
+      cd = 0;
+      for (cl = cd_list; cl; cl = cl->next)
+	{
+	  if (cgen_bitset_compare (cl->isa, isa) == 0 &&
+	      cl->mach == mach &&
+	      cl->endian == endian)
+	    {
+	      cd = cl->cd;
+ 	      prev_isa = cd->isas;
+	      break;
+	    }
+	}
+    } 
+
+  /* If we haven't initialized yet, initialize the opcode table.  */
+  if (! cd)
+    {
+      const bfd_arch_info_type *arch_type = bfd_lookup_arch (arch, mach);
+      const char *mach_name;
+
+      if (!arch_type)
+	abort ();
+      mach_name = arch_type->printable_name;
+
+      prev_isa = cgen_bitset_copy (isa);
+      prev_mach = mach;
+      prev_endian = endian;
+      cd = lm32_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,
+				 CGEN_CPU_OPEN_BFDMACH, mach_name,
+				 CGEN_CPU_OPEN_ENDIAN, prev_endian,
+				 CGEN_CPU_OPEN_END);
+      if (!cd)
+	abort ();
+
+      /* Save this away for future reference.  */
+      cl = xmalloc (sizeof (struct cpu_desc_list));
+      cl->cd = cd;
+      cl->isa = prev_isa;
+      cl->mach = mach;
+      cl->endian = endian;
+      cl->next = cd_list;
+      cd_list = cl;
+
+      lm32_cgen_init_dis (cd);
+    }
+
+  /* We try to have as much common code as possible.
+     But at this point some targets need to take over.  */
+  /* ??? Some targets may need a hook elsewhere.  Try to avoid this,
+     but if not possible try to move this hook elsewhere rather than
+     have two hooks.  */
+  length = CGEN_PRINT_INSN (cd, pc, info);
+  if (length > 0)
+    return length;
+  if (length < 0)
+    return -1;
+
+  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
+  return cd->default_insn_bitsize / 8;
+}
diff --git a/opcodes/lm32-ibld.c b/opcodes/lm32-ibld.c
new file mode 100644
index 0000000..21d8844
--- /dev/null
+++ b/opcodes/lm32-ibld.c
@@ -0,0 +1,1025 @@
+/* Instruction building/extraction support for lm32. -*- C -*-
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN: Cpu tools GENerator.
+   - the resultant file is machine generated, cgen-ibld.in isn't
+
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "dis-asm.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "lm32-desc.h"
+#include "lm32-opc.h"
+#include "opintl.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+/* Used by the ifield rtx function.  */
+#define FLD(f) (fields->f)
+
+static const char * insert_normal
+  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
+static const char * insert_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *,
+   CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+static int extract_normal
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
+   unsigned int, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, bfd_vma, long *);
+static int extract_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
+   CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+#if CGEN_INT_INSN_P
+static void put_insn_int_value
+  (CGEN_CPU_DESC, CGEN_INSN_BYTES_PTR, int, int, CGEN_INSN_INT);
+#endif
+#if ! CGEN_INT_INSN_P
+static CGEN_INLINE void insert_1
+  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+static CGEN_INLINE int fill_cache
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
+static CGEN_INLINE long extract_1
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
+#endif
+
+/* Operand insertion.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of insert_normal.  */
+
+static CGEN_INLINE void
+insert_1 (CGEN_CPU_DESC cd,
+	  unsigned long value,
+	  int start,
+	  int length,
+	  int word_length,
+	  unsigned char *bufp)
+{
+  unsigned long x,mask;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  x = (x & ~(mask << shift)) | ((value & mask) << shift);
+
+  cgen_put_insn_value (cd, bufp, word_length, (bfd_vma) x);
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default insertion routine.
+
+   ATTRS is a mask of the boolean attributes.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   The result is an error message or NULL if success.  */
+
+/* ??? This duplicates functionality with bfd's howto table and
+   bfd_install_relocation.  */
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static const char *
+insert_normal (CGEN_CPU_DESC cd,
+	       long value,
+	       unsigned int attrs,
+	       unsigned int word_offset,
+	       unsigned int start,
+	       unsigned int length,
+	       unsigned int word_length,
+	       unsigned int total_length,
+	       CGEN_INSN_BYTES_PTR buffer)
+{
+  static char errbuf[100];
+  /* Written this way to avoid undefined behaviour.  */
+  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value.  */
+  if (length == 0)
+    return NULL;
+
+  if (word_length > 32)
+    abort ();
+
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset == 0
+	  && word_length > total_length)
+	word_length = total_length;
+    }
+
+  /* Ensure VALUE will fit.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
+    {
+      long minval = - (1L << (length - 1));
+      unsigned long maxval = mask;
+      
+      if ((value > 0 && (unsigned long) value > maxval)
+	  || value < minval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (%ld not between %ld and %lu)"),
+		   value, minval, maxval);
+	  return errbuf;
+	}
+    }
+  else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
+    {
+      unsigned long maxval = mask;
+      unsigned long val = (unsigned long) value;
+
+      /* For hosts with a word size > 32 check to see if value has been sign
+	 extended beyond 32 bits.  If so then ignore these higher sign bits
+	 as the user is attempting to store a 32-bit signed value into an
+	 unsigned 32-bit field which is allowed.  */
+      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+	val &= 0xFFFFFFFF;
+
+      if (val > maxval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (0x%lx not between 0 and 0x%lx)"),
+		   val, maxval);
+	  return errbuf;
+	}
+    }
+  else
+    {
+      if (! cgen_signed_overflow_ok_p (cd))
+	{
+	  long minval = - (1L << (length - 1));
+	  long maxval =   (1L << (length - 1)) - 1;
+	  
+	  if (value < minval || value > maxval)
+	    {
+	      sprintf
+		/* xgettext:c-format */
+		(errbuf, _("operand out of range (%ld not between %ld and %ld)"),
+		 value, minval, maxval);
+	      return errbuf;
+	    }
+	}
+    }
+
+#if CGEN_INT_INSN_P
+
+  {
+    int shift;
+
+    if (CGEN_INSN_LSB0_P)
+      shift = (word_offset + start + 1) - length;
+    else
+      shift = total_length - (word_offset + start + length);
+    *buffer = (*buffer & ~(mask << shift)) | ((value & mask) << shift);
+  }
+
+#else /* ! CGEN_INT_INSN_P */
+
+  {
+    unsigned char *bufp = (unsigned char *) buffer + word_offset / 8;
+
+    insert_1 (cd, value, start, length, word_length, bufp);
+  }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  return NULL;
+}
+
+/* Default insn builder (insert handler).
+   The instruction is recorded in CGEN_INT_INSN_P byte order (meaning
+   that if CGEN_INSN_BYTES_PTR is an int * and thus, the value is
+   recorded in host byte order, otherwise BUFFER is an array of bytes
+   and the value is recorded in target byte order).
+   The result is an error message or NULL if success.  */
+
+static const char *
+insert_insn_normal (CGEN_CPU_DESC cd,
+		    const CGEN_INSN * insn,
+		    CGEN_FIELDS * fields,
+		    CGEN_INSN_BYTES_PTR buffer,
+		    bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  unsigned long value;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+
+  CGEN_INIT_INSERT (cd);
+  value = CGEN_INSN_BASE_VALUE (insn);
+
+  /* If we're recording insns as numbers (rather than a string of bytes),
+     target byte order handling is deferred until later.  */
+
+#if CGEN_INT_INSN_P
+
+  put_insn_int_value (cd, buffer, cd->base_insn_bitsize,
+		      CGEN_FIELDS_BITSIZE (fields), value);
+
+#else
+
+  cgen_put_insn_value (cd, buffer, min ((unsigned) cd->base_insn_bitsize,
+					(unsigned) CGEN_FIELDS_BITSIZE (fields)),
+		       value);
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* ??? It would be better to scan the format's fields.
+     Still need to be able to insert a value based on the operand though;
+     e.g. storing a branch displacement that got resolved later.
+     Needs more thought first.  */
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); * syn; ++ syn)
+    {
+      const char *errmsg;
+
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	continue;
+
+      errmsg = (* cd->insert_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+				       fields, buffer, pc);
+      if (errmsg)
+	return errmsg;
+    }
+
+  return NULL;
+}
+
+#if CGEN_INT_INSN_P
+/* Cover function to store an insn value into an integral insn.  Must go here
+   because it needs <prefix>-desc.h for CGEN_INT_INSN_P.  */
+
+static void
+put_insn_int_value (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+		    CGEN_INSN_BYTES_PTR buf,
+		    int length,
+		    int insn_length,
+		    CGEN_INSN_INT value)
+{
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     length may be too big.  */
+  if (length > insn_length)
+    *buf = value;
+  else
+    {
+      int shift = insn_length - length;
+      /* Written this way to avoid undefined behaviour.  */
+      CGEN_INSN_INT mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+      *buf = (*buf & ~(mask << shift)) | ((value & mask) << shift);
+    }
+}
+#endif
+
+/* Operand extraction.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of extract_normal.
+   Ensure sufficient bytes are cached in EX_INFO.
+   OFFSET is the offset in bytes from the start of the insn of the value.
+   BYTES is the length of the needed value.
+   Returns 1 for success, 0 for failure.  */
+
+static CGEN_INLINE int
+fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	    CGEN_EXTRACT_INFO *ex_info,
+	    int offset,
+	    int bytes,
+	    bfd_vma pc)
+{
+  /* It's doubtful that the middle part has already been fetched so
+     we don't optimize that case.  kiss.  */
+  unsigned int mask;
+  disassemble_info *info = (disassemble_info *) ex_info->dis_info;
+
+  /* First do a quick check.  */
+  mask = (1 << bytes) - 1;
+  if (((ex_info->valid >> offset) & mask) == mask)
+    return 1;
+
+  /* Search for the first byte we need to read.  */
+  for (mask = 1 << offset; bytes > 0; --bytes, ++offset, mask <<= 1)
+    if (! (mask & ex_info->valid))
+      break;
+
+  if (bytes)
+    {
+      int status;
+
+      pc += offset;
+      status = (*info->read_memory_func)
+	(pc, ex_info->insn_bytes + offset, bytes, info);
+
+      if (status != 0)
+	{
+	  (*info->memory_error_func) (status, pc, info);
+	  return 0;
+	}
+
+      ex_info->valid |= ((1 << bytes) - 1) << offset;
+    }
+
+  return 1;
+}
+
+/* Subroutine of extract_normal.  */
+
+static CGEN_INLINE long
+extract_1 (CGEN_CPU_DESC cd,
+	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+	   int start,
+	   int length,
+	   int word_length,
+	   unsigned char *bufp,
+	   bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  unsigned long x;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  return x >> shift;
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default extraction routine.
+
+   INSN_VALUE is the first base_insn_bitsize bits of the insn in host order,
+   or sometimes less for cases like the m32r where the base insn size is 32
+   but some insns are 16 bits.
+   ATTRS is a mask of the boolean attributes.  We only need `SIGNED',
+   but for generality we take a bitmask of all of them.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   Returns 1 for success, 0 for failure.  */
+
+/* ??? The return code isn't properly used.  wip.  */
+
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static int
+extract_normal (CGEN_CPU_DESC cd,
+#if ! CGEN_INT_INSN_P
+		CGEN_EXTRACT_INFO *ex_info,
+#else
+		CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+#endif
+		CGEN_INSN_INT insn_value,
+		unsigned int attrs,
+		unsigned int word_offset,
+		unsigned int start,
+		unsigned int length,
+		unsigned int word_length,
+		unsigned int total_length,
+#if ! CGEN_INT_INSN_P
+		bfd_vma pc,
+#else
+		bfd_vma pc ATTRIBUTE_UNUSED,
+#endif
+		long *valuep)
+{
+  long value, mask;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value
+     so give it a standard value of zero.  */
+  if (length == 0)
+    {
+      *valuep = 0;
+      return 1;
+    }
+
+  if (word_length > 32)
+    abort ();
+
+  /* For architectures with insns smaller than the insn-base-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset + word_length > total_length)
+	word_length = total_length - word_offset;
+    }
+
+  /* Does the value reside in INSN_VALUE, and at the right alignment?  */
+
+  if (CGEN_INT_INSN_P || (word_offset == 0 && word_length == total_length))
+    {
+      if (CGEN_INSN_LSB0_P)
+	value = insn_value >> ((word_offset + start + 1) - length);
+      else
+	value = insn_value >> (total_length - ( word_offset + start + length));
+    }
+
+#if ! CGEN_INT_INSN_P
+
+  else
+    {
+      unsigned char *bufp = ex_info->insn_bytes + word_offset / 8;
+
+      if (word_length > 32)
+	abort ();
+
+      if (fill_cache (cd, ex_info, word_offset / 8, word_length / 8, pc) == 0)
+	return 0;
+
+      value = extract_1 (cd, ex_info, start, length, word_length, bufp, pc);
+    }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  value &= mask;
+  /* sign extend? */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED)
+      && (value & (1L << (length - 1))))
+    value |= ~mask;
+
+  *valuep = value;
+
+  return 1;
+}
+
+/* Default insn extractor.
+
+   INSN_VALUE is the first base_insn_bitsize bits, translated to host order.
+   The extracted fields are stored in FIELDS.
+   EX_INFO is used to handle reading variable length insns.
+   Return the length of the insn in bits, or 0 if no match,
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+extract_insn_normal (CGEN_CPU_DESC cd,
+		     const CGEN_INSN *insn,
+		     CGEN_EXTRACT_INFO *ex_info,
+		     CGEN_INSN_INT insn_value,
+		     CGEN_FIELDS *fields,
+		     bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+  CGEN_INIT_EXTRACT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      int length;
+
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	continue;
+
+      length = (* cd->extract_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+					ex_info, insn_value, fields, pc);
+      if (length <= 0)
+	return length;
+    }
+
+  /* We recognized and successfully extracted this insn.  */
+  return CGEN_INSN_BITSIZE (insn);
+}
+
+/* Machine generated code added here.  */
+
+const char * lm32_cgen_insert_operand
+  (CGEN_CPU_DESC, int, CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+
+/* Main entry point for operand insertion.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  It's also needed by GAS to insert operands that couldn't be
+   resolved during parsing.  */
+
+const char *
+lm32_cgen_insert_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     CGEN_INSN_BYTES_PTR buffer,
+			     bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  const char * errmsg = NULL;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      {
+        long value = fields->f_branch;
+        value = ((int) (((value) - (pc))) >> (2));
+        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, buffer);
+      }
+      break;
+    case LM32_OPERAND_CALL :
+      {
+        long value = fields->f_call;
+        value = ((int) (((value) - (pc))) >> (2));
+        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, buffer);
+      }
+      break;
+    case LM32_OPERAND_CSR :
+      errmsg = insert_normal (cd, fields->f_csr, 0, 0, 25, 5, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      errmsg = insert_normal (cd, fields->f_exception, 0, 0, 25, 26, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_GOT16 :
+      errmsg = insert_normal (cd, fields->f_imm, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_GP16 :
+      errmsg = insert_normal (cd, fields->f_imm, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_HI16 :
+      errmsg = insert_normal (cd, fields->f_uimm, 0, 0, 15, 16, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_IMM :
+      errmsg = insert_normal (cd, fields->f_imm, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_LO16 :
+      errmsg = insert_normal (cd, fields->f_uimm, 0, 0, 15, 16, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_R0 :
+      errmsg = insert_normal (cd, fields->f_r0, 0, 0, 25, 5, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_R1 :
+      errmsg = insert_normal (cd, fields->f_r1, 0, 0, 20, 5, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_R2 :
+      errmsg = insert_normal (cd, fields->f_r2, 0, 0, 15, 5, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_SHIFT :
+      errmsg = insert_normal (cd, fields->f_shift, 0, 0, 4, 5, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_UIMM :
+      errmsg = insert_normal (cd, fields->f_uimm, 0, 0, 15, 16, 32, total_length, buffer);
+      break;
+    case LM32_OPERAND_USER :
+      errmsg = insert_normal (cd, fields->f_user, 0, 0, 10, 11, 32, total_length, buffer);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while building insn.\n"),
+	       opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+int lm32_cgen_extract_operand
+  (CGEN_CPU_DESC, int, CGEN_EXTRACT_INFO *, CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+
+/* Main entry point for operand extraction.
+   The result is <= 0 for error, >0 for success.
+   ??? Actual values aren't well defined right now.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+int
+lm32_cgen_extract_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_EXTRACT_INFO *ex_info,
+			     CGEN_INSN_INT insn_value,
+			     CGEN_FIELDS * fields,
+			     bfd_vma pc)
+{
+  /* Assume success (for those operands that are nops).  */
+  int length = 1;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      {
+        long value;
+        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 15, 16, 32, total_length, pc, & value);
+        value = ((pc) + (((int) (((value) << (16))) >> (14))));
+        fields->f_branch = value;
+      }
+      break;
+    case LM32_OPERAND_CALL :
+      {
+        long value;
+        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, pc, & value);
+        value = ((pc) + (((int) (((value) << (6))) >> (4))));
+        fields->f_call = value;
+      }
+      break;
+    case LM32_OPERAND_CSR :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_csr);
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 26, 32, total_length, pc, & fields->f_exception);
+      break;
+    case LM32_OPERAND_GOT16 :
+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & fields->f_imm);
+      break;
+    case LM32_OPERAND_GP16 :
+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & fields->f_imm);
+      break;
+    case LM32_OPERAND_HI16 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 16, 32, total_length, pc, & fields->f_uimm);
+      break;
+    case LM32_OPERAND_IMM :
+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & fields->f_imm);
+      break;
+    case LM32_OPERAND_LO16 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 16, 32, total_length, pc, & fields->f_uimm);
+      break;
+    case LM32_OPERAND_R0 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_r0);
+      break;
+    case LM32_OPERAND_R1 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 20, 5, 32, total_length, pc, & fields->f_r1);
+      break;
+    case LM32_OPERAND_R2 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 5, 32, total_length, pc, & fields->f_r2);
+      break;
+    case LM32_OPERAND_SHIFT :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 4, 5, 32, total_length, pc, & fields->f_shift);
+      break;
+    case LM32_OPERAND_UIMM :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 16, 32, total_length, pc, & fields->f_uimm);
+      break;
+    case LM32_OPERAND_USER :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 11, 32, total_length, pc, & fields->f_user);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while decoding insn.\n"),
+	       opindex);
+      abort ();
+    }
+
+  return length;
+}
+
+cgen_insert_fn * const lm32_cgen_insert_handlers[] = 
+{
+  insert_insn_normal,
+};
+
+cgen_extract_fn * const lm32_cgen_extract_handlers[] = 
+{
+  extract_insn_normal,
+};
+
+int lm32_cgen_get_int_operand     (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+bfd_vma lm32_cgen_get_vma_operand (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+
+/* Getting values from cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they return.
+   TODO: floating point, inlining support, remove cases where result type
+   not appropriate.  */
+
+int
+lm32_cgen_get_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  int value;
+
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      value = fields->f_branch;
+      break;
+    case LM32_OPERAND_CALL :
+      value = fields->f_call;
+      break;
+    case LM32_OPERAND_CSR :
+      value = fields->f_csr;
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      value = fields->f_exception;
+      break;
+    case LM32_OPERAND_GOT16 :
+      value = fields->f_imm;
+      break;
+    case LM32_OPERAND_GP16 :
+      value = fields->f_imm;
+      break;
+    case LM32_OPERAND_HI16 :
+      value = fields->f_uimm;
+      break;
+    case LM32_OPERAND_IMM :
+      value = fields->f_imm;
+      break;
+    case LM32_OPERAND_LO16 :
+      value = fields->f_uimm;
+      break;
+    case LM32_OPERAND_R0 :
+      value = fields->f_r0;
+      break;
+    case LM32_OPERAND_R1 :
+      value = fields->f_r1;
+      break;
+    case LM32_OPERAND_R2 :
+      value = fields->f_r2;
+      break;
+    case LM32_OPERAND_SHIFT :
+      value = fields->f_shift;
+      break;
+    case LM32_OPERAND_UIMM :
+      value = fields->f_uimm;
+      break;
+    case LM32_OPERAND_USER :
+      value = fields->f_user;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+bfd_vma
+lm32_cgen_get_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  bfd_vma value;
+
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      value = fields->f_branch;
+      break;
+    case LM32_OPERAND_CALL :
+      value = fields->f_call;
+      break;
+    case LM32_OPERAND_CSR :
+      value = fields->f_csr;
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      value = fields->f_exception;
+      break;
+    case LM32_OPERAND_GOT16 :
+      value = fields->f_imm;
+      break;
+    case LM32_OPERAND_GP16 :
+      value = fields->f_imm;
+      break;
+    case LM32_OPERAND_HI16 :
+      value = fields->f_uimm;
+      break;
+    case LM32_OPERAND_IMM :
+      value = fields->f_imm;
+      break;
+    case LM32_OPERAND_LO16 :
+      value = fields->f_uimm;
+      break;
+    case LM32_OPERAND_R0 :
+      value = fields->f_r0;
+      break;
+    case LM32_OPERAND_R1 :
+      value = fields->f_r1;
+      break;
+    case LM32_OPERAND_R2 :
+      value = fields->f_r2;
+      break;
+    case LM32_OPERAND_SHIFT :
+      value = fields->f_shift;
+      break;
+    case LM32_OPERAND_UIMM :
+      value = fields->f_uimm;
+      break;
+    case LM32_OPERAND_USER :
+      value = fields->f_user;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+void lm32_cgen_set_int_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, int);
+void lm32_cgen_set_vma_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, bfd_vma);
+
+/* Stuffing values in cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they accept.
+   TODO: floating point, inlining support, remove cases where argument type
+   not appropriate.  */
+
+void
+lm32_cgen_set_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     int value)
+{
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      fields->f_branch = value;
+      break;
+    case LM32_OPERAND_CALL :
+      fields->f_call = value;
+      break;
+    case LM32_OPERAND_CSR :
+      fields->f_csr = value;
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      fields->f_exception = value;
+      break;
+    case LM32_OPERAND_GOT16 :
+      fields->f_imm = value;
+      break;
+    case LM32_OPERAND_GP16 :
+      fields->f_imm = value;
+      break;
+    case LM32_OPERAND_HI16 :
+      fields->f_uimm = value;
+      break;
+    case LM32_OPERAND_IMM :
+      fields->f_imm = value;
+      break;
+    case LM32_OPERAND_LO16 :
+      fields->f_uimm = value;
+      break;
+    case LM32_OPERAND_R0 :
+      fields->f_r0 = value;
+      break;
+    case LM32_OPERAND_R1 :
+      fields->f_r1 = value;
+      break;
+    case LM32_OPERAND_R2 :
+      fields->f_r2 = value;
+      break;
+    case LM32_OPERAND_SHIFT :
+      fields->f_shift = value;
+      break;
+    case LM32_OPERAND_UIMM :
+      fields->f_uimm = value;
+      break;
+    case LM32_OPERAND_USER :
+      fields->f_user = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+void
+lm32_cgen_set_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     bfd_vma value)
+{
+  switch (opindex)
+    {
+    case LM32_OPERAND_BRANCH :
+      fields->f_branch = value;
+      break;
+    case LM32_OPERAND_CALL :
+      fields->f_call = value;
+      break;
+    case LM32_OPERAND_CSR :
+      fields->f_csr = value;
+      break;
+    case LM32_OPERAND_EXCEPTION :
+      fields->f_exception = value;
+      break;
+    case LM32_OPERAND_GOT16 :
+      fields->f_imm = value;
+      break;
+    case LM32_OPERAND_GP16 :
+      fields->f_imm = value;
+      break;
+    case LM32_OPERAND_HI16 :
+      fields->f_uimm = value;
+      break;
+    case LM32_OPERAND_IMM :
+      fields->f_imm = value;
+      break;
+    case LM32_OPERAND_LO16 :
+      fields->f_uimm = value;
+      break;
+    case LM32_OPERAND_R0 :
+      fields->f_r0 = value;
+      break;
+    case LM32_OPERAND_R1 :
+      fields->f_r1 = value;
+      break;
+    case LM32_OPERAND_R2 :
+      fields->f_r2 = value;
+      break;
+    case LM32_OPERAND_SHIFT :
+      fields->f_shift = value;
+      break;
+    case LM32_OPERAND_UIMM :
+      fields->f_uimm = value;
+      break;
+    case LM32_OPERAND_USER :
+      fields->f_user = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+/* Function to call before using the instruction builder tables.  */
+
+void
+lm32_cgen_init_ibld_table (CGEN_CPU_DESC cd)
+{
+  cd->insert_handlers = & lm32_cgen_insert_handlers[0];
+  cd->extract_handlers = & lm32_cgen_extract_handlers[0];
+
+  cd->insert_operand = lm32_cgen_insert_operand;
+  cd->extract_operand = lm32_cgen_extract_operand;
+
+  cd->get_int_operand = lm32_cgen_get_int_operand;
+  cd->set_int_operand = lm32_cgen_set_int_operand;
+  cd->get_vma_operand = lm32_cgen_get_vma_operand;
+  cd->set_vma_operand = lm32_cgen_set_vma_operand;
+}
diff --git a/opcodes/lm32-opc.c b/opcodes/lm32-opc.c
new file mode 100644
index 0000000..b1723b6
--- /dev/null
+++ b/opcodes/lm32-opc.c
@@ -0,0 +1,804 @@
+/* Instruction opcode table for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2007 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "lm32-desc.h"
+#include "lm32-opc.h"
+#include "libiberty.h"
+
+/* The hash functions are recorded here to help keep assembler code out of
+   the disassembler and vice versa.  */
+
+static int asm_hash_insn_p        (const CGEN_INSN *);
+static unsigned int asm_hash_insn (const char *);
+static int dis_hash_insn_p        (const CGEN_INSN *);
+static unsigned int dis_hash_insn (const char *, CGEN_INSN_INT);
+
+/* Instruction formats.  */
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define F(f) & lm32_cgen_ifld_table[LM32_##f]
+#else
+#define F(f) & lm32_cgen_ifld_table[LM32_/**/f]
+#endif
+static const CGEN_IFMT ifmt_empty ATTRIBUTE_UNUSED = {
+  0, 0, 0x0, { { 0 } }
+};
+
+static const CGEN_IFMT ifmt_add ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc0007ff, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV0) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_addi ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_IMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_andi ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_UIMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_andhii ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_UIMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_b ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc1fffff, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV0) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_bi ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_CALL) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_be ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_BRANCH) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_ori ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_UIMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_rcsr ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc1f07ff, { { F (F_OPCODE) }, { F (F_CSR) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV0) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_sextb ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc1f07ff, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV0) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_user ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_R2) }, { F (F_USER) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_wcsr ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc00ffff, { { F (F_OPCODE) }, { F (F_CSR) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV0) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_break ATTRIBUTE_UNUSED = {
+  32, 32, 0xffffffff, { { F (F_OPCODE) }, { F (F_EXCEPTION) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_bret ATTRIBUTE_UNUSED = {
+  32, 32, 0xffffffff, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV0) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mvi ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe00000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_IMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mvui ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe00000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_UIMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mvhi ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe00000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_UIMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mva ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe00000, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_IMM) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_nop ATTRIBUTE_UNUSED = {
+  32, 32, 0xffffffff, { { F (F_OPCODE) }, { F (F_R0) }, { F (F_R1) }, { F (F_IMM) }, { 0 } }
+};
+
+#undef F
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define A(a) (1 << CGEN_INSN_##a)
+#else
+#define A(a) (1 << CGEN_INSN_/**/a)
+#endif
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define OPERAND(op) LM32_OPERAND_##op
+#else
+#define OPERAND(op) LM32_OPERAND_/**/op
+#endif
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The instruction table.  */
+
+static const CGEN_OPCODE lm32_cgen_insn_opcode_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { { 0, 0, 0, 0 }, {{0}}, 0, {0}},
+/* add $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xb4000000 }
+  },
+/* addi $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x34000000 }
+  },
+/* and $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xa0000000 }
+  },
+/* andi $r1,$r0,$uimm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (UIMM), 0 } },
+    & ifmt_andi, { 0x20000000 }
+  },
+/* andhi $r1,$r0,$hi16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (HI16), 0 } },
+    & ifmt_andhii, { 0x60000000 }
+  },
+/* b $r0 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), 0 } },
+    & ifmt_b, { 0xc0000000 }
+  },
+/* bi $call */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (CALL), 0 } },
+    & ifmt_bi, { 0xe0000000 }
+  },
+/* be $r0,$r1,$branch */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), ',', OP (R1), ',', OP (BRANCH), 0 } },
+    & ifmt_be, { 0x44000000 }
+  },
+/* bg $r0,$r1,$branch */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), ',', OP (R1), ',', OP (BRANCH), 0 } },
+    & ifmt_be, { 0x48000000 }
+  },
+/* bge $r0,$r1,$branch */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), ',', OP (R1), ',', OP (BRANCH), 0 } },
+    & ifmt_be, { 0x4c000000 }
+  },
+/* bgeu $r0,$r1,$branch */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), ',', OP (R1), ',', OP (BRANCH), 0 } },
+    & ifmt_be, { 0x50000000 }
+  },
+/* bgu $r0,$r1,$branch */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), ',', OP (R1), ',', OP (BRANCH), 0 } },
+    & ifmt_be, { 0x54000000 }
+  },
+/* bne $r0,$r1,$branch */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), ',', OP (R1), ',', OP (BRANCH), 0 } },
+    & ifmt_be, { 0x5c000000 }
+  },
+/* call $r0 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R0), 0 } },
+    & ifmt_b, { 0xd8000000 }
+  },
+/* calli $call */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (CALL), 0 } },
+    & ifmt_bi, { 0xf8000000 }
+  },
+/* cmpe $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xe4000000 }
+  },
+/* cmpei $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x64000000 }
+  },
+/* cmpg $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xe8000000 }
+  },
+/* cmpgi $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x68000000 }
+  },
+/* cmpge $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xec000000 }
+  },
+/* cmpgei $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x6c000000 }
+  },
+/* cmpgeu $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xf0000000 }
+  },
+/* cmpgeui $r1,$r0,$uimm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (UIMM), 0 } },
+    & ifmt_andi, { 0x70000000 }
+  },
+/* cmpgu $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xf4000000 }
+  },
+/* cmpgui $r1,$r0,$uimm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (UIMM), 0 } },
+    & ifmt_andi, { 0x74000000 }
+  },
+/* cmpne $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xfc000000 }
+  },
+/* cmpnei $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x7c000000 }
+  },
+/* divu $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0x8c000000 }
+  },
+/* lb $r1,($r0+$imm) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', '(', OP (R0), '+', OP (IMM), ')', 0 } },
+    & ifmt_addi, { 0x10000000 }
+  },
+/* lbu $r1,($r0+$imm) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', '(', OP (R0), '+', OP (IMM), ')', 0 } },
+    & ifmt_addi, { 0x40000000 }
+  },
+/* lh $r1,($r0+$imm) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', '(', OP (R0), '+', OP (IMM), ')', 0 } },
+    & ifmt_addi, { 0x1c000000 }
+  },
+/* lhu $r1,($r0+$imm) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', '(', OP (R0), '+', OP (IMM), ')', 0 } },
+    & ifmt_addi, { 0x2c000000 }
+  },
+/* lw $r1,($r0+$imm) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', '(', OP (R0), '+', OP (IMM), ')', 0 } },
+    & ifmt_addi, { 0x28000000 }
+  },
+/* modu $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xc4000000 }
+  },
+/* mul $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0x88000000 }
+  },
+/* muli $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x8000000 }
+  },
+/* nor $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0x84000000 }
+  },
+/* nori $r1,$r0,$uimm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (UIMM), 0 } },
+    & ifmt_andi, { 0x4000000 }
+  },
+/* or $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xb8000000 }
+  },
+/* ori $r1,$r0,$lo16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (LO16), 0 } },
+    & ifmt_ori, { 0x38000000 }
+  },
+/* orhi $r1,$r0,$hi16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (HI16), 0 } },
+    & ifmt_andhii, { 0x78000000 }
+  },
+/* rcsr $r2,$csr */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (CSR), 0 } },
+    & ifmt_rcsr, { 0x90000000 }
+  },
+/* sb ($r0+$imm),$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', '(', OP (R0), '+', OP (IMM), ')', ',', OP (R1), 0 } },
+    & ifmt_addi, { 0x30000000 }
+  },
+/* sextb $r2,$r0 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), 0 } },
+    & ifmt_sextb, { 0xb0000000 }
+  },
+/* sexth $r2,$r0 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), 0 } },
+    & ifmt_sextb, { 0xdc000000 }
+  },
+/* sh ($r0+$imm),$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', '(', OP (R0), '+', OP (IMM), ')', ',', OP (R1), 0 } },
+    & ifmt_addi, { 0xc000000 }
+  },
+/* sl $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xbc000000 }
+  },
+/* sli $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x3c000000 }
+  },
+/* sr $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0x94000000 }
+  },
+/* sri $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x14000000 }
+  },
+/* sru $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0x80000000 }
+  },
+/* srui $r1,$r0,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (IMM), 0 } },
+    & ifmt_addi, { 0x0 }
+  },
+/* sub $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xc8000000 }
+  },
+/* sw ($r0+$imm),$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', '(', OP (R0), '+', OP (IMM), ')', ',', OP (R1), 0 } },
+    & ifmt_addi, { 0x58000000 }
+  },
+/* user $r2,$r0,$r1,$user */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), ',', OP (USER), 0 } },
+    & ifmt_user, { 0xcc000000 }
+  },
+/* wcsr $csr,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (CSR), ',', OP (R1), 0 } },
+    & ifmt_wcsr, { 0xd0000000 }
+  },
+/* xor $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0x98000000 }
+  },
+/* xori $r1,$r0,$uimm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (UIMM), 0 } },
+    & ifmt_andi, { 0x18000000 }
+  },
+/* xnor $r2,$r0,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), ',', OP (R1), 0 } },
+    & ifmt_add, { 0xa4000000 }
+  },
+/* xnori $r1,$r0,$uimm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (R0), ',', OP (UIMM), 0 } },
+    & ifmt_andi, { 0x24000000 }
+  },
+/* break */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_break, { 0xac000002 }
+  },
+/* scall */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_break, { 0xac000007 }
+  },
+/* bret */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_bret, { 0xc3e00000 }
+  },
+/* eret */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_bret, { 0xc3c00000 }
+  },
+/* ret */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_bret, { 0xc3a00000 }
+  },
+/* mv $r2,$r0 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), 0 } },
+    & ifmt_sextb, { 0xb8000000 }
+  },
+/* mvi $r1,$imm */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (IMM), 0 } },
+    & ifmt_mvi, { 0x34000000 }
+  },
+/* mvu $r1,$lo16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (LO16), 0 } },
+    & ifmt_mvui, { 0x38000000 }
+  },
+/* mvhi $r1,$hi16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (HI16), 0 } },
+    & ifmt_mvhi, { 0x78000000 }
+  },
+/* mva $r1,$gp16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (GP16), 0 } },
+    & ifmt_mva, { 0x37400000 }
+  },
+/* not $r2,$r0 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R2), ',', OP (R0), 0 } },
+    & ifmt_sextb, { 0xa4000000 }
+  },
+/* nop */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_nop, { 0x34000000 }
+  },
+/* lb $r1,$gp16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (GP16), 0 } },
+    & ifmt_mva, { 0x13400000 }
+  },
+/* lbu $r1,$gp16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (GP16), 0 } },
+    & ifmt_mva, { 0x43400000 }
+  },
+/* lh $r1,$gp16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (GP16), 0 } },
+    & ifmt_mva, { 0x1f400000 }
+  },
+/* lhu $r1,$gp16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (GP16), 0 } },
+    & ifmt_mva, { 0x2f400000 }
+  },
+/* lw $r1,$gp16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', OP (GP16), 0 } },
+    & ifmt_mva, { 0x2b400000 }
+  },
+/* sb $gp16,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (GP16), ',', OP (R1), 0 } },
+    & ifmt_mva, { 0x33400000 }
+  },
+/* sh $gp16,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (GP16), ',', OP (R1), 0 } },
+    & ifmt_mva, { 0xf400000 }
+  },
+/* sw $gp16,$r1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (GP16), ',', OP (R1), 0 } },
+    & ifmt_mva, { 0x5b400000 }
+  },
+/* lw $r1,(gp+$got16) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (R1), ',', '(', 'g', 'p', '+', OP (GOT16), ')', 0 } },
+    & ifmt_mva, { 0x2b400000 }
+  },
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+/* Formats for ALIAS macro-insns.  */
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define F(f) & lm32_cgen_ifld_table[LM32_##f]
+#else
+#define F(f) & lm32_cgen_ifld_table[LM32_/**/f]
+#endif
+#undef F
+
+/* Each non-simple macro entry points to an array of expansion possibilities.  */
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define A(a) (1 << CGEN_INSN_##a)
+#else
+#define A(a) (1 << CGEN_INSN_/**/a)
+#endif
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define OPERAND(op) LM32_OPERAND_##op
+#else
+#define OPERAND(op) LM32_OPERAND_/**/op
+#endif
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The macro instruction table.  */
+
+static const CGEN_IBASE lm32_cgen_macro_insn_table[] =
+{
+};
+
+/* The macro instruction opcode table.  */
+
+static const CGEN_OPCODE lm32_cgen_macro_insn_opcode_table[] =
+{
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+#ifndef CGEN_ASM_HASH_P
+#define CGEN_ASM_HASH_P(insn) 1
+#endif
+
+#ifndef CGEN_DIS_HASH_P
+#define CGEN_DIS_HASH_P(insn) 1
+#endif
+
+/* Return non-zero if INSN is to be added to the hash table.
+   Targets are free to override CGEN_{ASM,DIS}_HASH_P in the .opc file.  */
+
+static int
+asm_hash_insn_p (insn)
+     const CGEN_INSN *insn ATTRIBUTE_UNUSED;
+{
+  return CGEN_ASM_HASH_P (insn);
+}
+
+static int
+dis_hash_insn_p (insn)
+     const CGEN_INSN *insn;
+{
+  /* If building the hash table and the NO-DIS attribute is present,
+     ignore.  */
+  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_NO_DIS))
+    return 0;
+  return CGEN_DIS_HASH_P (insn);
+}
+
+#ifndef CGEN_ASM_HASH
+#define CGEN_ASM_HASH_SIZE 127
+#ifdef CGEN_MNEMONIC_OPERANDS
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE)
+#else
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE) /*FIXME*/
+#endif
+#endif
+
+/* It doesn't make much sense to provide a default here,
+   but while this is under development we do.
+   BUFFER is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+#ifndef CGEN_DIS_HASH
+#define CGEN_DIS_HASH_SIZE 256
+#define CGEN_DIS_HASH(buf, value) (*(unsigned char *) (buf))
+#endif
+
+/* The result is the hash value of the insn.
+   Targets are free to override CGEN_{ASM,DIS}_HASH in the .opc file.  */
+
+static unsigned int
+asm_hash_insn (mnem)
+     const char * mnem;
+{
+  return CGEN_ASM_HASH (mnem);
+}
+
+/* BUF is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+static unsigned int
+dis_hash_insn (buf, value)
+     const char * buf ATTRIBUTE_UNUSED;
+     CGEN_INSN_INT value ATTRIBUTE_UNUSED;
+{
+  return CGEN_DIS_HASH (buf, value);
+}
+
+/* Set the recorded length of the insn in the CGEN_FIELDS struct.  */
+
+static void
+set_fields_bitsize (CGEN_FIELDS *fields, int size)
+{
+  CGEN_FIELDS_BITSIZE (fields) = size;
+}
+
+/* Function to call before using the operand instance table.
+   This plugs the opcode entries and macro instructions into the cpu table.  */
+
+void
+lm32_cgen_init_opcode_table (CGEN_CPU_DESC cd)
+{
+  int i;
+  int num_macros = (sizeof (lm32_cgen_macro_insn_table) /
+		    sizeof (lm32_cgen_macro_insn_table[0]));
+  const CGEN_IBASE *ib = & lm32_cgen_macro_insn_table[0];
+  const CGEN_OPCODE *oc = & lm32_cgen_macro_insn_opcode_table[0];
+  CGEN_INSN *insns = xmalloc (num_macros * sizeof (CGEN_INSN));
+
+  memset (insns, 0, num_macros * sizeof (CGEN_INSN));
+  for (i = 0; i < num_macros; ++i)
+    {
+      insns[i].base = &ib[i];
+      insns[i].opcode = &oc[i];
+      lm32_cgen_build_insn_regex (& insns[i]);
+    }
+  cd->macro_insn_table.init_entries = insns;
+  cd->macro_insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->macro_insn_table.num_init_entries = num_macros;
+
+  oc = & lm32_cgen_insn_opcode_table[0];
+  insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    {
+      insns[i].opcode = &oc[i];
+      lm32_cgen_build_insn_regex (& insns[i]);
+    }
+
+  cd->sizeof_fields = sizeof (CGEN_FIELDS);
+  cd->set_fields_bitsize = set_fields_bitsize;
+
+  cd->asm_hash_p = asm_hash_insn_p;
+  cd->asm_hash = asm_hash_insn;
+  cd->asm_hash_size = CGEN_ASM_HASH_SIZE;
+
+  cd->dis_hash_p = dis_hash_insn_p;
+  cd->dis_hash = dis_hash_insn;
+  cd->dis_hash_size = CGEN_DIS_HASH_SIZE;
+}
diff --git a/opcodes/lm32-opc.h b/opcodes/lm32-opc.h
new file mode 100644
index 0000000..0c960e0
--- /dev/null
+++ b/opcodes/lm32-opc.h
@@ -0,0 +1,103 @@
+/* Instruction opcode header for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2007 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef LM32_OPC_H
+#define LM32_OPC_H
+
+/* -- opc.h */
+
+/* Allows reason codes to be output when assembler errors occur.  */
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+#define CGEN_DIS_HASH_SIZE 64
+#define CGEN_DIS_HASH(buf,value) ((value >> 26) & 0x3f) 
+
+/* -- asm.c */
+/* Enum declaration for lm32 instruction types.  */
+typedef enum cgen_insn_type {
+  LM32_INSN_INVALID, LM32_INSN_ADD, LM32_INSN_ADDI, LM32_INSN_AND
+ , LM32_INSN_ANDI, LM32_INSN_ANDHII, LM32_INSN_B, LM32_INSN_BI
+ , LM32_INSN_BE, LM32_INSN_BG, LM32_INSN_BGE, LM32_INSN_BGEU
+ , LM32_INSN_BGU, LM32_INSN_BNE, LM32_INSN_CALL, LM32_INSN_CALLI
+ , LM32_INSN_CMPE, LM32_INSN_CMPEI, LM32_INSN_CMPG, LM32_INSN_CMPGI
+ , LM32_INSN_CMPGE, LM32_INSN_CMPGEI, LM32_INSN_CMPGEU, LM32_INSN_CMPGEUI
+ , LM32_INSN_CMPGU, LM32_INSN_CMPGUI, LM32_INSN_CMPNE, LM32_INSN_CMPNEI
+ , LM32_INSN_DIVU, LM32_INSN_LB, LM32_INSN_LBU, LM32_INSN_LH
+ , LM32_INSN_LHU, LM32_INSN_LW, LM32_INSN_MODU, LM32_INSN_MUL
+ , LM32_INSN_MULI, LM32_INSN_NOR, LM32_INSN_NORI, LM32_INSN_OR
+ , LM32_INSN_ORI, LM32_INSN_ORHII, LM32_INSN_RCSR, LM32_INSN_SB
+ , LM32_INSN_SEXTB, LM32_INSN_SEXTH, LM32_INSN_SH, LM32_INSN_SL
+ , LM32_INSN_SLI, LM32_INSN_SR, LM32_INSN_SRI, LM32_INSN_SRU
+ , LM32_INSN_SRUI, LM32_INSN_SUB, LM32_INSN_SW, LM32_INSN_USER
+ , LM32_INSN_WCSR, LM32_INSN_XOR, LM32_INSN_XORI, LM32_INSN_XNOR
+ , LM32_INSN_XNORI, LM32_INSN_BREAK, LM32_INSN_SCALL, LM32_INSN_BRET
+ , LM32_INSN_ERET, LM32_INSN_RET, LM32_INSN_MV, LM32_INSN_MVI
+ , LM32_INSN_MVUI, LM32_INSN_MVHI, LM32_INSN_MVA, LM32_INSN_NOT
+ , LM32_INSN_NOP, LM32_INSN_LBGPREL, LM32_INSN_LBUGPREL, LM32_INSN_LHGPREL
+ , LM32_INSN_LHUGPREL, LM32_INSN_LWGPREL, LM32_INSN_SBGPREL, LM32_INSN_SHGPREL
+ , LM32_INSN_SWGPREL, LM32_INSN_LWGOTREL
+} CGEN_INSN_TYPE;
+
+/* Index of `invalid' insn place holder.  */
+#define CGEN_INSN_INVALID LM32_INSN_INVALID
+
+/* Total number of insns in table.  */
+#define MAX_INSNS ((int) LM32_INSN_LWGOTREL + 1)
+
+/* This struct records data prior to insertion or after extraction.  */
+struct cgen_fields
+{
+  int length;
+  long f_nil;
+  long f_anyof;
+  long f_opcode;
+  long f_r0;
+  long f_r1;
+  long f_r2;
+  long f_resv0;
+  long f_shift;
+  long f_imm;
+  long f_uimm;
+  long f_csr;
+  long f_user;
+  long f_exception;
+  long f_branch;
+  long f_call;
+};
+
+#define CGEN_INIT_PARSE(od) \
+{\
+}
+#define CGEN_INIT_INSERT(od) \
+{\
+}
+#define CGEN_INIT_EXTRACT(od) \
+{\
+}
+#define CGEN_INIT_PRINT(od) \
+{\
+}
+
+
+#endif /* LM32_OPC_H */
diff --git a/opcodes/lm32-opinst.c b/opcodes/lm32-opinst.c
new file mode 100644
index 0000000..fd42e6d
--- /dev/null
+++ b/opcodes/lm32-opinst.c
@@ -0,0 +1,393 @@
+/* Semantic operand instances for lm32.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2007 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "lm32-desc.h"
+#include "lm32-opc.h"
+
+/* Operand references.  */
+
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#define OP_ENT(op) LM32_OPERAND_##op
+#else
+#define OP_ENT(op) LM32_OPERAND_/**/op
+#endif
+#define INPUT CGEN_OPINST_INPUT
+#define OUTPUT CGEN_OPINST_OUTPUT
+#define END CGEN_OPINST_END
+#define COND_REF CGEN_OPINST_COND_REF
+
+static const CGEN_OPINST sfmt_empty_ops[] ATTRIBUTE_UNUSED = {
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_add_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "r2", HW_H_GR, CGEN_MODE_SI, OP_ENT (R2), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_addi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "imm", HW_H_SINT, CGEN_MODE_INT, OP_ENT (IMM), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_andi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "uimm", HW_H_UINT, CGEN_MODE_UINT, OP_ENT (UIMM), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_andhii_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "hi16", HW_H_UINT, CGEN_MODE_SI, OP_ENT (HI16), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_b_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "f_r0", HW_H_UINT, CGEN_MODE_UINT, 0, 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_bi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "call", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (CALL), 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_be_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "branch", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (BRANCH), 0, COND_REF },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_call_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "h_gr_SI_29", HW_H_GR, CGEN_MODE_SI, 0, 29, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_calli_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "call", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (CALL), 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "h_gr_SI_29", HW_H_GR, CGEN_MODE_SI, 0, 29, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_divu_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "f_r0", HW_H_UINT, CGEN_MODE_UINT, 0, 0, 0 },
+  { INPUT, "f_r1", HW_H_UINT, CGEN_MODE_UINT, 0, 0, 0 },
+  { INPUT, "f_r2", HW_H_UINT, CGEN_MODE_UINT, 0, 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_QI_add__DFLT_r0_ext__SI_trunc__HI_imm", HW_H_MEMORY, CGEN_MODE_QI, 0, 0, 0 },
+  { INPUT, "imm", HW_H_SINT, CGEN_MODE_INT, OP_ENT (IMM), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lh_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_HI_add__DFLT_r0_ext__SI_trunc__HI_imm", HW_H_MEMORY, CGEN_MODE_HI, 0, 0, 0 },
+  { INPUT, "imm", HW_H_SINT, CGEN_MODE_INT, OP_ENT (IMM), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lw_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_SI_add__DFLT_r0_ext__SI_trunc__HI_imm", HW_H_MEMORY, CGEN_MODE_SI, 0, 0, 0 },
+  { INPUT, "imm", HW_H_SINT, CGEN_MODE_INT, OP_ENT (IMM), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ori_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "lo16", HW_H_UINT, CGEN_MODE_UINT, OP_ENT (LO16), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_rcsr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "csr", HW_H_CSR, CGEN_MODE_SI, OP_ENT (CSR), 0, 0 },
+  { OUTPUT, "r2", HW_H_GR, CGEN_MODE_SI, OP_ENT (R2), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "imm", HW_H_SINT, CGEN_MODE_INT, OP_ENT (IMM), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "h_memory_QI_add__DFLT_r0_ext__SI_trunc__HI_imm", HW_H_MEMORY, CGEN_MODE_QI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sextb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r2", HW_H_GR, CGEN_MODE_SI, OP_ENT (R2), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sh_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "imm", HW_H_SINT, CGEN_MODE_INT, OP_ENT (IMM), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "h_memory_HI_add__DFLT_r0_ext__SI_trunc__HI_imm", HW_H_MEMORY, CGEN_MODE_HI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sl_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_INT, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "r2", HW_H_GR, CGEN_MODE_SI, OP_ENT (R2), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sw_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "imm", HW_H_SINT, CGEN_MODE_INT, OP_ENT (IMM), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "h_memory_SI_add__DFLT_r0_ext__SI_trunc__HI_imm", HW_H_MEMORY, CGEN_MODE_SI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_user_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { INPUT, "user", HW_H_UINT, CGEN_MODE_UINT, OP_ENT (USER), 0, 0 },
+  { OUTPUT, "r2", HW_H_GR, CGEN_MODE_SI, OP_ENT (R2), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_wcsr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "f_csr", HW_H_UINT, CGEN_MODE_UINT, 0, 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_break_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_bret_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_mvui_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "lo16", HW_H_UINT, CGEN_MODE_UINT, OP_ENT (LO16), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_mva_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "gp16", HW_H_SINT, CGEN_MODE_INT, OP_ENT (GP16), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_nop_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lbgprel_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "gp16", HW_H_SINT, CGEN_MODE_INT, OP_ENT (GP16), 0, 0 },
+  { INPUT, "h_memory_QI_add__DFLT_r0_ext__SI_trunc__HI_gp16", HW_H_MEMORY, CGEN_MODE_QI, 0, 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lhgprel_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "gp16", HW_H_SINT, CGEN_MODE_INT, OP_ENT (GP16), 0, 0 },
+  { INPUT, "h_memory_HI_add__DFLT_r0_ext__SI_trunc__HI_gp16", HW_H_MEMORY, CGEN_MODE_HI, 0, 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lwgprel_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "gp16", HW_H_SINT, CGEN_MODE_INT, OP_ENT (GP16), 0, 0 },
+  { INPUT, "h_memory_SI_add__DFLT_r0_ext__SI_trunc__HI_gp16", HW_H_MEMORY, CGEN_MODE_SI, 0, 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { OUTPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sbgprel_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "gp16", HW_H_SINT, CGEN_MODE_INT, OP_ENT (GP16), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "h_memory_QI_add__DFLT_r0_ext__SI_trunc__HI_gp16", HW_H_MEMORY, CGEN_MODE_QI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_shgprel_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "gp16", HW_H_SINT, CGEN_MODE_INT, OP_ENT (GP16), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "h_memory_HI_add__DFLT_r0_ext__SI_trunc__HI_gp16", HW_H_MEMORY, CGEN_MODE_HI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_swgprel_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "gp16", HW_H_SINT, CGEN_MODE_INT, OP_ENT (GP16), 0, 0 },
+  { INPUT, "r0", HW_H_GR, CGEN_MODE_SI, OP_ENT (R0), 0, 0 },
+  { INPUT, "r1", HW_H_GR, CGEN_MODE_SI, OP_ENT (R1), 0, 0 },
+  { OUTPUT, "h_memory_SI_add__DFLT_r0_ext__SI_trunc__HI_gp16", HW_H_MEMORY, CGEN_MODE_SI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+#undef OP_ENT
+#undef INPUT
+#undef OUTPUT
+#undef END
+#undef COND_REF
+
+/* Operand instance lookup table.  */
+
+static const CGEN_OPINST *lm32_cgen_opinst_table[MAX_INSNS] = {
+  0,
+  & sfmt_add_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_andi_ops[0],
+  & sfmt_andhii_ops[0],
+  & sfmt_b_ops[0],
+  & sfmt_bi_ops[0],
+  & sfmt_be_ops[0],
+  & sfmt_be_ops[0],
+  & sfmt_be_ops[0],
+  & sfmt_be_ops[0],
+  & sfmt_be_ops[0],
+  & sfmt_be_ops[0],
+  & sfmt_call_ops[0],
+  & sfmt_calli_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_andi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_andi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_divu_ops[0],
+  & sfmt_lb_ops[0],
+  & sfmt_lb_ops[0],
+  & sfmt_lh_ops[0],
+  & sfmt_lh_ops[0],
+  & sfmt_lw_ops[0],
+  & sfmt_divu_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_andi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_ori_ops[0],
+  & sfmt_andhii_ops[0],
+  & sfmt_rcsr_ops[0],
+  & sfmt_sb_ops[0],
+  & sfmt_sextb_ops[0],
+  & sfmt_sextb_ops[0],
+  & sfmt_sh_ops[0],
+  & sfmt_sl_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_sl_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_sl_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_sw_ops[0],
+  & sfmt_user_ops[0],
+  & sfmt_wcsr_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_andi_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_andi_ops[0],
+  & sfmt_break_ops[0],
+  & sfmt_break_ops[0],
+  & sfmt_bret_ops[0],
+  & sfmt_bret_ops[0],
+  & sfmt_bret_ops[0],
+  & sfmt_sextb_ops[0],
+  & sfmt_addi_ops[0],
+  & sfmt_mvui_ops[0],
+  & sfmt_andhii_ops[0],
+  & sfmt_mva_ops[0],
+  & sfmt_sextb_ops[0],
+  & sfmt_nop_ops[0],
+  & sfmt_lbgprel_ops[0],
+  & sfmt_lbgprel_ops[0],
+  & sfmt_lhgprel_ops[0],
+  & sfmt_lhgprel_ops[0],
+  & sfmt_lwgprel_ops[0],
+  & sfmt_sbgprel_ops[0],
+  & sfmt_shgprel_ops[0],
+  & sfmt_swgprel_ops[0],
+  & sfmt_lwgprel_ops[0],
+};
+
+/* Function to call before using the operand instance table.  */
+
+void
+lm32_cgen_init_opinst_table (cd)
+     CGEN_CPU_DESC cd;
+{
+  int i;
+  const CGEN_OPINST **oi = & lm32_cgen_opinst_table[0];
+  CGEN_INSN *insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].opinst = oi[i];
+}

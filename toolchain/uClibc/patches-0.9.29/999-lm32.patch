diff -Naur uClibc-0.9.29.orig/extra/Configs/Config.in uClibc-0.9.29/extra/Configs/Config.in
--- uClibc-0.9.29.orig/extra/Configs/Config.in	2007-04-17 19:24:29.000000000 +0200
+++ uClibc-0.9.29/extra/Configs/Config.in	2010-01-23 11:34:05.000000000 +0100
@@ -43,6 +43,9 @@
 config TARGET_ia64
 	bool "ia64"
 
+config TARGET_lm32
+	bool "lm32"
+
 config TARGET_m68k
 	bool "m68k"
 
@@ -128,6 +131,10 @@
 source "extra/Configs/Config.ia64"
 endif
 
+if TARGET_lm32
+source "extra/Configs/Config.lm32"
+endif
+
 if TARGET_m68k
 source "extra/Configs/Config.m68k"
 endif
diff -Naur uClibc-0.9.29.orig/extra/Configs/Config.lm32 uClibc-0.9.29/extra/Configs/Config.lm32
--- uClibc-0.9.29.orig/extra/Configs/Config.lm32	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/extra/Configs/Config.lm32	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,18 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config TARGET_ARCH
+	string
+	default "lm32"
+
+config FORCE_OPTIONS_FOR_ARCH
+	bool
+	default y
+	select ARCH_BIG_ENDIAN
+	select ARCH_HAS_NO_LDSO
+	select ARCH_HAS_NO_MMU
+
+config ARCH_CFLAGS
+	string
diff -Naur uClibc-0.9.29.orig/extra/Configs/defconfigs/lm32 uClibc-0.9.29/extra/Configs/defconfigs/lm32
--- uClibc-0.9.29.orig/extra/Configs/defconfigs/lm32	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/extra/Configs/defconfigs/lm32	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1 @@
+TARGET_lm32=y
diff -Naur uClibc-0.9.29.orig/include/elf.h uClibc-0.9.29/include/elf.h
--- uClibc-0.9.29.orig/include/elf.h	2006-11-17 07:51:34.000000000 +0100
+++ uClibc-0.9.29/include/elf.h	2010-01-23 11:34:05.000000000 +0100
@@ -260,7 +260,8 @@
 #define EM_BLACKFIN	106		/* Analog Devices Blackfin */
 #define EM_ALTERA_NIOS2	113	/* Altera Nios II soft-core processor */
 #define EM_CRX		114		/* National Semiconductor CRX */
-#define EM_NUM		95
+#define EM_LATTICEMICO32	138	/* Lattice Mico32 */
+#define EM_NUM		96
 
 /* If it is necessary to assign new unofficial EM_* values, please pick large
    random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of collision
diff -Naur uClibc-0.9.29.orig/libc/misc/internals/__uClibc_main.c uClibc-0.9.29/libc/misc/internals/__uClibc_main.c
--- uClibc-0.9.29.orig/libc/misc/internals/__uClibc_main.c	2007-01-11 23:39:13.000000000 +0100
+++ uClibc-0.9.29/libc/misc/internals/__uClibc_main.c	2010-01-23 11:46:55.000000000 +0100
@@ -390,9 +390,11 @@
     if (likely(__errno_location!=NULL))
 	*(__errno_location()) = 0;
 
+#if 0
     /* Set h_errno to 0 as well */
     if (likely(__h_errno_location!=NULL))
 	*(__h_errno_location()) = 0;
+#endif
 
     /*
      * Finally, invoke application's main and then exit.
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/common/getpagesize.c uClibc-0.9.29/libc/sysdeps/linux/common/getpagesize.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/common/getpagesize.c	2006-03-10 17:20:23.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/common/getpagesize.c	2010-01-23 11:34:05.000000000 +0100
@@ -19,6 +19,7 @@
 #include <unistd.h>
 #include <features.h>
 #include <sys/param.h>
+#include <sys/user.h>
 
 extern size_t __pagesize;
 
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/endian.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/endian.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/endian.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/endian.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,7 @@
+/* Lattice Mico32 (lm32) is big-endian.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/fcntl.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/fcntl.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/fcntl.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,227 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 2000, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+
+#include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECTORY	00200000  /* Must be a directory.	 */
+# define O_NOFOLLOW	00400000  /* Do not follow links.	 */
+# define O_DIRECT	00040000  /* Direct disk access.	*/
+# define O_NOATIME	01000000  /* Do not set atime.  */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	00100000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_UNIX98
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* For F_[GET|SET]FL.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+#ifdef __USE_GNU
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+#endif
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+
+#if 0
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+
+/* Splice address range into a pipe.  */
+extern int vmsplice (int __fdout, const struct iovec *__iov, size_t __count,
+		     unsigned int __flags);
+
+/* Splice two files together.  */
+extern int splice (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern int tee (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+#endif
+
+#endif
+
+__END_DECLS
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/kernel_stat.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/kernel_stat.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/kernel_stat.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/kernel_stat.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,62 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+#ifndef _LIBC
+#error bits/kernel_stat.h is for internal uClibc use only!
+#endif
+
+/* This file provides whatever this particular arch's kernel thinks 
+ * struct kernel_stat should look like...  It turns out each arch has a 
+ * different opinion on the subject... */
+
+struct kernel_stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long  st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+        unsigned long  __unused1;
+	unsigned long  st_mtime;
+        unsigned long  __unused2;
+	unsigned long  st_ctime;
+        unsigned long  __unused3;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+struct kernel_stat64 {
+	unsigned long long st_dev;
+	unsigned char      __pad1[4];
+
+#define _HAVE_STAT64___ST_INO
+	unsigned long      __st_ino;
+	unsigned int       st_mode;
+	unsigned int       st_nlink;
+	unsigned long      st_uid;
+	unsigned long      st_gid;
+
+	unsigned long long st_rdev;
+	unsigned char      __pad3[4];
+
+	long long          st_size;
+	unsigned long      st_blksize;
+	unsigned long long st_blocks;  /* Number 512-byte blocks allocated. */
+
+	unsigned long      st_atime;
+	unsigned long      st_atime_nsec;
+	unsigned long      st_mtime;
+	unsigned long      st_mtime_nsec;
+	unsigned long      st_ctime;
+	unsigned long      st_ctime_nsec;
+	unsigned long long st_ino;
+};
+
+#endif	/*  _BITS_STAT_STRUCT_H */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/kernel_types.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/kernel_types.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/kernel_types.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/kernel_types.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,44 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts 
+ * with the posix_types.h kernel header, and will ensure that 
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ARCH_LM32_ASM_POSIX_TYPES_H
+#define __ARCH_LM32_ASM_POSIX_TYPES_H
+
+typedef unsigned short	__kernel_dev_t;
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef long long	__kernel_loff_t;
+typedef __kernel_dev_t	__kernel_old_dev_t;
+
+typedef struct {
+#ifdef __USE_ALL
+	int val[2];
+#else
+	int __val[2];
+#endif
+} __kernel_fsid_t;
+
+#endif /* __ARCH_LM32_POSIX_TYPES_H */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/mman.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/mman.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/mman.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/mman.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,106 @@
+/* Definitions for POSIX memory map interface.  Linux/MIPS version.
+   Copyright (C) 1997, 2000, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+# define MAP_RENAME	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_NORESERVE	0x0400		/* don't check for reservations */
+# define MAP_ANONYMOUS	0x20		/* don't use a file */
+# define MAP_GROWSDOWN	0x1000		/* stack-like segment */
+# define MAP_DENYWRITE	0x2000		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x4000		/* mark it as an executable */
+# define MAP_LOCKED	0x8000		/* pages are locked */
+# define MAP_POPULATE   0x10000         /* populate (prefault) pagetables */
+# define MAP_NONBLOCK   0x20000         /* do not block on IO */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+# define MREMAP_FIXED	2
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_REMOVE	 9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/setjmp.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/setjmp.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/setjmp.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/setjmp.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,55 @@
+/* Define the machine-dependent type `jmp_buf'.  MIPS version.
+   Copyright (C) 1992,93,95,97,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H	1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+typedef struct
+  {
+    /* Program counter (the return address actually).  */
+    void * __pc;
+
+    /* Callee-saved registers r11 through r28.  */
+    unsigned int __regs[17];
+
+    /* The global pointer (r26).  */
+    void * __gp;
+
+    /* The frame pointer (r27).  */
+    void * __fp;
+
+    /* Stack pointer (r28).  */
+    void * __sp;
+  } __jmp_buf[1];
+
+#ifdef __USE_MISC
+/* Offset to the program counter in `jmp_buf'.  */
+# define JB_PC	0
+#endif
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (void *) (jmpbuf)[0].__sp)
+
+#endif	/* bits/setjmp.h */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/stackinfo.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/stackinfo.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/stackinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/stackinfo.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,28 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On blackfin the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/syscalls.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/syscalls.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/syscalls.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/syscalls.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,122 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+#ifndef __ASSEMBLER__
+
+#include <errno.h>
+#include <asm/traps.h>
+
+#define __syscall_return(type, res) \
+do { \
+	if ((unsigned long)(res) >= (unsigned long)(-125)) { \
+		int __err = -(int)(res); \
+		errno = __err; \
+		return (type)-1; \
+	} \
+	return (type) (res); \
+} while (0)
+
+#define _syscall0(type,name)			\
+type name(void) \
+{ \
+    register unsigned int  r_syscall	asm("r8") = (__NR_##name); \
+    register long          r_a          asm("r1") = 0; \
+    __asm__ __volatile__ ( "scall\n" \
+			   : "=r"(r_a) \
+			   : "r"(r_syscall)); \
+    __syscall_return(type, r_a); \
+}
+
+#define _syscall1(type,name,atype,a)		\
+type name(atype a) \
+{ \
+    register unsigned int  r_syscall	asm("r8") = (__NR_##name); \
+    register atype         r_a          asm("r1") = a; \
+    __asm__ __volatile__ ( "scall\n" \
+			   : "=r"(r_a) \
+			   : "r"(r_syscall), "r"(r_a) \
+			   ); \
+    __syscall_return(type, r_a); \
+}
+
+#define _syscall2(type,name,atype,a,btype,b) \
+type name(atype a,btype b) \
+{ \
+    register unsigned int  r_syscall	asm("r8") = (__NR_##name); \
+    register atype         r_a          asm("r1") = a; \
+    register btype         r_b          asm("r2") = b; \
+    __asm__ __volatile__ ( "scall\n" \
+			   : "=r"(r_a) \
+			   : "r"(r_syscall), "r"(r_a), "r"(r_b) \
+			   );\
+    __syscall_return(type, r_a); \
+}
+
+#define _syscall3(type,name,atype,a,btype,b,ctype,c)	\
+type name(atype a,btype b,ctype c) \
+{ \
+    register unsigned int  r_syscall	asm("r8") = (__NR_##name); \
+    register atype         r_a          asm("r1") = a; \
+    register btype         r_b          asm("r2") = b; \
+    register ctype         r_c          asm("r3") = c; \
+    __asm__ __volatile__ ( "scall\n" \
+			   : "=r"(r_a) \
+			   : "r"(r_syscall), "r"(r_a), "r"(r_b), "r"(r_c) ); \
+    __syscall_return(type, r_a); \
+}
+
+#define _syscall4(type,name,atype,a,btype,b,ctype,c,dtype,d) \
+type name (atype a, btype b, ctype c, dtype d) \
+{ \
+    register unsigned int  r_syscall	asm("r8") = (__NR_##name); \
+    register atype         r_a          asm("r1") = a; \
+    register btype         r_b          asm("r2") = b; \
+    register ctype         r_c          asm("r3") = c; \
+    register dtype         r_d          asm("r4") = d; \
+    __asm__ __volatile__ ( "scall\n" \
+			   : "=r"(r_a) \
+			   : "r"(r_syscall), \
+			     "r"(r_a), "r"(r_b), "r"(r_c), "r"(r_d));	\
+    __syscall_return(type, r_a); \
+}
+
+#define _syscall5(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e) \
+type name (atype a,btype b,ctype c,dtype d,etype e) \
+{ \
+    register unsigned int  r_syscall	asm("r8") = (__NR_##name); \
+    register atype         r_a          asm("r1") = a; \
+    register btype         r_b          asm("r2") = b; \
+    register ctype         r_c          asm("r3") = c; \
+    register dtype         r_d          asm("r4") = d; \
+    register etype         r_e          asm("r5") = e; \
+    __asm__ __volatile__ ( "scall\n" \
+			   : "=r"(r_a) \
+			   : "r"(r_syscall), \
+			     "r"(r_a), "r"(r_b), "r"(r_c), "r"(r_d), "r"(r_e));	\
+    __syscall_return(type, r_a); \
+}
+
+#define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
+type name (atype a,btype b,ctype c,dtype d,etype e,ftype f) \
+{ \
+    register unsigned int  r_syscall	asm("r8") = (__NR_##name); \
+    register atype         r_a          asm("r1") = a; \
+    register btype         r_b          asm("r2") = b; \
+    register ctype         r_c          asm("r3") = c; \
+    register dtype         r_d          asm("r4") = d; \
+    register etype         r_e          asm("r5") = e; \
+    register ftype         r_f          asm("r6") = f; \
+    __asm__ __volatile__ ( "scall\n" \
+			   : "=r"(r_a) \
+			   : "r"(r_syscall), \
+			     "r"(r_a), "r"(r_b), "r"(r_c), \
+			     "r"(r_d), "r"(r_e), "r"(r_f));	\
+    __syscall_return(type, r_a); \
+}
+
+#endif /* __ASSEMBLER__ */
+#endif /* _BITS_SYSCALLS_H */
+
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/uClibc_arch_features.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/uClibc_arch_features.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/uClibc_arch_features.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/uClibc_arch_features.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * Track misc arch-specific features that aren't config options
+ */
+
+#ifndef _BITS_UCLIBC_ARCH_FEATURES_H
+#define _BITS_UCLIBC_ARCH_FEATURES_H
+
+/* instruction used when calling abort() to kill yourself */
+/*#define __UCLIBC_ABORT_INSTRUCTION__ "asm instruction"*/
+#undef __UCLIBC_ABORT_INSTRUCTION__
+
+/* can your target use syscall6() for mmap ? */
+#define __UCLIBC_MMAP_HAS_6_ARGS__
+
+/* does your target use syscall4() for truncate64 ? (32bit arches only) */
+#undef __UCLIBC_TRUNCATE64_HAS_4_ARGS__
+
+/* does your target have a broken create_module() ? */
+#undef __UCLIBC_BROKEN_CREATE_MODULE__
+
+/* does your target prefix all symbols with an _ ? */
+#define __UCLIBC_NO_UNDERSCORES__
+
+/* does your target have an asm .set ? */
+#undef __UCLIBC_HAVE_ASM_SET_DIRECTIVE__
+
+/* define if target doesn't like .global */
+#undef __UCLIBC_ASM_GLOBAL_DIRECTIVE__
+
+/* define if target supports .weak */
+#define __UCLIBC_HAVE_ASM_WEAK_DIRECTIVE__
+
+/* define if target supports .weakext */
+#undef __UCLIBC_HAVE_ASM_WEAKEXT_DIRECTIVE__
+
+/* needed probably only for ppc64 */
+#undef __UCLIBC_HAVE_ASM_GLOBAL_DOT_NAME__
+
+/* define if target supports IEEE signed zero floats */
+#define __UCLIBC_HAVE_SIGNED_ZERO__
+
+#endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/uClibc_page.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/uClibc_page.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/uClibc_page.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/uClibc_page.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,9 @@
+#ifndef _UCLIBC_PAGE_H
+#define _UCLIBC_PAGE_H
+
+#define PAGE_SHIFT      (12)
+#define PAGE_SIZE       (1UL << PAGE_SHIFT)
+#define PAGE_MASK       (~(PAGE_SIZE-1))
+
+#endif /* _UCLIBC_PAGE_H */
+
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/wordsize.h uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/wordsize.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bits/wordsize.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bits/wordsize.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	32
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/brk.c uClibc-0.9.29/libc/sysdeps/linux/lm32/brk.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/brk.c	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/brk.c	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,31 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+void *__curbrk attribute_hidden = 0;
+
+libc_hidden_proto(brk)
+int brk (void *addr)
+{
+  void *newbrk;
+
+  {
+    register unsigned int  r_syscall	asm("r8") = (__NR_brk); 
+    register void*         r_addr       asm("r1") = addr; 
+
+    __asm__ __volatile__ ( "scall\n" 
+    	    		   "mv %0, r1\n" /* return value */ 
+			   : "=r"(newbrk) 
+			   : "r"(r_syscall), "r"(r_addr) ); 
+  }
+  __curbrk = newbrk;
+
+  if (newbrk < addr)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  return 0;
+}
+libc_hidden_def(brk)
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bsd-_setjmp.S uClibc-0.9.29/libc/sysdeps/linux/lm32/bsd-_setjmp.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bsd-_setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bsd-_setjmp.S	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,10 @@
+/* This just does a tail-call to `__sigsetjmp (ARG, 0)'.
+   We cannot do it in C because it must be a tail-call, so frame-unwinding
+   in setjmp doesn't clobber the state restored by longjmp.  */
+
+.global setjmp
+.type setjmp,%function
+.align 2
+setjmp:
+	mv	r1, r0
+	be	r0, r0, __sigsetjmp
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bsd-setjmp.S uClibc-0.9.29/libc/sysdeps/linux/lm32/bsd-setjmp.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/bsd-setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/bsd-setjmp.S	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,11 @@
+/* This just does a tail-call to `__sigsetjmp (ARG, 1)'.
+   We cannot do it in C because it must be a tail-call, so frame-unwinding
+   in setjmp doesn't clobber the state restored by longjmp.  */
+
+.global _setjmp
+.type _setjmp,%function
+.align 2
+_setjmp:
+	mvi	r2, 1
+	be	r0, r0, __sigsetjmp
+
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/clone.S uClibc-0.9.29/libc/sysdeps/linux/lm32/clone.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/clone.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/clone.S	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,44 @@
+#define _ERRNO_H
+#include <features.h>
+#include <bits/errno.h>
+#include <sys/syscall.h>
+
+#ifdef __NR_clone
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
+
+.text
+.global clone
+.type clone,%function
+.align 2
+clone:
+	/* sanity check arguments */
+	be	r1, r0, __einval
+	be	r2, r0, __einval
+
+	/* insert the args onto the new stack */
+	addi	r2, r2, -12
+	sw	(r2 + 8), r4   /* child_stack[1] = arg */
+	sw	(r2 + 4), r1   /* child_stack[0] = fn */
+
+	/* do the system call */
+	mvi	r8, __NR_clone
+	scall
+	/* if r1 is negative -> __error */
+	bg	r0, r1, __error
+	/* if r1 == 0 -> child, otherwise parent && r1 contains pid(child) */
+	be	r1, r0, __thread_start
+	ret	/* parent --- return (branch to RA)*/
+
+__thread_start:
+	lw	r1, (sp + 8)  /* load the arg */
+	lw	r2, (sp + 4)  /* load the function pointer */
+	call	r2
+
+	/* and we are done, passing the return value through r1 */
+	calli	HIDDEN_JUMPTARGET(_exit)	
+	
+__einval:
+	mvi	r1, -EINVAL
+__error:	
+	be	r0, r0, __syscall_error
+#endif
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crt1.S uClibc-0.9.29/libc/sysdeps/linux/lm32/crt1.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crt1.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/crt1.S	2010-01-23 11:46:55.000000000 +0100
@@ -0,0 +1,152 @@
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  We use expect this to be set up as follows on the call:
+
+   r14		Contains a function pointer to be registered with `atexit'.
+
+   sp 		The stack contains the arguments and environment:
+		0(%esp)			argc
+		4(%esp)			argv[0]
+		...
+		(4*argc)(%esp)		NULL
+		(4*(argc+1))(%esp)	envp[0]
+		...
+					NULL
+   ra 		The return address register is set to zero so that programs
+		that search backword through stack frames recognize the last
+		stack frame.
+*/
+
+/* setup by ELF_FDPIC_PLAT_INIT in include/asm-lm32/elf.h:
+ *
+ * r11 = _exec_map_addr
+ * r12 = _interp_map_addr
+ * r13 = _dynamic_addr
+ * r14 = _rtld_fini (= NULL)
+ */
+
+	.text
+	.globl	_start
+	.type	_start,@function
+	.type	_init,@function
+	.type	_fini,@function
+#ifndef __UCLIBC_CTOR_DTOR__
+	.weak	_init
+	.weak	_fini
+#endif
+	.type	main,@function
+	.type	__uClibc_main,@function
+
+/* We need to call:
+   __uClibc_main (int (*main) (int, char **, char **), int argc,
+		      char **argv, void (*init) (void), void (*fini) (void),
+		      void (*rtld_fini) (void), void *stack_end)
+*/
+
+_start:
+	/* Place a local address ra, so we provide some position
+	 * independence, even though full position independence
+	 * will have to wait until the GOT is available
+	 */
+	calli .Lcall
+.Lcall:
+	mvhi    r15, hi(.Lcall)
+	ori	r15, r15, lo(.Lcall)
+	/* calculate offset between symbol addresses and real addresses */
+	/* r15 = symbol address of .Lcall, ra = real address of .Lcall */
+	sub r15, ra, r15
+	/* now r15 = value which has to be added to a symbol address to get a real address*/
+	
+	/* TODO: use exec_fdpic_loadmap */
+	/* for now use offset */
+	mv r1, r15
+
+	/* get got start/end* addresses */
+	mvhi r2, hi(_got_start)
+	ori r2, r2, lo(_got_start)
+	mvhi r3, hi(_got_end)
+	ori r3, r3, lo(_got_end)
+	mvhi r4, hi(_data_rel_start)
+	ori r4, r4, lo(_data_rel_start)
+	mvhi r5, hi(_data_rel_end)
+	ori r5, r5, lo(_data_rel_end)
+
+	/* relocate got start/end* addresses */
+	add r2, r2, r15
+	add r3, r3, r15
+	add r4, r4, r15
+	add r5, r5, r15
+
+	/* get got start/end addresses */
+	lw r2, (r2+0)
+	lw r3, (r3+0)
+	lw r4, (r4+0)
+	lw r5, (r5+0)
+
+	/* relocate got start/end addresses */
+	add r2, r2, r15
+	add r3, r3, r15
+	add r4, r4, r15
+	add r5, r5, r15
+
+	/* relocate self */
+	calli __self_reloc
+	/* return value = relocated pointer to gp */
+	mv gp, r1
+
+	/* r1: main */
+	mvhi	r1, hi(main)
+	ori	r1, r1, lo(main)
+	add	r1, r1, r15 /* relocate */
+
+	/* r2: argc */
+	lw	r2, (sp + 0)	/* load argc */
+
+	/* r3: argv */
+	addi	r3, sp, 4	/* argv points to &sp[1] */
+	addi    sp, sp, -4	/* fix stack, sp now reallypoints to next free place */
+	
+	/* r4: init */
+	mvhi	r4, hi(_init)
+	ori	r4, r4, lo(_init)
+	add	r4, r4, r15 /* relocate */
+
+	/* r5: fini */
+	mvhi	r5, hi(_fini)
+	ori	r5, r5, lo(_fini)
+	add	r5, r5, r15 /* relocate */
+
+	/* r6: rtld_fini */
+	mv r6, r14
+
+	/* r7 should contain sp */
+	mv	r7, sp
+	
+	/* a 26-bit relative call should suffice for now. */
+	calli	__uClibc_main
+hlt:
+	/* Hang if somehow `__uClibc_main' returns anyway.  */
+	be	r0, r0, hlt
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
+
+	.globl _data_rel_start
+_data_rel_start:
+	.word __data_rel_start
+	.globl _data_rel_end
+_data_rel_end:
+	.word __data_rel_end
+
+	.globl _got_start
+_got_start:
+	.word __got_start
+
+	.globl _got_end
+_got_end:
+	.word __got_end
+
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crti.S uClibc-0.9.29/libc/sysdeps/linux/lm32/crti.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crti.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/crti.S	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,18 @@
+
+	/* Copied from gcc */
+	
+        .section .init
+        .global _init
+        .type _init,@function
+        .align 4
+_init:
+        addi    sp, sp, -4        
+        sw      (sp+4), ra
+
+        .section .fini
+        .global _fini
+        .type _fini,@function
+        .align 4
+_fini:        
+        addi    sp, sp, -4        
+        sw      (sp+4), ra
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crtn.S uClibc-0.9.29/libc/sysdeps/linux/lm32/crtn.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crtn.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/crtn.S	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,13 @@
+	/* Copied from gcc */
+
+	.section .init
+        
+        lw      ra, (sp+4)
+        addi    sp, sp, 4
+        ret
+                
+	.section .fini
+        
+        lw      ra, (sp+4)
+        addi    sp, sp, 4
+        ret
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crtreloc.c uClibc-0.9.29/libc/sysdeps/linux/lm32/crtreloc.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/crtreloc.c	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/crtreloc.c	2010-01-23 11:46:55.000000000 +0100
@@ -0,0 +1,19 @@
+#include <sys/types.h>
+#include <link.h>
+
+void* attribute_hidden
+__self_reloc (unsigned long offset,
+		unsigned long* start, unsigned long* end,
+		unsigned long* start2, unsigned long* end2)
+{
+	unsigned long* p;
+	for(p = start; p != end; ++p) {
+		*p = *p + offset;
+	}
+	for(p = start2; p != end2; ++p) {
+		*p = *p + offset;
+	}
+  
+	return start;
+}
+
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/__longjmp.c uClibc-0.9.29/libc/sysdeps/linux/lm32/__longjmp.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/__longjmp.c	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/__longjmp.c	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,59 @@
+#include <features.h>
+#include <setjmp.h>
+#include <stdlib.h>
+
+#ifndef	__GNUC__
+  #error This file uses GNU C extensions; you must compile with GCC.
+#endif
+
+extern void __longjmp (__jmp_buf __env, int __val) attribute_noreturn;
+libc_hidden_proto(__longjmp)
+
+void __longjmp (__jmp_buf env, int val_arg)
+{
+    /* Make sure that gcc doesn't try to be smart about r2 */
+    register int val __asm__ ("r2") = val_arg;
+
+    /* Get the GP. */
+    asm volatile ("lw gp, %0" : : "m"(env[0].__gp));
+  
+    /* Get the callee-saved registers.  */
+    asm volatile ("lw r11, %0" : : "m" (env[0].__regs[0]));
+    asm volatile ("lw r12, %0" : : "m" (env[0].__regs[1]));
+    asm volatile ("lw r13, %0" : : "m" (env[0].__regs[2]));
+    asm volatile ("lw r14, %0" : : "m" (env[0].__regs[3]));
+    asm volatile ("lw r15, %0" : : "m" (env[0].__regs[4]));
+    asm volatile ("lw r16, %0" : : "m" (env[0].__regs[5]));
+    asm volatile ("lw r17, %0" : : "m" (env[0].__regs[6]));
+    asm volatile ("lw r18, %0" : : "m" (env[0].__regs[7]));
+    asm volatile ("lw r19, %0" : : "m" (env[0].__regs[8]));
+    asm volatile ("lw r20, %0" : : "m" (env[0].__regs[9]));
+    asm volatile ("lw r21, %0" : : "m" (env[0].__regs[10]));
+    asm volatile ("lw r22, %0" : : "m" (env[0].__regs[11]));
+    asm volatile ("lw r23, %0" : : "m" (env[0].__regs[12]));
+    asm volatile ("lw r24, %0" : : "m" (env[0].__regs[13]));
+    asm volatile ("lw r25, %0" : : "m" (env[0].__regs[14]));
+
+    /* Get the PC --- actually the return address  */
+    asm volatile ("lw ra, %0" : : "m" (env[0].__pc));
+
+    /* Restore the stack pointer and the FP.  They have to be restored
+       last and in a single asm as gcc, depending on options used, may
+       use either of them to access env.  */
+    asm volatile ("lw sp, %0\n"
+		  "lw fp, %1\n"
+		  : 
+		  : "m" (env[0].__sp), "m" (env[0].__fp)
+		  : "fp", "sp");
+
+    if (val == 0)
+	asm volatile ("mvi r1, 1");
+    else
+	asm volatile ("mv  r1, %0" : : "r" (val));
+
+    asm volatile ("ret");
+    
+    /* Avoid `function does return' warnings.  */
+    for (;;)
+      ;
+}  
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/Makefile uClibc-0.9.29/libc/sysdeps/linux/lm32/Makefile
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/Makefile	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,13 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+top_srcdir=../../../../
+top_builddir=../../../../
+all: objs
+include $(top_builddir)Rules.mak
+include Makefile.arch
+include $(top_srcdir)Makerules
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/Makefile.arch uClibc-0.9.29/libc/sysdeps/linux/lm32/Makefile.arch
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/Makefile.arch	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/Makefile.arch	2010-01-23 11:46:55.000000000 +0100
@@ -0,0 +1,12 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+CSRC := brk.c clone.c syscall.c __syscall_error.c setjmp_aux.c mmap.c crtreloc.c
+
+SSRC := __longjmp.S setjmp.S bsd-_setjmp.S bsd-setjmp.S vfork.S
+
+include $(top_srcdir)libc/sysdeps/linux/Makefile.commonarch
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/mmap.c uClibc-0.9.29/libc/sysdeps/linux/lm32/mmap.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/mmap.c	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/mmap.c	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,27 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+#define __NR__mmap __NR_mmap2
+
+#ifndef MMAP2_PAGE_SHIFT
+# define MMAP2_PAGE_SHIFT 12
+#endif
+
+libc_hidden_proto (mmap)
+
+static inline _syscall6 (__ptr_t, _mmap, __ptr_t, addr, size_t, len,
+                         int, prot, int, flags, int, fd, __off_t, offset);
+
+__ptr_t mmap(__ptr_t addr, size_t len, int prot,
+             int flags, int fd, __off_t offset)
+{
+  /* check if offset is page aligned */
+    if (offset & ((1 << MMAP2_PAGE_SHIFT) - 1))
+        return MAP_FAILED;
+  return (__ptr_t) _mmap (addr, len, prot, flags,
+			  fd,(off_t) (offset >> MMAP2_PAGE_SHIFT));
+}
+
+libc_hidden_def (mmap)
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/setjmp_aux.c uClibc-0.9.29/libc/sysdeps/linux/lm32/setjmp_aux.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/setjmp_aux.c	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/setjmp_aux.c	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,64 @@
+/* Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <features.h>
+#include <setjmp.h>
+
+/* This function is only called via the assembly language routine
+   __sigsetjmp, which arranges to pass in the stack pointer and the frame
+   pointer.  We do things this way because it's difficult to reliably
+   access them in C.  */
+
+extern int __sigjmp_save (sigjmp_buf, int);
+
+int __sigsetjmp_aux (jmp_buf env, int savemask, int sp, int fp);
+
+int __sigsetjmp_aux (jmp_buf env, int savemask, int sp, int fp)
+{
+  /* Store the PC (actually the RA);  */
+  asm volatile ("sw %0, ra" : "=m" (env[0].__jmpbuf[0].__pc) );
+
+  /* .. and the stack pointer;  */
+  env[0].__jmpbuf[0].__sp = (void *) sp;
+
+  /* .. and the FP; it'll be in r4. */
+  env[0].__jmpbuf[0].__fp = (void *) fp;
+
+  /* .. and the GP; */
+  asm volatile ("sw %0, gp" : "=m" (env[0].__jmpbuf[0].__gp));
+
+  asm volatile ("sw %0, r11" : "=m" (env[0].__jmpbuf[0].__regs[0]) );
+  asm volatile ("sw %0, r12" : "=m" (env[0].__jmpbuf[0].__regs[1]) );
+  asm volatile ("sw %0, r13" : "=m" (env[0].__jmpbuf[0].__regs[2]) );
+  asm volatile ("sw %0, r14" : "=m" (env[0].__jmpbuf[0].__regs[3]) );
+  asm volatile ("sw %0, r15" : "=m" (env[0].__jmpbuf[0].__regs[4]) );
+  asm volatile ("sw %0, r16" : "=m" (env[0].__jmpbuf[0].__regs[5]) );
+  asm volatile ("sw %0, r17" : "=m" (env[0].__jmpbuf[0].__regs[6]) );
+  asm volatile ("sw %0, r18" : "=m" (env[0].__jmpbuf[0].__regs[7]) );
+  asm volatile ("sw %0, r19" : "=m" (env[0].__jmpbuf[0].__regs[8]) );
+  asm volatile ("sw %0, r20" : "=m" (env[0].__jmpbuf[0].__regs[9]) );
+  asm volatile ("sw %0, r21" : "=m" (env[0].__jmpbuf[0].__regs[10]) );
+  asm volatile ("sw %0, r22" : "=m" (env[0].__jmpbuf[0].__regs[11]) );
+  asm volatile ("sw %0, r23" : "=m" (env[0].__jmpbuf[0].__regs[12]) );
+  asm volatile ("sw %0, r24" : "=m" (env[0].__jmpbuf[0].__regs[13]) );
+  asm volatile ("sw %0, r25" : "=m" (env[0].__jmpbuf[0].__regs[14]) );
+
+  /* Save the signal mask if requested.  */
+  return __sigjmp_save (env, savemask);
+}
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/setjmp.S uClibc-0.9.29/libc/sysdeps/linux/lm32/setjmp.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/setjmp.S	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,35 @@
+/* Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* The function __sigsetjmp_aux saves all the registers, but it can't
+   reliably access the stack or frame pointers, so we pass them in as
+   extra arguments.  */
+
+.text
+.global __sigsetjmp
+.align 2;
+.type __sigsetjmp,@function
+
+__sigsetjmp:
+	mv	r3, sp
+	mv	r4, fp
+
+	bi	__sigsetjmp_aux
+
+	.end	__sigsetjmp
+	.size	__sigsetjmp,.-__sigsetjmp
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/procfs.h uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/procfs.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/procfs.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,111 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <asm/elf.h>
+
+__BEGIN_DECLS
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/ptrace.h uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/ptrace.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/ptrace.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,151 @@
+/*
+ * Based on:
+ *
+ * `ptrace' debugger support interface.  FRV-Linux version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Type of the REQUEST argument to `ptrace.'  */
+enum __ptrace_request
+{
+  /* Indicate that the process making this request should be traced.
+     All signals received by this process can be intercepted by its
+     parent, and its parent can use the other `ptrace' requests.  */
+  PTRACE_TRACEME = 0,
+#define PT_TRACE_ME PTRACE_TRACEME
+
+  /* Return the word in the process's text space at address ADDR.  */
+  PTRACE_PEEKTEXT = 1,
+#define PT_READ_I PTRACE_PEEKTEXT
+
+  /* Return the word in the process's data space at address ADDR.  */
+  PTRACE_PEEKDATA = 2,
+#define PT_READ_D PTRACE_PEEKDATA
+
+  /* Return the word in the process's user area at offset ADDR.  */
+  PTRACE_PEEKUSER = 3,
+#define PT_READ_U PTRACE_PEEKUSER
+
+  /* Write the word DATA into the process's text space at address ADDR.  */
+  PTRACE_POKETEXT = 4,
+#define PT_WRITE_I PTRACE_POKETEXT
+
+  /* Write the word DATA into the process's data space at address ADDR.  */
+  PTRACE_POKEDATA = 5,
+#define PT_WRITE_D PTRACE_POKEDATA
+
+  /* Write the word DATA into the process's user area at offset ADDR.  */
+  PTRACE_POKEUSER = 6,
+#define PT_WRITE_U PTRACE_POKEUSER
+
+  /* Continue the process.  */
+  PTRACE_CONT = 7,
+#define PT_CONTINUE PTRACE_CONT
+
+  /* Kill the process.  */
+  PTRACE_KILL = 8,
+#define PT_KILL PTRACE_KILL
+
+  /* Single step the process.
+     This is not supported on all machines.  */
+  PTRACE_SINGLESTEP = 9,
+#define PT_STEP PTRACE_SINGLESTEP
+
+  /* Get all general purpose registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETREGS = 12,
+#define PT_GETREGS PTRACE_GETREGS
+
+  /* Set all general purpose registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETREGS = 13,
+#define PT_SETREGS PTRACE_SETREGS
+
+  /* Get all floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETFPREGS = 14,
+#define PT_GETFPREGS PTRACE_GETFPREGS
+
+  /* Set all floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETFPREGS = 15,
+#define PT_SETFPREGS PTRACE_SETFPREGS
+
+  /* Attach to a process that is already running. */
+  PTRACE_ATTACH = 16,
+#define PT_ATTACH PTRACE_ATTACH
+
+  /* Detach from a process attached to with PTRACE_ATTACH.  */
+  PTRACE_DETACH = 17,
+#define PT_DETACH PTRACE_DETACH
+
+  /* Get all extended floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETFPXREGS = 18,
+#define PT_GETFPXREGS PTRACE_GETFPXREGS
+
+  /* Set all extended floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETFPXREGS = 19,
+#define PT_SETFPXREGS PTRACE_SETFPXREGS
+
+  /* Continue and stop at the next (return from) syscall.  */
+  PTRACE_SYSCALL = 24,
+#define PT_SYSCALL PTRACE_SYSCALL
+
+  /* Obtain the load map of the main program or the interpreter of the
+     ptraced process, depending on whether the addr argument is
+     (void*)0 or (void*)1, respectively.  */
+  PTRACE_GETFDPIC = 31,
+#define PT_GETFDPIC PTRACE_GETFDPIC
+
+	PTRACE_TEXT_ADDR = 50,
+#define PT_TEXT_ADDR PTRACE_TEXT_ADDR
+
+	PTRACE_TEXT_END_ADDR = 51,
+#define PT_TEXT_END_ADDR PTRACE_TEXT_END_ADDR
+
+	PTRACE_DATA_ADDR = 52
+#define PT_DATA_ADDR PTRACE_DATA_ADDR
+};
+
+#define PTRACE_GETFDPIC_EXEC      ((void*)0)	/* [addr] request the executable loadmap */
+#define PTRACE_GETFDPIC_INTERP    ((void*)1)	/* [addr] request the interpreter loadmap */
+
+/* Perform process tracing functions.  REQUEST is one of the values
+   above, and determines the action to be taken.
+   For all requests except PTRACE_TRACEME, PID specifies the process to be
+   traced.
+
+   PID and the other arguments described above for the various requests should
+   appear (those that are used for the particular request) as:
+     pid_t PID, void *ADDR, int DATA, void *ADDR2
+   after REQUEST.  */
+extern long int ptrace (enum __ptrace_request __request, ...) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_PTRACE_H */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/ucontext.h uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/ucontext.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/ucontext.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,128 @@
+/* Copyright (C) 1998, 1999, 2001, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* System V/ARM ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+#include <sys/procfs.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	32
+
+/* Container for all general registers.  */
+typedef elf_gregset_t gregset_t;
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  R0 = 0,
+#define R0	R0
+  R1 = 1,
+#define R1	R1
+  R2 = 2,
+#define R2	R2
+  R3 = 3,
+#define R3	R3
+  R4 = 4,
+#define R4	R4
+  R5 = 5,
+#define R5	R5
+  R6 = 6,
+#define R6	R6
+  R7 = 7,
+#define R7	R7
+  R8 = 8,
+#define R8	R8
+  R9 = 9,
+#define R9	R9
+  R10 = 10,
+#define R10	R10
+  R11 = 11,
+#define R11	R11
+  R12 = 12,
+#define R12	R12
+  R13 = 13,
+#define R13	R13
+  R14 = 14,
+#define R14	R14
+  R15 = 15,
+#define R15	R15
+  R16 = 16,
+#define R16	R16
+  R17 = 17,
+#define R17	R17
+  R18 = 18,
+#define R18	R18
+  R19 = 19,
+#define R19	R19
+  R20 = 20,
+#define R20	R20
+  R21 = 21,
+#define R21	R21
+  R22 = 22,
+#define R22	R22
+  R23 = 23,
+#define R23	R23
+  R24 = 24,
+#define R24	R24
+  R25 = 25,
+#define R25	R25
+  R26 = 26,
+#define R26	R26
+  R27 = 27,
+#define R27	R27
+  R28 = 28,
+#define R28	R28
+  R29 = 29,
+#define R29	R29
+  R30 = 30,
+#define R30	R30
+  R31 = 31
+#define R31	R31
+};
+
+/* Structure to describe FPU registers.  */
+typedef elf_fpregset_t	fpregset_t;
+
+/* Context to describe whole processor state.  This only describes
+   the core registers; coprocessor registers get saved elsewhere
+   (e.g. in uc_regspace, or somewhere unspecified on the stack
+   during non-RT signal handlers).  */
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/user.h uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/user.h
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/sys/user.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/sys/user.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,30 @@
+/* Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+#include <bits/uClibc_page.h>
+
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif  /* sys/user.h */
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/syscall.c uClibc-0.9.29/libc/sysdeps/linux/lm32/syscall.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/syscall.c	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/syscall.c	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,31 @@
+#include <features.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+
+
+long syscall(long sysnum, long a, long b, long c, long d, long e, long f)
+{
+    register unsigned int  r_syscall	asm("r8") = sysnum; 
+    register long          r_a          asm("r1") = a; 
+    register long          r_b          asm("r2") = b; 
+    register long          r_c          asm("r3") = c; 
+    register long          r_d          asm("r4") = d; 
+    register long          r_e          asm("r5") = e; 
+    register long          r_f          asm("r6") = f; 
+             long          __res; 
+
+    asm volatile ( "scall\n" 
+		   "mv %0, r1\n" 
+		   : "=r"(__res) 
+		   : "r"(r_syscall), 
+		     "r"(r_a), "r"(r_b), "r"(r_c), 
+		     "r"(r_d), "r"(r_e), "r"(r_f) );	
+
+    if(__res >=(unsigned long) -4095) {
+      long err = __res;
+      (*__errno_location())=(-err);
+      __res = (unsigned long) -1;
+    }
+    return (long) __res;
+}
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/__syscall_error.c uClibc-0.9.29/libc/sysdeps/linux/lm32/__syscall_error.c
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/__syscall_error.c	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/__syscall_error.c	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,18 @@
+/* Wrapper for setting errno.
+ *
+ * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <errno.h>
+#include <features.h>
+
+/* This routine is jumped to by all the syscall handlers, to stash
+ * an error number into errno.  */
+int __syscall_error(int err_no) attribute_hidden;
+int __syscall_error(int err_no)
+{
+	__set_errno(err_no);
+	return -1;
+}
diff -Naur uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/vfork.S uClibc-0.9.29/libc/sysdeps/linux/lm32/vfork.S
--- uClibc-0.9.29.orig/libc/sysdeps/linux/lm32/vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libc/sysdeps/linux/lm32/vfork.S	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,27 @@
+#include <features.h>
+
+#define _ERRNO_H
+#include <bits/errno.h>
+#include <asm/unistd.h>
+
+#ifndef __NR_vfork
+#define __NR_vfork __NR_fork /* uClinux-2.0 only has fork which is vfork */
+#endif
+
+.text
+.global	__vfork
+.hidden	__vfork
+.type	__vfork,%function
+.align 4
+
+__vfork:
+	mvi	r8, __NR_vfork
+	scall
+	ret
+	
+__error:
+	bi	__syscall_error
+
+.size __vfork,.-__vfork
+weak_alias(__vfork,vfork)
+libc_hidden_weak(vfork)
diff -Naur uClibc-0.9.29.orig/libpthread/linuxthreads.old/sysdeps/lm32/pt-machine.h uClibc-0.9.29/libpthread/linuxthreads.old/sysdeps/lm32/pt-machine.h
--- uClibc-0.9.29.orig/libpthread/linuxthreads.old/sysdeps/lm32/pt-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/libpthread/linuxthreads.old/sysdeps/lm32/pt-machine.h	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,61 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   nios2 version.
+   Copyright (C) 1996, 1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int* spinlock);
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+  unsigned long psw;
+	unsigned long ret;
+
+  /* disable interrupts  */
+  __asm__ __volatile__ (
+			"rcsr %0, IE\n"
+			"wcsr IE, r0"
+			: "=&r" (psw));
+
+	/* get previous state */
+	ret = *spinlock;
+
+	/* set */
+	*spinlock = 1;
+
+	__asm__ __volatile__ (
+			"wcsr IE, %0"
+			: : "r" (psw)); /* re-enable */
+
+	return ret;
+}
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("sp");
+
+#endif /* pt-machine.h */
diff -Naur uClibc-0.9.29.orig/Rules.mak uClibc-0.9.29/Rules.mak
--- uClibc-0.9.29.orig/Rules.mak	2007-04-17 15:34:11.000000000 +0200
+++ uClibc-0.9.29/Rules.mak	2010-01-23 11:46:55.000000000 +0100
@@ -154,7 +154,11 @@
 endif
 
 ifeq ($(UCLIBC_FORMAT_FDPIC_ELF),y)
-	PICFLAG:=-mfdpic
+	ifeq ($(TARGET_ARCH),lm32)
+		PICFLAG:=-fPIC
+	else
+		PICFLAG:=-mfdpic
+	endif
 else
 	PICFLAG:=-fPIC
 endif
@@ -241,6 +245,13 @@
 	CPU_CFLAGS-y+=-m32
 endif
 
+
+ifeq ($(TARGET_ARCH),lm32)
+## FIXME: revisit & make configurable through options
+	CPU_LDFLAGS-y+=-mmultiply-enabled -mdivide-enabled -mbarrel-shift-enabled -msign-extend-enabled
+	CPU_CFLAGS-y+=-mmultiply-enabled -mdivide-enabled -mbarrel-shift-enabled -msign-extend-enabled
+endif
+
 ifeq ($(TARGET_ARCH),sh)
 	OPTIMIZATION+=-fstrict-aliasing
 	OPTIMIZATION+= $(call check_gcc,-mprefergot,)
@@ -410,7 +421,11 @@
 LDFLAGS:=$(LDFLAGS_NOSTRIP) -z defs
 ifeq ($(DODEBUG),y)
 #CFLAGS += -g3
+ifeq ($(TARGET_ARCH),lm32)
+CFLAGS += -O2 -g3
+else
 CFLAGS += -O0 -g3
+endif
 else
 CFLAGS += $(OPTIMIZATION) $(XARCH_CFLAGS)
 endif
diff -Naur uClibc-0.9.29.orig/Rules.mak.orig uClibc-0.9.29/Rules.mak.orig
--- uClibc-0.9.29.orig/Rules.mak.orig	1970-01-01 01:00:00.000000000 +0100
+++ uClibc-0.9.29/Rules.mak.orig	2010-01-23 11:34:05.000000000 +0100
@@ -0,0 +1,534 @@
+# Rules.make for uClibc
+#
+# Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+# check for proper make version
+ifneq ($(findstring 3.7,$(MAKE_VERSION)),)
+$(error Your make is too old $(MAKE_VERSION). Go get at least 3.80)
+endif
+
+#-----------------------------------------------------------
+# This file contains rules which are shared between multiple
+# Makefiles.  All normal configuration options live in the
+# file named ".config".  Don't mess with this file unless
+# you know what you are doing.
+
+
+#-----------------------------------------------------------
+# If you are running a cross compiler, you will want to set
+# 'CROSS' to something more interesting ...  Target
+# architecture is determined by asking the CC compiler what
+# arch it compiles things for, so unless your compiler is
+# broken, you should not need to specify TARGET_ARCH.
+#
+# Most people will set this stuff on the command line, i.e.
+#        make CROSS=arm-linux-
+# will build uClibc for 'arm'.
+
+ifndef CROSS
+CROSS=
+endif
+CC         = $(CROSS)gcc
+AR         = $(CROSS)ar
+LD         = $(CROSS)ld
+NM         = $(CROSS)nm
+STRIPTOOL  = $(CROSS)strip
+
+INSTALL    = install
+LN         = ln
+RM         = rm -f
+TAR        = tar
+
+STRIP_FLAGS ?= -x -R .note -R .comment
+
+# Select the compiler needed to build binaries for your development system
+HOSTCC     = gcc
+BUILD_CFLAGS = -O2 -Wall
+export ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun.*/sparc/ -e s/sparc.*/sparc/ \
+				  -e s/arm.*/arm/ -e s/sa110/arm/ -e s/sh.*/sh/ \
+				  -e s/s390x/s390/ -e s/parisc.*/hppa/ \
+				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ )
+
+
+#---------------------------------------------------------
+# Nothing beyond this point should ever be touched by mere
+# mortals.  Unless you hang out with the gods, you should
+# probably leave all this stuff alone.
+
+# Pull in the user's uClibc configuration
+ifeq ($(filter $(noconfig_targets),$(MAKECMDGOALS)),)
+-include $(top_builddir).config
+endif
+
+# Make certain these contain a final "/", but no "//"s.
+TARGET_ARCH:=$(shell grep -s '^TARGET_ARCH' $(top_builddir)/.config | sed -e 's/^TARGET_ARCH=//' -e 's/"//g')
+TARGET_ARCH:=$(strip $(subst ",, $(strip $(TARGET_ARCH))))
+TARGET_SUBARCH:=$(shell grep -s '^TARGET_SUBARCH' $(top_builddir)/.config | sed -e 's/^TARGET_SUBARCH=//' -e 's/"//g')
+TARGET_SUBARCH:=$(strip $(subst ",, $(strip $(TARGET_SUBARCH))))
+RUNTIME_PREFIX:=$(strip $(subst //,/, $(subst ,/, $(subst ",, $(strip $(RUNTIME_PREFIX))))))
+DEVEL_PREFIX:=$(strip $(subst //,/, $(subst ,/, $(subst ",, $(strip $(DEVEL_PREFIX))))))
+KERNEL_HEADERS:=$(strip $(subst //,/, $(subst ,/, $(subst ",, $(strip $(KERNEL_HEADERS))))))
+export RUNTIME_PREFIX DEVEL_PREFIX KERNEL_HEADERS
+
+
+# Now config hard core
+MAJOR_VERSION := 0
+MINOR_VERSION := 9
+SUBLEVEL      := 29
+EXTRAVERSION  :=
+VERSION       := $(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL)
+ifneq ($(EXTRAVERSION),)
+VERSION       := $(VERSION)$(EXTRAVERSION)
+endif
+# Ensure consistent sort order, 'gcc -print-search-dirs' behavior, etc.
+LC_ALL := C
+export MAJOR_VERSION MINOR_VERSION SUBLEVEL VERSION LC_ALL
+
+LIBC := libc
+SHARED_MAJORNAME := $(LIBC).so.$(MAJOR_VERSION)
+ifneq ($(findstring  $(TARGET_ARCH) , hppa64 ia64 mips64 powerpc64 s390x sh64 sparc64 x86_64 ),)
+UCLIBC_LDSO_NAME := ld64-uClibc
+else
+UCLIBC_LDSO_NAME := ld-uClibc
+endif
+UCLIBC_LDSO := $(UCLIBC_LDSO_NAME).so.$(MAJOR_VERSION)
+NONSHARED_LIBNAME := uclibc_nonshared.a
+libc := $(top_builddir)lib/$(SHARED_MAJORNAME)
+interp := $(top_builddir)lib/interp.os
+ldso := $(top_builddir)lib/$(UCLIBC_LDSO)
+headers_dep := $(top_builddir)include/bits/sysnum.h
+sub_headers := $(headers_dep)
+
+#LIBS :=$(interp) -L$(top_builddir)lib -lc
+LIBS := $(interp) -L$(top_builddir)lib $(libc:.$(MAJOR_VERSION)=)
+
+# Make sure DESTDIR and PREFIX can be used to install
+# PREFIX is a uClibcism while DESTDIR is a common GNUism
+ifndef PREFIX
+PREFIX = $(DESTDIR)
+endif
+
+ifneq ($(HAVE_SHARED),y)
+libc :=
+interp :=
+ldso :=
+endif
+
+ifndef CROSS
+CROSS=$(subst ",, $(strip $(CROSS_COMPILER_PREFIX)))
+endif
+
+# A nifty macro to make testing gcc features easier
+check_gcc=$(shell \
+	if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; \
+	then echo "$(1)"; else echo "$(2)"; fi)
+check_as=$(shell \
+	if $(CC) -Wa,$(1) -Wa,-Z -c -o /dev/null -xassembler /dev/null > /dev/null 2>&1; \
+	then echo "-Wa,$(1)"; fi)
+check_ld=$(shell \
+	if $(LD) $(1) -o /dev/null -b binary /dev/null > /dev/null 2>&1; \
+	then echo "$(1)"; fi)
+
+ARFLAGS:=cr
+
+OPTIMIZATION:=
+# Use '-Os' optimization if available, else use -O2, allow Config to override
+OPTIMIZATION+=$(call check_gcc,-Os,-O2)
+# Use the gcc 3.4 -funit-at-a-time optimization when available
+OPTIMIZATION+=$(call check_gcc,-funit-at-a-time,)
+
+GCC_MAJOR_VER?=$(shell $(CC) -dumpversion | cut -d . -f 1)
+#GCC_MINOR_VER?=$(shell $(CC) -dumpversion | cut -d . -f 2)
+
+ifeq ($(GCC_MAJOR_VER),4)
+# shrinks code, results are from 4.0.2
+# 0.36%
+OPTIMIZATION+=$(call check_gcc,-fno-tree-loop-optimize,)
+# 0.34%
+OPTIMIZATION+=$(call check_gcc,-fno-tree-dominator-opts,)
+# 0.1%
+OPTIMIZATION+=$(call check_gcc,-fno-strength-reduce,)
+endif
+
+ifeq ($(UCLIBC_FORMAT_FDPIC_ELF),y)
+	ifeq ($(TARGET_ARCH),lm32)
+		PICFLAG:=
+	else
+		PICFLAG:=-mfdpic
+	endif
+else
+	PICFLAG:=-fPIC
+endif
+PIEFLAG_NAME:=-fPIE
+
+# Some nice CPU specific optimizations
+ifeq ($(TARGET_ARCH),i386)
+	OPTIMIZATION+=$(call check_gcc,-mpreferred-stack-boundary=2,)
+	OPTIMIZATION+=$(call check_gcc,-falign-jumps=0 -falign-loops=0,-malign-jumps=0 -malign-loops=0)
+	CPU_CFLAGS-$(CONFIG_386)+=-march=i386
+	CPU_CFLAGS-$(CONFIG_486)+=-march=i486
+	CPU_CFLAGS-$(CONFIG_ELAN)+=-march=i486
+	CPU_CFLAGS-$(CONFIG_586)+=-march=i586
+	CPU_CFLAGS-$(CONFIG_586MMX)+=$(call check_gcc,-march=pentium-mmx,-march=i586)
+	CPU_CFLAGS-$(CONFIG_686)+=-march=i686
+	CPU_CFLAGS-$(CONFIG_PENTIUMII)+=$(call check_gcc,-march=pentium2,-march=i686)
+	CPU_CFLAGS-$(CONFIG_PENTIUMIII)+=$(call check_gcc,-march=pentium3,-march=i686)
+	CPU_CFLAGS-$(CONFIG_PENTIUM4)+=$(call check_gcc,-march=pentium4,-march=i686)
+	CPU_CFLAGS-$(CONFIG_K6)+=$(call check_gcc,-march=k6,-march=i586)
+	CPU_CFLAGS-$(CONFIG_K7)+=$(call check_gcc,-march=athlon,-march=i686) $(call check_gcc,-falign-functions=4,-malign-functions=4)
+	CPU_CFLAGS-$(CONFIG_CRUSOE)+=-march=i686 $(call check_gcc,-falign-functions=0,-malign-functions=0)
+	CPU_CFLAGS-$(CONFIG_WINCHIPC6)+=$(call check_gcc,-march=winchip-c6,-march=i586)
+	CPU_CFLAGS-$(CONFIG_WINCHIP2)+=$(call check_gcc,-march=winchip2,-march=i586)
+	CPU_CFLAGS-$(CONFIG_CYRIXIII)+=$(call check_gcc,-march=c3,-march=i486) $(call check_gcc,-falign-functions=0,-malign-functions=0)
+	CPU_CFLAGS-$(CONFIG_NEHEMIAH)+=$(call check_gcc,-march=c3-2,-march=i686)
+endif
+
+ifeq ($(TARGET_ARCH),sparc)
+	CPU_CFLAGS-$(CONFIG_SPARC_V7)+=-mcpu=v7
+	CPU_CFLAGS-$(CONFIG_SPARC_V8)+=-mcpu=v8
+	CPU_CFLAGS-$(CONFIG_SPARC_V9)+=-mcpu=v9
+	CPU_CFLAGS-$(CONFIG_SPARC_V9B)+=$(call check_gcc,-mcpu=v9b,-mcpu=ultrasparc)
+endif
+
+ifeq ($(TARGET_ARCH),arm)
+	OPTIMIZATION+=-fstrict-aliasing
+	CPU_LDFLAGS-$(ARCH_LITTLE_ENDIAN)+=-EL
+	CPU_LDFLAGS-$(ARCH_BIG_ENDIAN)+=-EB
+	CPU_CFLAGS-$(ARCH_LITTLE_ENDIAN)+=-mlittle-endian
+	CPU_CFLAGS-$(ARCH_BIG_ENDIAN)+=-mbig-endian
+	CPU_CFLAGS-$(CONFIG_GENERIC_ARM)+=
+	CPU_CFLAGS-$(CONFIG_ARM610)+=-mtune=arm610 -march=armv3
+	CPU_CFLAGS-$(CONFIG_ARM710)+=-mtune=arm710 -march=armv3
+	CPU_CFLAGS-$(CONFIG_ARM7TDMI)+=-mtune=arm7tdmi -march=armv4t
+	CPU_CFLAGS-$(CONFIG_ARM720T)+=-mtune=arm7tdmi -march=armv4t
+	CPU_CFLAGS-$(CONFIG_ARM920T)+=-mtune=arm9tdmi -march=armv4t
+	CPU_CFLAGS-$(CONFIG_ARM922T)+=-mtune=arm9tdmi -march=armv4t
+	CPU_CFLAGS-$(CONFIG_ARM926T)+=-mtune=arm9tdmi -march=armv5t
+	CPU_CFLAGS-$(CONFIG_ARM10T)+=-mtune=arm10tdmi -march=armv5t
+	CPU_CFLAGS-$(CONFIG_ARM1136JF_S)+=-mtune=arm1136jf-s -march=armv6
+	CPU_CFLAGS-$(CONFIG_ARM1176JZ_S)+=-mtune=arm1176jz-s -march=armv6
+	CPU_CFLAGS-$(CONFIG_ARM1176JZF_S)+=-mtune=arm1176jzf-s -march=armv6
+	CPU_CFLAGS-$(CONFIG_ARM_SA110)+=-mtune=strongarm110 -march=armv4
+	CPU_CFLAGS-$(CONFIG_ARM_SA1100)+=-mtune=strongarm1100 -march=armv4
+	CPU_CFLAGS-$(CONFIG_ARM_XSCALE)+=$(call check_gcc,-mtune=xscale,-mtune=strongarm110)
+	CPU_CFLAGS-$(CONFIG_ARM_XSCALE)+=-march=armv5te -Wa,-mcpu=xscale
+ 	CPU_CFLAGS-$(CONFIG_ARM_IWMMXT)+=-march=iwmmxt -Wa,-mcpu=iwmmxt -mabi=iwmmxt
+endif
+
+ifeq ($(TARGET_ARCH),mips)
+	CPU_LDFLAGS-$(ARCH_LITTLE_ENDIAN)+=-EL
+	CPU_LDFLAGS-$(ARCH_BIG_ENDIAN)+=-EB
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_1)+=-mips1
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_2)+=-mips2 -mtune=mips2
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_3)+=-mips3 -mtune=mips3
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_4)+=-mips4 -mtune=mips4
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_MIPS32)+=-mips32 -mtune=mips32
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_MIPS64)+=-mips64 -mtune=mips32
+	ifeq ($(strip $(ARCH_BIG_ENDIAN)),y)
+		CPU_LDFLAGS-$(CONFIG_MIPS_N64_ABI)+=-melf64btsmip
+		CPU_LDFLAGS-$(CONFIG_MIPS_O32_ABI)+=-melf32btsmip
+	endif
+	ifeq ($(strip $(ARCH_LITTLE_ENDIAN)),y)
+		CPU_LDFLAGS-$(CONFIG_MIPS_N64_ABI)+=-melf64ltsmip
+		CPU_LDFLAGS-$(CONFIG_MIPS_O32_ABI)+=-melf32ltsmip
+	endif
+	CPU_CFLAGS-$(CONFIG_MIPS_N64_ABI)+=-mabi=64
+	CPU_CFLAGS-$(CONFIG_MIPS_O32_ABI)+=-mabi=32
+	CPU_CFLAGS-$(CONFIG_MIPS_N32_ABI)+=-mabi=n32
+endif
+
+ifeq ($(TARGET_ARCH),nios)
+	CPU_LDFLAGS-y+=-m32
+	CPU_CFLAGS-y+=-m32
+endif
+
+
+ifeq ($(TARGET_ARCH),lm32)
+## FIXME: revisit & make configurable through options
+	CPU_LDFLAGS-y+=-mmultiply-enabled -mdivide-enabled -mbarrel-shift-enabled -msign-extend-enabled
+	CPU_CFLAGS-y+=-mmultiply-enabled -mdivide-enabled -mbarrel-shift-enabled -msign-extend-enabled
+endif
+
+ifeq ($(TARGET_ARCH),sh)
+	OPTIMIZATION+=-fstrict-aliasing
+	OPTIMIZATION+= $(call check_gcc,-mprefergot,)
+	CPU_LDFLAGS-$(ARCH_LITTLE_ENDIAN)+=-EL
+	CPU_LDFLAGS-$(ARCH_BIG_ENDIAN)+=-EB
+	CPU_CFLAGS-$(ARCH_LITTLE_ENDIAN)+=-ml
+	CPU_CFLAGS-$(ARCH_BIG_ENDIAN)+=-mb
+	CPU_CFLAGS-$(CONFIG_SH2)+=-m2
+	CPU_CFLAGS-$(CONFIG_SH3)+=-m3
+ifeq ($(UCLIBC_HAS_FLOATS),y)
+	CPU_CFLAGS-$(CONFIG_SH2A)+=-m2a
+	CPU_CFLAGS-$(CONFIG_SH4)+=-m4
+else
+	CPU_CFLAGS-$(CONFIG_SH2A)+=-m2a-nofpu
+	CPU_CFLAGS-$(CONFIG_SH4)+=-m4-nofpu
+endif
+endif
+
+ifeq ($(TARGET_ARCH),sh64)
+	OPTIMIZATION+=-fstrict-aliasing
+	CPU_LDFLAGS-$(ARCH_LITTLE_ENDIAN):=-EL
+	CPU_LDFLAGS-$(ARCH_BIG_ENDIAN):=-EB
+	CPU_CFLAGS-$(ARCH_LITTLE_ENDIAN):=-ml
+	CPU_CFLAGS-$(ARCH_BIG_ENDIAN):=-mb
+	CPU_CFLAGS-$(CONFIG_SH5)+=-m5-32media
+endif
+
+ifeq ($(TARGET_ARCH),h8300)
+	CPU_LDFLAGS-$(CONFIG_H8300H)+= -ms8300h
+	CPU_LDFLAGS-$(CONFIG_H8S)   += -ms8300s
+	CPU_CFLAGS-$(CONFIG_H8300H) += -mh -mint32
+	CPU_CFLAGS-$(CONFIG_H8S)    += -ms -mint32
+endif
+
+ifeq ($(TARGET_ARCH),cris)
+	CPU_LDFLAGS-$(CONFIG_CRIS)+=-mcrislinux
+	CPU_LDFLAGS-$(CONFIG_CRISV32)+=-mcrislinux
+	CPU_CFLAGS-$(CONFIG_CRIS)+=-mlinux
+	PICFLAG:=-fpic
+	PIEFLAG_NAME:=-fpie
+endif
+
+ifeq ($(TARGET_ARCH),m68k)
+	# -fPIC is only supported for 68020 and above.  It is not supported
+	# for 68000, 68010, or Coldfire.
+	PICFLAG:=-fpic
+	PIEFLAG_NAME:=-fpie
+endif
+
+ifeq ($(TARGET_ARCH),powerpc)
+# PowerPC can hold 8192 entries in its GOT with -fpic which is more than
+# enough. Therefore use -fpic which will reduce code size and generates
+# faster code.
+	PICFLAG:=-fpic
+	PIEFLAG_NAME:=-fpie
+	PPC_HAS_REL16:=$(shell echo -e "\t.text\n\taddis 11,30,_GLOBAL_OFFSET_TABLE_-.@ha" | $(CC) -c -x assembler -o /dev/null -  2> /dev/null && echo -n y || echo -n n)
+	CPU_CFLAGS-$(PPC_HAS_REL16)+= -DHAVE_ASM_PPC_REL16
+	CPU_CFLAGS-$(CONFIG_E500) += "-D__NO_MATH_INLINES -D__NO_LONG_DOUBLE_MATH"
+
+endif
+
+ifeq ($(TARGET_ARCH),frv)
+	CPU_LDFLAGS-$(CONFIG_FRV)+=-melf32frvfd
+	# Using -pie causes the program to have an interpreter, which is
+	# forbidden, so we must make do with -shared.  Unfortunately,
+	# -shared by itself would get us global function descriptors
+	# and calls through PLTs, dynamic resolution of symbols, etc,
+	# which would break as well, but -Bsymbolic comes to the rescue.
+	export LDPIEFLAG:=-shared -Bsymbolic
+	UCLIBC_LDSO=ld.so.1
+endif
+
+# Keep the check_gcc from being needlessly executed
+ifndef PIEFLAG
+ifneq ($(UCLIBC_BUILD_PIE),y)
+export PIEFLAG:=
+else
+export PIEFLAG:=$(call check_gcc,$(PIEFLAG_NAME),$(PICFLAG))
+endif
+endif
+# We need to keep track of both the CC PIE flag (above) as
+# well as the LD PIE flag (below) because we can't rely on
+# gcc passing -pie if we used -fPIE
+ifndef LDPIEFLAG
+ifneq ($(UCLIBC_BUILD_PIE),y)
+export LDPIEFLAG:=
+else
+export LDPIEFLAG:=$(shell $(LD) --help 2>/dev/null | grep -q -- -pie && echo "-Wl,-pie")
+endif
+endif
+
+# Check for AS_NEEDED support in linker script (binutils>=2.16.1 has it)
+ifndef ASNEEDED
+ifneq ($(UCLIBC_HAS_SSP),y)
+export ASNEEDED:=
+else
+export ASNEEDED:=$(shell (LD_TMP=$(mktemp LD_XXXXXX) ; echo "GROUP ( AS_NEEDED ( /usr/lib/libc.so ) )" > $LD_TMP && if $(LD) -T $LD_TMP -o /dev/null > /dev/null 2>&1; then echo "AS_NEEDED ( $(UCLIBC_LDSO) )"; else echo "$(UCLIBC_LDSO)"; fi; rm -f $LD_TMP ) )
+endif
+endif
+
+# Add a bunch of extra pedantic annoyingly strict checks
+XWARNINGS=$(subst ",, $(strip $(WARNINGS))) -Wstrict-prototypes -fno-strict-aliasing
+ifeq ($(EXTRA_WARNINGS),y)
+XWARNINGS+=-Wnested-externs -Wshadow -Wmissing-noreturn -Wmissing-format-attribute -Wformat=2
+XWARNINGS+=-Wmissing-prototypes -Wmissing-declarations
+XWARNINGS+=-Wnonnull -Wundef
+# works only w/ gcc-3.4 and up, can't be checked for gcc-3.x w/ check_gcc()
+#XWARNINGS+=-Wdeclaration-after-statement
+endif
+XARCH_CFLAGS=$(subst ",, $(strip $(ARCH_CFLAGS)))
+CPU_CFLAGS=$(subst ",, $(strip $(CPU_CFLAGS-y)))
+
+SSP_DISABLE_FLAGS ?= $(call check_gcc,-fno-stack-protector,)
+ifeq ($(UCLIBC_BUILD_SSP),y)
+SSP_CFLAGS := $(call check_gcc,-fno-stack-protector-all,)
+SSP_CFLAGS += $(call check_gcc,-fstack-protector,)
+SSP_ALL_CFLAGS ?= $(call check_gcc,-fstack-protector-all,)
+else
+SSP_CFLAGS := $(SSP_DISABLE_FLAGS)
+endif
+
+# Some nice CFLAGS to work with
+CFLAGS := -include $(top_builddir)include/libc-symbols.h \
+	$(XWARNINGS) $(CPU_CFLAGS) $(SSP_CFLAGS) \
+	-fno-builtin -nostdinc -I$(top_builddir)include -I.
+
+ifneq ($(strip $(UCLIBC_EXTRA_CFLAGS)),"")
+CFLAGS += $(subst ",, $(UCLIBC_EXTRA_CFLAGS))
+endif
+
+LDADD_LIBFLOAT=
+ifeq ($(UCLIBC_HAS_SOFT_FLOAT),y)
+# If -msoft-float isn't supported, we want an error anyway.
+# Hmm... might need to revisit this for arm since it has 2 different
+# soft float encodings.
+ifneq ($(TARGET_ARCH),nios)
+ifneq ($(TARGET_ARCH),nios2)
+CFLAGS += -msoft-float
+endif
+endif
+ifeq ($(TARGET_ARCH),arm)
+# No longer needed with current toolchains, but leave it here for now.
+# If anyone is actually still using gcc 2.95 (say), they can uncomment it.
+#    LDADD_LIBFLOAT=-lfloat
+endif
+endif
+
+# We need this to be checked within libc-symbols.h
+ifneq ($(HAVE_SHARED),y)
+CFLAGS += -DSTATIC
+endif
+
+CFLAGS += $(call check_gcc,-std=gnu99,)
+
+LDFLAGS_NOSTRIP:=$(CPU_LDFLAGS-y) -shared --warn-common --warn-once -z combreloc
+# binutils-2.16.1 warns about ignored sections, 2.16.91.0.3 and newer are ok
+#LDFLAGS_NOSTRIP+=$(call check_ld,--gc-sections)
+
+ifeq ($(UCLIBC_BUILD_RELRO),y)
+LDFLAGS_NOSTRIP+=-z relro
+endif
+
+ifeq ($(UCLIBC_BUILD_NOW),y)
+LDFLAGS_NOSTRIP+=-z now
+endif
+
+LDFLAGS:=$(LDFLAGS_NOSTRIP) -z defs
+ifeq ($(DODEBUG),y)
+#CFLAGS += -g3
+ifeq ($(TARGET_ARCH),lm32)
+CFLAGS += -O2 -g3
+else
+CFLAGS += -O0 -g3
+endif
+else
+CFLAGS += $(OPTIMIZATION) $(XARCH_CFLAGS)
+endif
+ifeq ($(DOSTRIP),y)
+LDFLAGS += -s
+else
+STRIPTOOL := true -Stripping_disabled
+endif
+
+ifeq ($(DOMULTI),y)
+# we try to compile all sources at once into an object (IMA), but
+# gcc-3.3.x does not support it
+# gcc-3.4.x supports it, but does not need and support --combine. though fails on many sources
+# gcc-4.0.x supports it, supports the --combine flag, but does not need it
+# gcc-4.1(200506xx) supports it, but needs the --combine flag, else libs are useless
+ifeq ($(GCC_MAJOR_VER),3)
+DOMULTI:=n
+else
+CFLAGS+=$(call check_gcc,--combine,)
+endif
+else
+DOMULTI:=n
+endif
+
+ifeq ($(UCLIBC_HAS_THREADS),y)
+ifeq ($(UCLIBC_HAS_THREADS_NATIVE),y)
+	PTNAME := nptl
+else
+ifeq ($(LINUXTHREADS_OLD),y)
+	PTNAME := linuxthreads.old
+else
+	PTNAME := linuxthreads
+endif
+endif
+PTDIR := $(top_builddir)libpthread/$(PTNAME)
+# set up system dependencies include dirs (NOTE: order matters!)
+ifeq ($(UCLIBC_HAS_THREADS_NATIVE),y)
+PTINC:=	-I$(PTDIR)						\
+	-I$(PTDIR)/sysdeps/unix/sysv/linux/$(TARGET_ARCH)	\
+	-I$(PTDIR)/sysdeps/$(TARGET_ARCH)			\
+	-I$(PTDIR)/sysdeps/unix/sysv/linux			\
+	-I$(PTDIR)/sysdeps/pthread				\
+	-I$(PTDIR)/sysdeps/pthread/bits				\
+	-I$(PTDIR)/sysdeps/generic				\
+	-I$(top_srcdir)ldso/ldso/$(TARGET_ARCH)			\
+	-I$(top_srcdir)ldso/include
+#
+# Test for TLS if NPTL support was selected.
+#
+GCC_HAS_TLS=$(shell \
+	echo "extern __thread int foo;" | $(CC) -o /dev/null -S -xc - 2>&1)
+ifneq ($(GCC_HAS_TLS),)
+gcc_tls_test_fail:
+	@echo "####";
+	@echo "#### Your compiler does not support TLS and you are trying to build uClibc";
+	@echo "#### with NPTL support. Upgrade your binutils and gcc to versions which";
+	@echo "#### support TLS for your architecture. Do not contact uClibc maintainers";
+	@echo "#### about this problem.";
+	@echo "####";
+	@echo "#### Exiting...";
+	@echo "####";
+	@exit 1;
+endif
+else
+PTINC := \
+	-I$(PTDIR)/sysdeps/unix/sysv/linux/$(TARGET_ARCH) \
+	-I$(PTDIR)/sysdeps/$(TARGET_ARCH) \
+	-I$(PTDIR)/sysdeps/unix/sysv/linux \
+	-I$(PTDIR)/sysdeps/pthread \
+	-I$(PTDIR) \
+	-I$(top_builddir)libpthread
+endif
+CFLAGS+=$(PTINC)
+else
+	PTNAME :=
+	PTINC  :=
+endif
+CFLAGS += -I$(KERNEL_HEADERS)
+
+# Sigh, some stupid versions of gcc can't seem to cope with '-iwithprefix include'
+#CFLAGS+=-iwithprefix include
+CFLAGS+=-isystem $(shell $(CC) -print-file-name=include)
+
+ifneq ($(DOASSERTS),y)
+CFLAGS+=-DNDEBUG
+endif
+
+# Keep the check_as from being needlessly executed
+ifndef ASFLAGS_NOEXEC
+ifeq ($(UCLIBC_BUILD_NOEXECSTACK),y)
+export ASFLAGS_NOEXEC := $(call check_as,--noexecstack)
+else
+export ASFLAGS_NOEXEC :=
+endif
+endif
+ASFLAGS = $(ASFLAGS_NOEXEC)
+
+LIBGCC_CFLAGS ?= $(CFLAGS) $(CPU_CFLAGS-y)
+LIBGCC:=$(shell $(CC) $(LIBGCC_CFLAGS) -print-libgcc-file-name)
+LIBGCC_DIR:=$(dir $(LIBGCC))
+
+# moved from libpthread/linuxthreads
+ifeq ($(UCLIBC_CTOR_DTOR),y)
+SHARED_START_FILES:=$(top_builddir)lib/crti.o $(LIBGCC_DIR)crtbeginS.o
+SHARED_END_FILES:=$(LIBGCC_DIR)crtendS.o $(top_builddir)lib/crtn.o
+endif
diff -Naur uClibc-0.9.29.orig/utils/ldd.c uClibc-0.9.29/utils/ldd.c
--- uClibc-0.9.29.orig/utils/ldd.c	2007-04-18 00:31:01.000000000 +0200
+++ uClibc-0.9.29/utils/ldd.c	2010-01-23 11:34:05.000000000 +0100
@@ -72,6 +72,11 @@
 #define ELFCLASSM	ELFCLASS64
 #endif
 
+#if defined(__lm32__)
+#define MATCH_MACHINE(x) (x == EM_LATTICEMICO32)
+#define ELFCLASSM	ELFCLASS32
+#endif
+
 #if defined(__mc68000__)
 #define MATCH_MACHINE(x) (x == EM_68K)
 #define ELFCLASSM	ELFCLASS32
diff -Naur uClibc-0.9.29.orig/utils/readelf.c uClibc-0.9.29/utils/readelf.c
--- uClibc-0.9.29.orig/utils/readelf.c	2006-10-07 08:01:37.000000000 +0200
+++ uClibc-0.9.29/utils/readelf.c	2010-01-23 11:34:05.000000000 +0100
@@ -245,6 +245,7 @@
 		case EM_ALTERA_NIOS2:	tmp="Altera Nios II"; break;
 		case EM_VPP500:		tmp="Fujitsu VPP500"; break;
 		case EM_PDSP:		tmp="Sony DSP Processor"; break;
+		case EM_LATTICEMICO32:	tmp="Lattice Mico32"; break;
 		default:			tmp="unknown";
 	}
 	printf( "Machine:\t%s\n", tmp);	

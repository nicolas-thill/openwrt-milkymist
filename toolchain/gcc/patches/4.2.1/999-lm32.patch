diff --git a/config.sub b/config.sub
index fab0aa3..6666f23 100755
--- a/config.sub
+++ b/config.sub
@@ -249,6 +249,7 @@ case $basic_machine in
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
 	| maxq | mb | microblaze | mcore \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
@@ -330,6 +331,7 @@ case $basic_machine in
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
 	| m32c-* | m32r-* | m32rle-* \
+	| lm32-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
 	| m88110-* | m88k-* | maxq-* | mcore-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 9a142e2..b7622c5 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -1395,6 +1395,14 @@ iq2000*-*-elf*)
         md_file=iq2000/iq2000.md
 	use_fixproto=yes
         ;;
+lm32-*-elf)
+	tm_file="dbxelf.h elfos.h ${tm_file}"
+	tmake_file=lm32/t-lm32
+	;;
+lm32-*-linux*)
+	tm_file="dbxelf.h elfos.h ${tm_file} linux.h lm32/uclinux-elf.h"
+	tmake_file=lm32/t-lm32
+	;;
 m32r-*-elf*)
 	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
 	extra_parts="crtinit.o crtfini.o"
diff --git a/gcc/config/linux.h b/gcc/config/linux.h
index 59e3e85..bdf694a 100644
--- a/gcc/config/linux.h
+++ b/gcc/config/linux.h
@@ -22,7 +22,9 @@ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
 Boston, MA 02110-1301, USA.  */
 
 /* Don't assume anything about the header files.  */
+#ifndef NO_IMPLICIT_EXTERN_C
 #define NO_IMPLICIT_EXTERN_C
+#endif
 
 #undef ASM_APP_ON
 #define ASM_APP_ON "#APP\n"
diff --git a/gcc/config/lm32/arithmetic.c b/gcc/config/lm32/arithmetic.c
new file mode 100644
index 0000000..ec52d05
--- /dev/null
+++ b/gcc/config/lm32/arithmetic.c
@@ -0,0 +1,264 @@
+/* Fixed-point arithmetic.
+   Contributed by Jon Beniston <jon@beniston.com> */
+
+typedef unsigned long UQItype __attribute__ ((mode (QI)));
+typedef	long SItype __attribute__ ((mode (SI)));
+typedef unsigned long USItype __attribute__ ((mode (SI)));
+
+/* Prototypes */
+
+USItype __mulsi3 (USItype a, USItype b);
+
+USItype __udivmodsi4 (USItype num, USItype den, int modwanted);
+SItype __divsi3 (SItype a, SItype b);
+SItype __modsi3 (SItype a, SItype b);
+USItype __udivsi3 (USItype a, USItype b);
+USItype __umodsi3 (USItype a, USItype b);
+
+SItype __ashlsi3 (SItype a, SItype b);
+SItype __ashrsi3 (SItype a, SItype b);
+USItype __lshrsi3 (USItype a, USItype b);
+
+/* Multiplication */
+
+#ifdef L_mulsi3
+USItype 
+__mulsi3 (USItype a, USItype b)
+{
+  USItype result;
+    
+  result = 0;
+
+  if (a==0)
+    return 0;
+
+  while (b!=0)
+    {
+      if (b & 1)
+        result += a;
+      a <<= 1;
+      b >>= 1;
+    }
+       
+  return result;    
+}
+#endif
+
+/* Division */
+
+#ifdef L_udivmodsi4
+USItype
+__udivmodsi4 (USItype num, USItype den, int modwanted)
+{
+  USItype bit = 1;
+  USItype res = 0;
+
+  while (den < num && bit && !(den & (1L<<31)))
+    {
+      den <<=1;
+      bit <<=1;
+    }
+  while (bit)
+    {
+      if (num >= den)
+	{
+	  num -= den;
+	  res |= bit;
+	}
+      bit >>=1;
+      den >>=1;
+    }
+  if (modwanted) 
+    return num;
+  return res;
+}
+#endif
+
+#ifdef L_divsi3
+
+static const UQItype __divsi3_table[] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 4, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 5, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 6, 3, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 7, 3, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 8, 4, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
+  0, 9, 4, 3, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
+  0, 10, 5, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
+  0, 11, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
+  0, 12, 6, 4, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0,
+  0, 13, 6, 4, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0,
+  0, 14, 7, 4, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0,
+  0, 15, 7, 5, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+
+SItype
+__divsi3 (SItype a, SItype b)
+{
+  int neg = 0;
+  SItype res;
+  int cfg;
+
+  if (b == 0) 
+    {
+      /* Raise divide by zero exception */
+      int eba;
+      __asm__ __volatile__ ("rcsr %0, EBA" : "=r" (eba));
+      eba += 32 * 5;
+      __asm__ __volatile__ ("mv ea, ra");
+      __asm__ __volatile__ ("b %0" : : "r" (eba)); 
+    }
+
+  if (((USItype)(a | b)) < 16)
+    {
+      res = __divsi3_table[(a << 4) + b];
+    } 
+  else
+    {
+
+      if (a < 0)
+        {
+          a = -a;
+          neg = !neg;
+        }
+    
+      if (b < 0)
+        {
+          b = -b;
+          neg = !neg;
+        }
+    
+      __asm__ ("rcsr %0, CFG" : "=r" (cfg));
+      if (cfg & 2)
+        __asm__ ("divu %0, %1, %2" : "=r" (res) : "r" (a), "r" (b));
+      else 
+        res = __udivmodsi4 (a, b, 0);
+    
+      if (neg)
+        res = -res;
+    }
+
+  return res;
+}
+#endif
+
+#ifdef L_modsi3
+SItype
+__modsi3 (SItype a, SItype b)
+{
+  int neg = 0;
+  SItype res;
+  int cfg;
+  
+  if (b == 0) 
+    {
+      /* Raise divide by zero exception */
+      int eba;
+      __asm__ __volatile__ ("rcsr %0, EBA" : "=r" (eba));
+      eba += 32 * 5;
+      __asm__ __volatile__ ("mv ea, ra");
+      __asm__ __volatile__ ("b %0" : : "r" (eba)); 
+    }
+  
+  if (a < 0)
+    {
+      a = -a;
+      neg = 1;
+    }
+
+  if (b < 0)
+    b = -b;
+
+  __asm__ ("rcsr %0, CFG" : "=r" (cfg));
+  if (cfg & 2)
+    __asm__ ("modu %0, %1, %2" : "=r" (res) : "r" (a), "r" (b));
+  else 
+    res = __udivmodsi4 (a, b, 1);
+
+  if (neg)
+    res = -res;
+
+  return res;
+}
+#endif
+
+#ifdef L_udivsi3
+USItype
+__udivsi3 (USItype a, USItype b)
+{
+  if (b == 0) 
+    {
+      /* Raise divide by zero exception */
+      int eba;
+      __asm__ __volatile__ ("rcsr %0, EBA" : "=r" (eba));
+      eba += 32 * 5;
+      __asm__ __volatile__ ("mv ea, ra");
+      __asm__ __volatile__ ("b %0" : : "r" (eba)); 
+    }
+  
+  return __udivmodsi4 (a, b, 0);
+}
+#endif
+
+#ifdef L_umodsi3
+USItype
+__umodsi3 (USItype a, USItype b)
+{
+  if (b == 0) 
+    {
+      /* Raise divide by zero exception */
+      int eba;
+      __asm__ __volatile__ ("rcsr %0, EBA" : "=r" (eba));
+      eba += 32 * 5;
+      __asm__ __volatile__ ("mv ea, ra");
+      __asm__ __volatile__ ("b %0" : : "r" (eba)); 
+    }
+  
+  return __udivmodsi4 (a, b, 1);
+}
+#endif
+
+#if 0
+
+/* Shifts - Optimized versions implemented in assembly. Use these if code space is preferred to performance.  */
+
+#ifdef L_ashlsi3
+SItype 
+__ashlsi3 (SItype a, SItype b)
+{
+  int i;
+  
+  for (i = (b & 0x1f); i > 0; --i)
+    a += a;
+  return a;
+}
+#endif
+
+#ifdef L_ashrsi3
+SItype
+__ashrsi3 (SItype a, SItype b)
+{
+  int i;
+  
+  for (i = (b & 0x1f); i > 0; --i)
+    __asm__ ("sri      %0, %0, 1" : "=r" (a) : "0" (a));
+  return a;
+}
+#endif
+
+#ifdef L_lshrsi3
+USItype
+__lshrsi3 (USItype a, USItype b)
+{
+  int i;
+  
+  for (i = (b & 0x1f); i > 0; --i)
+    __asm__ ("srui     %0, %0, 1" : "=r" (a) : "0" (a));
+  return a;
+}
+#endif
+
+#endif 
diff --git a/gcc/config/lm32/crti.S b/gcc/config/lm32/crti.S
new file mode 100644
index 0000000..29d6c93
--- /dev/null
+++ b/gcc/config/lm32/crti.S
@@ -0,0 +1,48 @@
+# crti.S for LatticeMico32 
+# Contributed by Jon Beniston <jon@beniston.com>
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2, or (at your option) any
+# later version.
+# 
+# In addition to the permissions in the GNU General Public License, the
+# Free Software Foundation gives you unlimited permission to link the
+# compiled version of this file with other programs, and to distribute
+# those programs without any restriction coming from the use of this
+# file.  (The General Public License restrictions do apply in other
+# respects; for example, they cover modification of the file, and
+# distribution when not linked into another program.)
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING.  If not, write to
+# the Free Software Foundation, 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+# 
+#    As a special exception, if you link this library with files
+#    compiled with GCC to produce an executable, this does not cause
+#    the resulting executable to be covered by the GNU General Public License.
+#    This exception does not however invalidate any other reasons why
+#    the executable file might be covered by the GNU General Public License.
+#
+
+        .section .init
+        .global _init
+        .type _init,@function
+        .align 4
+_init:
+        addi    sp, sp, -4        
+        sw      (sp+4), ra
+
+        .section .fini
+        .global _fini
+        .type _fini,@function
+        .align 4
+_fini:        
+        addi    sp, sp, -4        
+        sw      (sp+4), ra
diff --git a/gcc/config/lm32/crtn.S b/gcc/config/lm32/crtn.S
new file mode 100644
index 0000000..85d198b
--- /dev/null
+++ b/gcc/config/lm32/crtn.S
@@ -0,0 +1,45 @@
+# crtn.S for LatticeMico32
+# Contributed by Jon Beniston <jon@beniston.com>
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2, or (at your option) any
+# later version.
+# 
+# In addition to the permissions in the GNU General Public License, the
+# Free Software Foundation gives you unlimited permission to link the
+# compiled version of this file with other programs, and to distribute
+# those programs without any restriction coming from the use of this
+# file.  (The General Public License restrictions do apply in other
+# respects; for example, they cover modification of the file, and
+# distribution when not linked into another program.)
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING.  If not, write to
+# the Free Software Foundation, 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+# 
+#    As a special exception, if you link this library with files
+#    compiled with GCC to produce an executable, this does not cause
+#    the resulting executable to be covered by the GNU General Public License.
+#    This exception does not however invalidate any other reasons why
+#    the executable file might be covered by the GNU General Public License.
+#
+
+        .section .init
+        
+        lw      ra, (sp+4)
+        addi    sp, sp, 4
+        ret
+                
+        .section .fini
+        
+        lw      ra, (sp+4)
+        addi    sp, sp, 4
+        ret
+        
diff --git a/gcc/config/lm32/lib1funcs.S b/gcc/config/lm32/lib1funcs.S
new file mode 100644
index 0000000..f75a099
--- /dev/null
+++ b/gcc/config/lm32/lib1funcs.S
@@ -0,0 +1,402 @@
+# shift.S for LatticeMico32 
+# Contributed by Jon Beniston <jon@beniston.com>
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2, or (at your option) any
+# later version.
+# 
+# In addition to the permissions in the GNU General Public License, the
+# Free Software Foundation gives you unlimited permission to link the
+# compiled version of this file with other programs, and to distribute
+# those programs without any restriction coming from the use of this
+# file.  (The General Public License restrictions do apply in other
+# respects; for example, they cover modification of the file, and
+# distribution when not linked into another program.)
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING.  If not, write to
+# the Free Software Foundation, 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+# 
+#    As a special exception, if you link this library with files
+#    compiled with GCC to produce an executable, this does not cause
+#    the resulting executable to be covered by the GNU General Public License.
+#    This exception does not however invalidate any other reasons why
+#    the executable file might be covered by the GNU General Public License.
+#
+
+/* Arithmetic left shift */
+        
+        .text
+
+        .global __ashlsi3
+        .type __ashlsi3,@function
+        .align 4
+        
+__ashlsi3:
+        /* Only use 5 LSBs, as that's all the h/w shifter uses */
+        andi    r2, r2, 0x1f
+        /* Get address of offset into unrolled shift loop to jump to */
+        mvhi    r3, hi(__ashlsi3_table)
+        ori     r3, r3, lo(__ashlsi3_table)
+        add     r2, r2, r2
+        add     r2, r2, r2
+        add     r3, r3, r2
+        lw      r3, (r3+0)
+        b       r3        
+        
+__ashlsi3_31:
+        add     r1, r1, r1
+__ashlsi3_30:
+        add     r1, r1, r1
+__ashlsi3_29:
+        add     r1, r1, r1
+__ashlsi3_28:
+        add     r1, r1, r1
+__ashlsi3_27:
+        add     r1, r1, r1
+__ashlsi3_26:
+        add     r1, r1, r1
+__ashlsi3_25:
+        add     r1, r1, r1
+__ashlsi3_24:
+        add     r1, r1, r1
+__ashlsi3_23:
+        add     r1, r1, r1
+__ashlsi3_22:
+        add     r1, r1, r1
+__ashlsi3_21:
+        add     r1, r1, r1
+__ashlsi3_20:
+        add     r1, r1, r1
+__ashlsi3_19:
+        add     r1, r1, r1
+__ashlsi3_18:
+        add     r1, r1, r1
+__ashlsi3_17:
+        add     r1, r1, r1
+__ashlsi3_16:
+        add     r1, r1, r1
+__ashlsi3_15:
+        add     r1, r1, r1
+__ashlsi3_14:
+        add     r1, r1, r1
+__ashlsi3_13:
+        add     r1, r1, r1
+__ashlsi3_12:
+        add     r1, r1, r1
+__ashlsi3_11:
+        add     r1, r1, r1
+__ashlsi3_10:
+        add     r1, r1, r1
+__ashlsi3_9:
+        add     r1, r1, r1
+__ashlsi3_8:
+        add     r1, r1, r1
+__ashlsi3_7:
+        add     r1, r1, r1
+__ashlsi3_6:
+        add     r1, r1, r1
+__ashlsi3_5:
+        add     r1, r1, r1
+__ashlsi3_4:
+        add     r1, r1, r1
+__ashlsi3_3:
+        add     r1, r1, r1
+__ashlsi3_2:
+        add     r1, r1, r1
+__ashlsi3_1:
+        add     r1, r1, r1
+__ashlsi3_0:
+        ret
+        
+        .section .rodata
+
+        .align 4
+
+__ashlsi3_table:
+        .word   __ashlsi3_0
+        .word   __ashlsi3_1
+        .word   __ashlsi3_2
+        .word   __ashlsi3_3
+        .word   __ashlsi3_4
+        .word   __ashlsi3_5
+        .word   __ashlsi3_6
+        .word   __ashlsi3_7
+        .word   __ashlsi3_8
+        .word   __ashlsi3_9
+        .word   __ashlsi3_10
+        .word   __ashlsi3_11
+        .word   __ashlsi3_12
+        .word   __ashlsi3_13
+        .word   __ashlsi3_14
+        .word   __ashlsi3_15
+        .word   __ashlsi3_16
+        .word   __ashlsi3_17
+        .word   __ashlsi3_18
+        .word   __ashlsi3_19
+        .word   __ashlsi3_20
+        .word   __ashlsi3_21
+        .word   __ashlsi3_22
+        .word   __ashlsi3_23
+        .word   __ashlsi3_24
+        .word   __ashlsi3_25
+        .word   __ashlsi3_26
+        .word   __ashlsi3_27
+        .word   __ashlsi3_28
+        .word   __ashlsi3_29
+        .word   __ashlsi3_30
+        .word   __ashlsi3_31
+        
+/* Logical right shift */
+        
+        .text
+        
+        .global __lshrsi3
+        .type __lshrsi3,@function
+        .align 4
+        
+__lshrsi3:
+        /* Only use 5 LSBs, as that's all the h/w shifter uses */
+        andi    r2, r2, 0x1f
+        /* Get address of offset into unrolled shift loop to jump to */
+        mvhi    r3, hi(__lshrsi3_table)
+        ori     r3, r3, lo(__lshrsi3_table)
+        add     r2, r2, r2
+        add     r2, r2, r2
+        add     r3, r3, r2
+        lw      r3, (r3+0)
+        b       r3        
+        
+__lshrsi3_31:        
+        srui    r1, r1, 1
+__lshrsi3_30:        
+        srui    r1, r1, 1
+__lshrsi3_29:        
+        srui    r1, r1, 1
+__lshrsi3_28:        
+        srui    r1, r1, 1
+__lshrsi3_27:        
+        srui    r1, r1, 1
+__lshrsi3_26:        
+        srui    r1, r1, 1
+__lshrsi3_25:        
+        srui    r1, r1, 1
+__lshrsi3_24:        
+        srui    r1, r1, 1
+__lshrsi3_23:        
+        srui    r1, r1, 1
+__lshrsi3_22:        
+        srui    r1, r1, 1
+__lshrsi3_21:        
+        srui    r1, r1, 1
+__lshrsi3_20:        
+        srui    r1, r1, 1
+__lshrsi3_19:        
+        srui    r1, r1, 1
+__lshrsi3_18:        
+        srui    r1, r1, 1
+__lshrsi3_17:        
+        srui    r1, r1, 1
+__lshrsi3_16:        
+        srui    r1, r1, 1
+__lshrsi3_15:        
+        srui    r1, r1, 1
+__lshrsi3_14:        
+        srui    r1, r1, 1
+__lshrsi3_13:        
+        srui    r1, r1, 1
+__lshrsi3_12:        
+        srui    r1, r1, 1
+__lshrsi3_11:        
+        srui    r1, r1, 1
+__lshrsi3_10:        
+        srui    r1, r1, 1
+__lshrsi3_9:        
+        srui    r1, r1, 1
+__lshrsi3_8:        
+        srui    r1, r1, 1
+__lshrsi3_7:        
+        srui    r1, r1, 1
+__lshrsi3_6:        
+        srui    r1, r1, 1
+__lshrsi3_5:        
+        srui    r1, r1, 1
+__lshrsi3_4:        
+        srui    r1, r1, 1
+__lshrsi3_3:        
+        srui    r1, r1, 1
+__lshrsi3_2:        
+        srui    r1, r1, 1
+__lshrsi3_1:        
+        srui    r1, r1, 1
+__lshrsi3_0:        
+        ret
+        
+        .section .rodata
+
+        .align 4
+
+__lshrsi3_table:        
+        .word   __lshrsi3_0        
+        .word   __lshrsi3_1        
+        .word   __lshrsi3_2        
+        .word   __lshrsi3_3        
+        .word   __lshrsi3_4        
+        .word   __lshrsi3_5        
+        .word   __lshrsi3_6        
+        .word   __lshrsi3_7        
+        .word   __lshrsi3_8        
+        .word   __lshrsi3_9        
+        .word   __lshrsi3_10        
+        .word   __lshrsi3_11        
+        .word   __lshrsi3_12        
+        .word   __lshrsi3_13        
+        .word   __lshrsi3_14        
+        .word   __lshrsi3_15        
+        .word   __lshrsi3_16        
+        .word   __lshrsi3_17        
+        .word   __lshrsi3_18        
+        .word   __lshrsi3_19        
+        .word   __lshrsi3_20        
+        .word   __lshrsi3_21        
+        .word   __lshrsi3_22        
+        .word   __lshrsi3_23        
+        .word   __lshrsi3_24        
+        .word   __lshrsi3_25        
+        .word   __lshrsi3_26        
+        .word   __lshrsi3_27        
+        .word   __lshrsi3_28
+        .word   __lshrsi3_29        
+        .word   __lshrsi3_30        
+        .word   __lshrsi3_31        
+        
+/* Arithmetic right shift */
+
+        .text
+        
+        .global __ashrsi3
+        .type __ashrsi3,@function
+        .align 4
+        
+__ashrsi3:
+        /* Only use 5 LSBs, as that's all the h/w shifter uses */
+        andi    r2, r2, 0x1f
+        /* Get address of offset into unrolled shift loop to jump to */
+        mvhi    r3, hi(__ashrsi3_table)
+        ori     r3, r3, lo(__ashrsi3_table)
+        add     r2, r2, r2
+        add     r2, r2, r2
+        add     r3, r3, r2
+        lw      r3, (r3+0)
+        b       r3        
+        
+__ashrsi3_31:
+        sri     r1, r1, 1
+__ashrsi3_30:
+        sri     r1, r1, 1
+__ashrsi3_29:
+        sri     r1, r1, 1
+__ashrsi3_28:
+        sri     r1, r1, 1
+__ashrsi3_27:
+        sri     r1, r1, 1
+__ashrsi3_26:
+        sri     r1, r1, 1
+__ashrsi3_25:
+        sri     r1, r1, 1
+__ashrsi3_24:
+        sri     r1, r1, 1
+__ashrsi3_23:
+        sri     r1, r1, 1
+__ashrsi3_22:
+        sri     r1, r1, 1
+__ashrsi3_21:
+        sri     r1, r1, 1
+__ashrsi3_20:
+        sri     r1, r1, 1
+__ashrsi3_19:
+        sri     r1, r1, 1
+__ashrsi3_18:
+        sri     r1, r1, 1
+__ashrsi3_17:
+        sri     r1, r1, 1
+__ashrsi3_16:
+        sri     r1, r1, 1
+__ashrsi3_15:
+        sri     r1, r1, 1
+__ashrsi3_14:
+        sri     r1, r1, 1
+__ashrsi3_13:
+        sri     r1, r1, 1
+__ashrsi3_12:
+        sri     r1, r1, 1
+__ashrsi3_11:
+        sri     r1, r1, 1
+__ashrsi3_10:
+        sri     r1, r1, 1
+__ashrsi3_9:
+        sri     r1, r1, 1
+__ashrsi3_8:
+        sri     r1, r1, 1
+__ashrsi3_7:
+        sri     r1, r1, 1
+__ashrsi3_6:
+        sri     r1, r1, 1
+__ashrsi3_5:
+        sri     r1, r1, 1
+__ashrsi3_4:
+        sri     r1, r1, 1
+__ashrsi3_3:
+        sri     r1, r1, 1
+__ashrsi3_2:
+        sri     r1, r1, 1
+__ashrsi3_1:
+        sri     r1, r1, 1
+__ashrsi3_0:
+        ret
+        
+        .section .rodata
+
+        .align 4
+
+__ashrsi3_table:
+        .word   __ashrsi3_0
+        .word   __ashrsi3_1
+        .word   __ashrsi3_2
+        .word   __ashrsi3_3
+        .word   __ashrsi3_4
+        .word   __ashrsi3_5
+        .word   __ashrsi3_6
+        .word   __ashrsi3_7
+        .word   __ashrsi3_8
+        .word   __ashrsi3_9
+        .word   __ashrsi3_10
+        .word   __ashrsi3_11
+        .word   __ashrsi3_12
+        .word   __ashrsi3_13
+        .word   __ashrsi3_14
+        .word   __ashrsi3_15
+        .word   __ashrsi3_16
+        .word   __ashrsi3_17
+        .word   __ashrsi3_18
+        .word   __ashrsi3_19
+        .word   __ashrsi3_20
+        .word   __ashrsi3_21
+        .word   __ashrsi3_22
+        .word   __ashrsi3_23
+        .word   __ashrsi3_24
+        .word   __ashrsi3_25
+        .word   __ashrsi3_26
+        .word   __ashrsi3_27
+        .word   __ashrsi3_28
+        .word   __ashrsi3_29
+        .word   __ashrsi3_30
+        .word   __ashrsi3_31
+        
diff --git a/gcc/config/lm32/lm32-protos.h b/gcc/config/lm32/lm32-protos.h
new file mode 100644
index 0000000..65b547c
--- /dev/null
+++ b/gcc/config/lm32/lm32-protos.h
@@ -0,0 +1,51 @@
+/* Prototypes of target machine functions, LatticeMico32 architecture.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+extern int lm32_return_in_memory (tree type);
+extern void lm32_declare_object (FILE *stream, char *name, char *init_string, 
+                                 char *final_string, int size);
+extern int symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED);
+extern int register_or_zero_operand (rtx op, enum machine_mode mode);
+extern int register_or_K_operand (rtx op, enum machine_mode mode);
+extern int constant_K_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED);
+extern int register_or_L_operand (rtx op, enum machine_mode mode);
+extern int constant_L_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED);
+extern int register_or_memory_operand (rtx op, enum machine_mode mode);
+extern int register_operand (rtx op, enum machine_mode mode);
+extern int const_ok_for_base_offset (rtx op, enum machine_mode mode);
+extern void lm32_expand_prologue (void);
+extern void lm32_expand_epilogue (void);
+extern unsigned int lm32_compute_frame_size (int size);
+extern void lm32_print_operand (FILE *file, rtx op, int letter);
+extern void lm32_print_operand_address (FILE *file, rtx addr);
+extern rtx lm32_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,
+                              tree type, int named);
+extern void lm32_override_options (void);
+extern unsigned int lm32_compute_initial_elimination_offset (unsigned int from, 
+                                                             unsigned int to);
+extern int lm32_can_use_return (void);
+extern rtx lm32_return_addr_rtx (int count, rtx frame);
+#ifdef RTX_CODE
+extern void gen_int_relational (enum rtx_code code, rtx result, rtx cmp0, 
+                                rtx cmp1, rtx destination);
+#endif
+extern int lm32_expand_block_move (rtx *);
+extern int nonpic_symbol_mentioned_p (rtx);
+extern rtx lm32_legitimize_pic_address (rtx, enum machine_mode, rtx);
diff --git a/gcc/config/lm32/lm32.c b/gcc/config/lm32/lm32.c
new file mode 100644
index 0000000..13ace2f
--- /dev/null
+++ b/gcc/config/lm32/lm32.c
@@ -0,0 +1,897 @@
+/* Subroutines used for code generation on the LatticeMico32 architecture.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "basic-block.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-flags.h"
+#include "insn-attr.h"
+#include "insn-codes.h"
+#include "recog.h"
+#include "output.h"
+#include "tree.h"
+#include "expr.h"
+#include "flags.h"
+#include "reload.h"
+#include "tm_p.h"
+#include "function.h"
+#include "toplev.h"
+#include "optabs.h"
+#include "libfuncs.h"
+#include "ggc.h"
+#include "target.h"
+#include "target-def.h"
+#include "langhooks.h"
+
+struct lm32_frame_info
+{
+  unsigned int total_size;      /* number of bytes that the entire frame takes up.  */
+  unsigned int callee_size;     /* number of bytes to save callee save registers  */
+  unsigned int pretend_size;    /* number of bytes we push and pretend caller did.  */
+  unsigned int args_size;       /* number of bytes that outgoing arguments take up.  */
+  unsigned int locals_size;     /* number of bytes that local variables take up.  */
+  unsigned int reg_save_mask;   /* mask of saved registers.  */
+};
+
+/* Prototypes for static functions */
+static rtx emit_add (rtx dest, rtx src0, rtx src1);
+static void expand_save_restore (struct lm32_frame_info *info, int op);
+static void abort_with_insn (rtx insn, const char *reason);
+static void stack_adjust (HOST_WIDE_INT amount);
+static bool lm32_in_small_data_p (tree);
+static void lm32_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode, 
+                             tree type, int *pretend_size, int no_rtl);
+
+/* Detemines if given constant can be used as a displacement */
+#define OFFSET_INT(X)  (((X) > -32768) && ((X) < 32768))
+
+#undef TARGET_ADDRESS_COST
+#define TARGET_ADDRESS_COST hook_int_rtx_0
+#undef TARGET_IN_SMALL_DATA_P
+#define TARGET_IN_SMALL_DATA_P lm32_in_small_data_p
+#undef TARGET_PROMOTE_FUNCTION_ARGS
+#define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_true
+#undef TARGET_PROMOTE_FUNCTION_RETURN
+#define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_true
+#undef TARGET_SETUP_INCOMING_VARARGS
+#define TARGET_SETUP_INCOMING_VARARGS lm32_setup_incoming_varargs
+#undef TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+/* Current frame information calculated by lm32_compute_frame_size.  */
+static struct lm32_frame_info current_frame_info;
+
+rtx lm32_compare_op0;
+rtx lm32_compare_op1;
+
+/* Return non-zero if the specified return type should be returned in memory */
+int
+lm32_return_in_memory (tree type)
+{
+  int size;
+
+  if (!AGGREGATE_TYPE_P (type))
+    {
+      /* All simple types are returned in registers.  */
+      return 0;
+    }
+
+  size = int_size_in_bytes (type);
+  if (size >=0 && size <= UNITS_PER_WORD)
+    {
+      /* If it can fit in one register */
+      return 0;
+    }
+  
+  return 1;
+}
+ 
+/* Determine if given constant can be used as a register displacement */
+int
+const_ok_for_base_offset (rtx op, enum machine_mode mode)
+{
+  int val;
+
+  val = INTVAL (op);
+  return OFFSET_INT (val);
+}
+
+/* Generate an emit a word sized add instruction */
+static rtx
+emit_add (rtx dest, rtx src0, rtx src1)
+{
+  rtx insn;
+  insn = emit_insn (gen_addsi3 (dest, src0, src1));
+  return insn;
+}
+
+/* Generate the code to compare (and possibly branch) two integer values
+   TEST_CODE is the comparison code we are trying to emulate 
+     (or implement directly)
+   RESULT is where to store the result of the comparison, 
+     or null to emit a branch
+   CMP0 CMP1 are the two comparison operands
+   DESTINATION is the destination of the branch, or null to only compare
+   */
+
+void
+gen_int_relational (enum rtx_code code, /* relational test (EQ, etc) */
+		    rtx result,		/* result to store comp. or 0 if branch */
+		    rtx cmp0,		/* first operand to compare */
+		    rtx cmp1,		/* second operand to compare */
+		    rtx destination)	/* destination of the branch, or 0 if compare */
+{
+  enum machine_mode mode;
+  int branch_p;
+
+  mode = GET_MODE (cmp0);
+  if (mode == VOIDmode)
+    mode = GET_MODE (cmp1);
+
+  branch_p = (destination != 0);
+
+  /* Instruction set doesn't support LE or LT, so swap operands and use GE, GT */
+  switch (code)
+    {
+      case LE: 
+      case LT: 
+      case LEU: 
+      case LTU:
+        code = swap_condition (code);
+        rtx temp = cmp0;
+        cmp0 = cmp1;
+        cmp1 = temp;       
+        break;
+      default:
+        break;  
+    }
+    
+  /* We can't have const_ints in cmp0. FIXME: except const_0 */
+  if (GET_CODE (cmp0) == CONST_INT)
+    cmp0 = force_reg (mode, cmp0);
+
+  /* if the comparison is against an int not in legal range
+     move it into a register */
+  if (GET_CODE (cmp1) == CONST_INT)
+    {
+      HOST_WIDE_INT value = INTVAL (cmp1);
+      switch (code) 
+        {
+          case EQ: case NE: case LE: case LT: case GE: case GT: 
+            if (!MEDIUM_INT(value))
+              cmp1 = force_reg (mode, cmp1);
+            break;
+          case LEU: case LTU: case GEU: case GTU:
+            if (!MEDIUM_UINT(value))
+              cmp1 = force_reg (mode, cmp1);
+            break;
+          default:
+            abort ();
+        }    
+    }
+
+  if (branch_p)
+    {
+      if (register_operand (cmp0, mode) && register_operand (cmp1, mode))
+	{
+	  rtx insn;
+	  rtx cond = gen_rtx_fmt_ee (code, mode, cmp0, cmp1);
+	  rtx label = gen_rtx_LABEL_REF (VOIDmode, destination);
+	  insn = gen_rtx_SET (VOIDmode, pc_rtx,
+			      gen_rtx_IF_THEN_ELSE (VOIDmode,
+						    cond, label, pc_rtx));
+	  emit_jump_insn (insn);
+	}
+      else
+	{
+	  rtx cond, label;
+
+	  result = gen_reg_rtx (mode);
+	  emit_move_insn (result,
+			  gen_rtx_fmt_ee (code, mode, cmp0, cmp1));
+	  cond = gen_rtx_fmt_ee (NE, mode, result, const0_rtx);
+	  label = gen_rtx_LABEL_REF (VOIDmode, destination);
+
+	  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
+				       gen_rtx_IF_THEN_ELSE (VOIDmode,
+							     cond,
+							     label, pc_rtx)));
+	}
+    }
+  else
+    {
+      if (register_operand (cmp0, mode) && register_operand (cmp1, mode))
+        emit_move_insn (result, gen_rtx_fmt_ee (code, mode, cmp0, cmp1));
+      else
+        emit_move_insn (result, gen_rtx_fmt_ee (code, mode, cmp0, cmp1));
+    }
+
+}
+
+/* Generate and emit RTL to save or restore callee save registers */
+static void
+expand_save_restore (struct lm32_frame_info *info, int op)
+{
+  unsigned int reg_save_mask = info->reg_save_mask;
+  int regno;
+  int offset;
+  rtx insn;
+
+  /* Callee saves are below locals and above outgoing arguments */
+  offset = info->args_size + info->callee_size;
+  for (regno = 0; regno <= 31; regno++)
+    {
+      if ((reg_save_mask & (1 << regno)) != 0)
+        {
+          if (op == 0)
+            {
+              insn = emit_move_insn (gen_rtx_MEM (word_mode, 
+                                                  gen_rtx_PLUS (Pmode,
+                                                                stack_pointer_rtx,
+                                                                GEN_INT (offset))), 
+                                     gen_rtx_REG (word_mode, regno));
+            }
+          else
+            {
+              insn = emit_move_insn (gen_rtx_REG (word_mode, regno),
+                                     gen_rtx_MEM (word_mode, 
+                                                  gen_rtx_PLUS (Pmode,
+                                                                stack_pointer_rtx,
+                                                                GEN_INT (offset))));
+            }
+
+	  /* only prologue instructions which set the sp fp or save a
+	     register should be marked as frame related */
+          if (op==0)
+	    RTX_FRAME_RELATED_P (insn) = 1;
+          offset -= UNITS_PER_WORD;
+        }
+    }
+}
+
+static void 
+stack_adjust (HOST_WIDE_INT amount)
+{
+  rtx insn;
+  
+  if (!MEDIUM_INT (amount))
+    {
+      /* r10 is caller saved so it can be used as a temp reg */
+      rtx r10;
+      r10 = gen_rtx_REG (word_mode, 10);  
+      insn = emit_move_insn (r10, GEN_INT (amount));
+      if (amount < 0)
+	RTX_FRAME_RELATED_P (insn) = 1;
+      insn = emit_add (stack_pointer_rtx, stack_pointer_rtx, r10);
+      if (amount < 0)
+	RTX_FRAME_RELATED_P (insn) = 1;
+    }
+  else
+    {
+      insn = emit_add (stack_pointer_rtx,
+                       stack_pointer_rtx,
+                       GEN_INT (amount));
+      if (amount < 0)
+	RTX_FRAME_RELATED_P (insn) = 1;
+    }
+}
+
+
+/* Create and emit instructions for a functions prologue */
+void
+lm32_expand_prologue (void)
+{
+  rtx insn;
+    
+  lm32_compute_frame_size (get_frame_size ());
+        
+  if (current_frame_info.total_size > 0)
+    {
+      /* Add space on stack new frame  */
+      stack_adjust (-current_frame_info.total_size);
+                                
+      /* Save callee save registers */
+      if (current_frame_info.reg_save_mask != 0)
+        expand_save_restore (&current_frame_info, 0);
+        
+      /* Setup frame pointer if it's needed */                
+      if (frame_pointer_needed == 1)
+        {
+          /* Load offset - Don't use total_size, as that includes pretend_size, which isn't part of this frame? */
+          insn = emit_move_insn (frame_pointer_rtx, GEN_INT (  current_frame_info.args_size 
+                                                             + current_frame_info.callee_size 
+                                                             + current_frame_info.locals_size));
+          RTX_FRAME_RELATED_P (insn) = 1;
+          
+          /* Add in sp */
+          insn = emit_add (frame_pointer_rtx, 
+                           frame_pointer_rtx,
+                           stack_pointer_rtx);
+          RTX_FRAME_RELATED_P (insn) = 1;
+        }  
+                
+      /* Prevent prologue from being scheduled into function body */
+      emit_insn (gen_blockage ());        
+    }
+}
+
+/* Create an emit instructions for a functions epilogue */
+void
+lm32_expand_epilogue (void)
+{
+  rtx ra_rtx = gen_rtx_REG (Pmode, RA_REGNUM);
+    
+  lm32_compute_frame_size (get_frame_size ());
+
+  if (current_frame_info.total_size > 0)
+    {       
+      /* Prevent stack code from being reordered */
+      emit_insn (gen_blockage ());             
+           
+      /* Restore callee save registers */
+      if (current_frame_info.reg_save_mask != 0)
+        expand_save_restore (&current_frame_info, 1);         
+      
+      /* Deallocate stack */
+      stack_adjust (current_frame_info.total_size);
+
+      /* Return to calling function */
+      emit_jump_insn (gen_return_internalsi (ra_rtx));                    
+    }
+  else
+    {
+      /* Return to calling function */
+      emit_jump_insn (gen_return_internalsi (ra_rtx));
+    }    
+}
+
+/* Return the bytes needed to compute the frame pointer from the current
+   stack pointer. */
+unsigned int
+lm32_compute_frame_size (int size)
+{
+  int regno;
+  unsigned int total_size, locals_size, args_size, pretend_size, callee_size;
+  unsigned int reg_save_mask;
+
+  locals_size = size;
+  args_size = current_function_outgoing_args_size;
+  pretend_size = current_function_pretend_args_size;
+  callee_size = 0;
+  reg_save_mask = 0;
+    
+  /* Build mask that actually determines which regsiters we save
+     and calculate size required to store them in the stack. */
+  for (regno = 1; regno < SP_REGNUM; regno++)
+    {
+      if (regs_ever_live[regno] && !call_used_regs[regno])
+        {
+          reg_save_mask |= 1 << regno;
+          callee_size += UNITS_PER_WORD;
+        }
+    }
+  if (regs_ever_live[RA_REGNUM] || !current_function_is_leaf || !optimize)
+    {
+      reg_save_mask |= 1 << RA_REGNUM;       
+      callee_size += UNITS_PER_WORD;
+    }
+  if (!(reg_save_mask & (1 << FP_REGNUM)) && frame_pointer_needed)
+    {
+      reg_save_mask |= 1 << FP_REGNUM;       
+      callee_size += UNITS_PER_WORD;
+    }
+
+  /* Compute total frame size */
+  total_size = pretend_size + args_size + locals_size + callee_size;
+     
+  /* Align frame to appropriate boundary */
+  total_size = (total_size+3) & ~3;
+  
+  /* Save computed information.  */
+  current_frame_info.total_size = total_size;
+  current_frame_info.callee_size = callee_size;
+  current_frame_info.pretend_size = pretend_size;
+  current_frame_info.locals_size = locals_size;
+  current_frame_info.args_size = args_size;
+  current_frame_info.reg_save_mask = reg_save_mask;
+
+/*  printf ("total %d\ncallee %d\npretend %d\nlocals %d\nargs %d\n\nreg_save_mask %x\n", 
+    total_size, callee_size, pretend_size, locals_size, args_size, reg_save_mask);*/
+
+  return total_size;
+}
+
+void
+lm32_print_operand (FILE *file, rtx op, int letter)
+{
+  register enum rtx_code code;
+
+  if (! op)
+    {
+      error ("PRINT_OPERAND null pointer");
+      abort ();
+    }
+
+  code = GET_CODE (op);
+
+  if (code == SIGN_EXTEND)
+    op = XEXP (op, 0), code = GET_CODE (op);
+  else if (code == REG || code == SUBREG)
+    {
+      int regnum;
+
+      if (code == REG)
+        regnum = REGNO (op);
+      else
+        regnum = true_regnum (op);
+
+     if (   (letter == 'H' && !WORDS_BIG_ENDIAN) 
+         || (letter == 'L' && WORDS_BIG_ENDIAN))
+         {
+         abort();
+            regnum++;
+            }
+
+      fprintf (file, "%s", reg_names[regnum]);
+    }
+  else if (code == MEM) 
+      output_address (XEXP (op, 0));
+  else if (letter == 'z' && GET_CODE (op) == CONST_INT && INTVAL (op) == 0)
+    fprintf (file, "%s", reg_names[0]);
+  else if (GET_CODE (op) == CONST_DOUBLE) 
+    {
+      if ((CONST_DOUBLE_LOW (op) != 0) || (CONST_DOUBLE_HIGH (op) != 0))
+        output_operand_lossage ("Only 0.0 can be loaded as an immediate");
+      else
+        fprintf (file, "0");
+    }        
+  else if (code == EQ)
+    fprintf (file, "e  ");  
+  else if (code == NE)
+    fprintf (file, "ne ");        
+  else if (code == GT)
+    fprintf (file, "g  ");    
+  else if (code == GTU)
+    fprintf (file, "gu ");    
+  else if (code == LT)
+    fprintf (file, "l  ");        
+  else if (code == LTU)
+    fprintf (file, "lu ");        
+  else if (code == GE)
+    fprintf (file, "ge ");        
+  else if (code == GEU)
+    fprintf (file, "geu");        
+  else if (code == LE)
+    fprintf (file, "le ");        
+  else if (code == LEU)
+    fprintf (file, "leu");                  
+  else
+    output_addr_const (file, op);
+}
+
+/* A C compound statement to output to stdio stream STREAM the
+   assembler syntax for an instruction operand that is a memory
+   reference whose address is ADDR.  ADDR is an RTL expression.
+
+   On some machines, the syntax for a symbolic address depends on
+   the section that the address refers to.  On these machines,
+   define the macro `ENCODE_SECTION_INFO' to store the information
+   into the `symbol_ref', and then check for it here.  */
+
+void
+lm32_print_operand_address (FILE *file, rtx addr)
+{
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      fprintf (file, "(%s+0)", reg_names [REGNO (addr)]);
+      break;
+
+    case MEM:
+      output_address (XEXP (addr, 0));
+      break;
+
+    case PLUS:
+      {
+        rtx arg0 = XEXP (addr, 0);
+        rtx arg1 = XEXP (addr, 1);
+              
+        if (GET_CODE (arg0) == REG && CONSTANT_P (arg1))
+          {
+            if (GET_CODE(arg1) == CONST_INT)
+              fprintf (file, "(%s+%ld)", reg_names [REGNO (arg0)], INTVAL (arg1));
+            else
+              {
+                fprintf (file, "(%s+", reg_names [REGNO (arg0)]);
+                output_addr_const (file, arg1);
+                fprintf (file, ")");
+              }
+          }
+        else if (CONSTANT_P (arg0) && CONSTANT_P (arg1))
+          output_addr_const (file, addr);
+        else
+          abort_with_insn (addr, "bad operand");
+      }
+      break;
+    
+    case SYMBOL_REF:
+      if (SYMBOL_REF_SMALL_P (addr)) 
+        {        
+          fprintf (file, "gp(");
+          output_addr_const (file, addr);
+          fprintf (file, ")");
+        } 
+      else
+        abort_with_insn (addr, "can't use non gp relative absolute address");
+      break;      
+        
+    default:
+      abort_with_insn (addr, "invalid addressing mode");
+      break;
+    }
+}
+
+/* Determine where to put an argument to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+    (otherwise it is an extra parameter matching an ellipsis).  */
+
+rtx
+lm32_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, 
+                   tree type, int named)
+{        
+  if (mode == VOIDmode)
+    /* Compute operand 2 of the call insn.  */
+    return GEN_INT (0);
+
+  if (targetm.calls.must_pass_in_stack (mode, type))
+    return NULL_RTX;
+    
+  if (!named  || (cum + LM32_NUM_REGS2(mode, type) > LM32_NUM_ARG_REGS))
+    return NULL_RTX;
+
+  return gen_rtx_REG (mode, cum + LM32_FIRST_ARG_REG);
+}
+
+unsigned int
+lm32_compute_initial_elimination_offset (unsigned int from, unsigned int to)
+{
+  int offset = 0;
+  
+  switch (from)
+    {
+    /*case FRAME_POINTER_REGNUM: - Same as ARG_POINTER_REGNUM */
+    case ARG_POINTER_REGNUM:
+      switch (to)
+        {
+        case FRAME_POINTER_REGNUM:
+          offset = 0;
+          break;
+        case STACK_POINTER_REGNUM:
+          offset = lm32_compute_frame_size (get_frame_size ()) - current_frame_info.pretend_size;
+          break;
+        default:
+          abort ();
+        }
+      break;
+    default:
+      abort ();
+    }
+    
+  return offset;    
+}
+
+static void
+lm32_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode, 
+                             tree type, int *pretend_size, int no_rtl)
+{
+  int first_anon_arg;
+  tree fntype;
+  int stdarg_p;
+  
+  fntype = TREE_TYPE (current_function_decl);
+  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0
+	      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))
+		  != void_type_node));
+   
+  if (stdarg_p)
+    first_anon_arg = *cum + LM32_FIRST_ARG_REG;
+  else
+    {
+      /* this is the common case, we have been passed details setup
+         for the last named argument, we want to skip over the
+         registers, if any used in passing this named paramter in
+         order to determine which is the first registers used to pass
+         anonymous arguments */
+      int size;
+
+      if (mode==BLKmode)
+        size = int_size_in_bytes (type);
+      else
+        size = GET_MODE_SIZE (mode);
+      
+      first_anon_arg = *cum + LM32_FIRST_ARG_REG + ((size + UNITS_PER_WORD - 1) / UNITS_PER_WORD);
+    }
+
+  if ((first_anon_arg < (LM32_FIRST_ARG_REG + LM32_NUM_ARG_REGS)) && !no_rtl)
+    {
+      int first_reg_offset = first_anon_arg;
+      int size = LM32_FIRST_ARG_REG + LM32_NUM_ARG_REGS - first_anon_arg;
+      rtx regblock;
+
+      regblock = gen_rtx_MEM (BLKmode,
+                              plus_constant (arg_pointer_rtx, 
+                                             FIRST_PARM_OFFSET (0)));
+      move_block_from_reg (first_reg_offset, regblock, size);
+
+      *pretend_size = size * UNITS_PER_WORD;
+    }
+}
+
+/* Abort after printing out a specific insn.  */
+static void
+abort_with_insn (rtx insn, const char *reason)
+{
+  error (reason);
+  debug_rtx (insn);
+  abort ();
+}
+
+/* Override command line options */
+void 
+lm32_override_options (void)
+{          
+  /* We must have sign-extend enabled if barrel-shift isn't */
+  if (!MASK_BARREL_SHIFT_ENABLED)
+    {
+      warning (0, "neither -mbarrel-shift-enabled nor -msign-extend-enabled specified. Assuming -msign-extend-enabled");
+      target_flags |= MASK_SIGN_EXTEND_ENABLED;
+    }
+}
+
+/* Return nonzero if this function is known to have a null epilogue.
+   This allows the optimizer to omit jumps to jumps if no stack
+   was created.  */
+int 
+lm32_can_use_return (void)
+{
+  if (!reload_completed) 
+    return 0;
+  
+  if (regs_ever_live[RA_REGNUM] || current_function_profile)
+    return 0;
+    
+  if (lm32_compute_frame_size (get_frame_size ()) != 0)
+    return 0;
+    
+  return 1;
+}
+
+/* Support function to determine the return address of the function
+   'count' frames back up the stack. */
+rtx 
+lm32_return_addr_rtx (int count, rtx frame)
+{
+  rtx r;
+  if (count == 0)
+    {
+      /* *mjs* This test originally used leaf_function_p (), we now use
+	 the regs_ever_live test which I *think* is more accurate. */
+      if (!regs_ever_live[RA_REGNUM])
+	{
+	  r = gen_rtx_REG (Pmode, RA_REGNUM);
+	}
+      else
+	{
+	  r = gen_rtx_MEM (Pmode, 
+			   gen_rtx_PLUS (Pmode, frame,
+					 GEN_INT(- 2 * UNITS_PER_WORD)));
+	  set_mem_alias_set (r, get_frame_alias_set ());
+	}
+    }
+  else if (flag_omit_frame_pointer)
+    r = NULL_RTX;
+  else
+    {
+      r = gen_rtx_MEM (Pmode, 
+		       gen_rtx_PLUS (Pmode, frame,
+				     GEN_INT(- 2 * UNITS_PER_WORD)));
+      set_mem_alias_set (r, get_frame_alias_set ());
+    }
+  return r;
+}
+
+/* Return true if EXP should be placed in the small data section.  */
+
+static bool
+lm32_in_small_data_p (tree exp)
+{
+  /* We want to merge strings, so we never consider them small data.  */
+  if (TREE_CODE (exp) == STRING_CST)
+    return false;
+
+  /* Functions are never in the small data area.  Duh.  */
+  if (TREE_CODE (exp) == FUNCTION_DECL)
+    return false;
+
+  if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))
+    {
+      const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));
+      if (strcmp (section, ".sdata") == 0
+	  || strcmp (section, ".sbss") == 0)
+	return true;
+    }
+  else
+    {
+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
+
+      /* If this is an incomplete type with size 0, then we can't put it
+	 in sdata because it might be too big when completed.  */
+      if (size > 0 && (unsigned HOST_WIDE_INT) size <= g_switch_value)
+	return true;
+    }
+
+  return false;
+}
+
+/* Emit straight-line code to move LENGTH bytes from SRC to DEST.
+   Assume that the areas do not overlap.  */
+
+static void
+lm32_block_move_inline (rtx dest, rtx src, HOST_WIDE_INT length, HOST_WIDE_INT alignment)
+{
+  HOST_WIDE_INT offset, delta;
+  unsigned HOST_WIDE_INT bits;
+  int i;
+  enum machine_mode mode;
+  rtx *regs;
+
+  /* Work out how many bits to move at a time.  */
+  switch (alignment)
+    {
+      case 1:
+        bits = 8;
+        break;
+      case 2:
+        bits = 16;
+        break;
+      case 4:
+        bits = 32;
+        break;
+    }
+
+  mode = mode_for_size (bits, MODE_INT, 0);
+  delta = bits / BITS_PER_UNIT;
+
+  /* Allocate a buffer for the temporary registers.  */
+  regs = alloca (sizeof (rtx) * length / delta);
+
+  /* Load as many BITS-sized chunks as possible.  */
+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)
+    {
+      regs[i] = gen_reg_rtx (mode);
+      emit_move_insn (regs[i], adjust_address (src, mode, offset));
+    }
+
+  /* Copy the chunks to the destination.  */
+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)
+    emit_move_insn (adjust_address (dest, mode, offset), regs[i]);
+
+  /* Mop up any left-over bytes.  */
+  if (offset < length)
+    {
+      src = adjust_address (src, BLKmode, offset);
+      dest = adjust_address (dest, BLKmode, offset);
+      move_by_pieces (dest, src, length - offset,
+		      MIN (MEM_ALIGN (src), MEM_ALIGN (dest)), 0);
+    }
+}
+
+/* Expand string/block move operations.
+
+   operands[0] is the pointer to the destination.
+   operands[1] is the pointer to the source.
+   operands[2] is the number of bytes to move.
+   operands[3] is the alignment.  */
+
+int
+lm32_expand_block_move (rtx *operands)
+{
+  if ((GET_CODE (operands[2]) == CONST_INT) && (INTVAL (operands[2]) <= 32))
+    {
+      lm32_block_move_inline (operands[0], operands[1], INTVAL (operands[2]), INTVAL (operands[3]));
+      return 1;
+    }
+  return 0;
+}
+
+/* Return TRUE if X references a SYMBOL_REF or LABEL_REF whose symbol
+   isn't protected by a PIC unspec.  */
+int
+nonpic_symbol_mentioned_p (rtx x)
+{
+  register const char *fmt;
+  register int i;
+
+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF
+      || GET_CODE (x) == PC)
+    return 1;
+
+  /* We don't want to look into the possible MEM location of a
+     CONST_DOUBLE, since we're not going to use it, in general.  */
+  if (GET_CODE (x) == CONST_DOUBLE)
+    return 0;
+
+  if (GET_CODE (x) == UNSPEC)
+    return 0;
+
+  fmt = GET_RTX_FORMAT (GET_CODE (x));
+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'E')
+	{
+	  register int j;
+
+	  for (j = XVECLEN (x, i) - 1; j >= 0; j--)
+	    if (nonpic_symbol_mentioned_p (XVECEXP (x, i, j)))
+	      return 1;
+	}
+      else if (fmt[i] == 'e' && nonpic_symbol_mentioned_p (XEXP (x, i)))
+	return 1;
+    }
+
+  return 0;
+}
+
+rtx lm32_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)
+{
+  rtx pic_ref;
+
+  if (GET_CODE (orig) == SYMBOL_REF || GET_CODE (orig) == LABEL_REF)
+    {
+      gcc_assert (reg);
+      pic_ref = gen_rtx_MEM (Pmode,
+			     gen_rtx_PLUS (Pmode,
+					   pic_offset_table_rtx, orig));
+      current_function_uses_pic_offset_table = 1;
+      MEM_READONLY_P (pic_ref) = 1;
+      emit_move_insn (reg, pic_ref);
+      return reg;    
+    }
+  return orig;
+}
diff --git a/gcc/config/lm32/lm32.h b/gcc/config/lm32/lm32.h
new file mode 100644
index 0000000..6ca1f8f
--- /dev/null
+++ b/gcc/config/lm32/lm32.h
@@ -0,0 +1,1208 @@
+/* Definitions of target machine for GNU compiler, LatticeMico32 archicture.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/*-------------------------------*/
+/* Run-time Target Specification */
+/*-------------------------------*/
+
+/* Print subsidiary information on the compiler version in use.  */
+#ifndef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (LatticeMico32)")
+#endif
+
+/* Target CPU builtins.  */
+#define TARGET_CPU_CPP_BUILTINS()               \
+  do                                            \
+    {                                           \
+      builtin_define ("__lm32__");              \
+      builtin_define_std ("lm32");              \
+      builtin_assert ("cpu=lm32");              \
+      builtin_assert ("machine=lm32");          \
+    }                                           \
+  while (0)
+
+#define CPP_SPEC "\
+%{mmultiply-enabled:-D__multiply_enabled__} \
+%{mdivide-enabled:-D__divide_enabled__} \
+%{mbarrel-shift-enabled:-D__barrel_shift_enabled__} \
+%{msign-extend-enabled:-D__sign_extend_enabled__} \
+%{muser-enabled:-D__user_enabled__} \
+"
+
+#undef  ASM_SPEC
+#define ASM_SPEC "\
+%{mmultiply-enabled} \
+%{mdivide-enabled} \
+%{mbarrel-shift-enabled} \
+%{msign-extend-enabled} \
+%{v} \
+"
+
+/* Let link script define all link options. Default to RAM based model. */
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC ""
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC ""
+#undef  LIB_SPEC
+#define LIB_SPEC "%{!T*:-T ram.ld}"
+
+#define OVERRIDE_OPTIONS lm32_override_options()
+
+extern int target_flags;
+
+/* Add -G xx support.  */
+
+#undef  SWITCH_TAKES_ARG
+#define SWITCH_TAKES_ARG(CHAR) \
+(DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')
+
+#undef  CC1_SPEC
+#define CC1_SPEC "%{G*}"
+
+extern struct rtx_def *lm32_compare_op0;
+extern struct rtx_def *lm32_compare_op1;
+
+/*---------------------------------*/
+/* Target machine storage layout.  */
+/*---------------------------------*/
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields.  */
+#define BITS_BIG_ENDIAN 0
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 1
+
+/* Define this if most significant word of a multiword number is the lowest
+   numbered.  */
+#define WORDS_BIG_ENDIAN 1
+
+/* Define this to set the endianness to use in libgcc2.c */
+#define LIBGCC2_WORDS_BIG_ENDIAN 1
+
+/* Number of bits in an addressable storage unit.  */
+#define BITS_PER_UNIT 8
+
+/* Width in bits of a "word", which is the contents of a machine register.
+   Note that this is not necessarily the width of data type `int';
+   if using 16-bit ints on a 68000, this would still be 32.
+   But on a machine with 16-bit registers, this would be 16.  */
+#define BITS_PER_WORD 32
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD 4
+
+/* Width in bits of a pointer.
+   See also the macro `Pmode' defined below.  */
+#define POINTER_SIZE 32
+
+/* A macro to update M and UNSIGNEDP when an object whose type is
+   TYPE and which has the specified mode and signedness is to be
+   stored in a register.  This macro is only called when TYPE is a
+   scalar type. */
+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
+do {                                                    \
+  if (GET_MODE_CLASS (MODE) == MODE_INT                 \
+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)         \
+    (MODE) = word_mode;                                 \
+} while (0)
+
+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
+#define PARM_BOUNDARY 32
+
+/* Boundary (in *bits*) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY 32
+
+/* No data type wants to be aligned rounder than this. */
+#define BIGGEST_ALIGNMENT 64
+
+/* Allocation boundary (in *bits*) for the code of a function.  */
+#define FUNCTION_BOUNDARY  32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY 32
+
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 1
+
+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT
+
+/* If bit field type is int, don't let it cross an int,
+   and give entire struct the alignment of an int.  */
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+/* Make strings word-aligned so strcpy from constants will be faster.  */
+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \
+  (TREE_CODE (EXP) == STRING_CST	\
+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))
+
+/* Make arrays of chars word-aligned for the same reasons.  */
+#define DATA_ALIGNMENT(TYPE, ALIGN)		\
+  (TREE_CODE (TYPE) == ARRAY_TYPE		\
+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode	\
+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))
+   
+/*----------------------------------------*/
+/* Layout of source language data types.  */
+/*----------------------------------------*/
+
+/*   A C expression for the size in bits of the type `int' on the
+     target machine.  If you don't define this, the default is one word. */
+#define INT_TYPE_SIZE		    32
+
+/*   A C expression for the size in bits of the type `short' on the
+     target machine.  If you don't define this, the default is half a
+     word.  (If this would be less than one storage unit, it is rounded
+     up to one unit.) */
+#define SHORT_TYPE_SIZE		    16
+
+/*   A C expression for the size in bits of the type `long' on the
+     target machine.  If you don't define this, the default is one word. */
+#define LONG_TYPE_SIZE		    32
+
+/*   A C expression for the size in bits of the type `long long' on the
+     target machine.  If you don't define this, the default is two
+     words.  If you want to support GNU Ada on your machine, the value
+     of macro must be at least 64. */
+#define LONG_LONG_TYPE_SIZE	    64
+
+/*   A C expression for the size in bits of the type `float' on the
+     target machine.  If you don't define this, the default is one word. */
+#define FLOAT_TYPE_SIZE		    32
+
+/*   A C expression for the size in bits of the type `double' on the
+     target machine.  If you don't define this, the default is two
+     words. */
+#define DOUBLE_TYPE_SIZE	    64
+
+/*   A C expression for the size in bits of the type `long double' on
+     the target machine.  If you don't define this, the default is two
+     words. */
+#define LONG_DOUBLE_TYPE_SIZE   64
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR     0
+
+/*   A C expression for a string describing the name of the data type
+     to use for size values.  The typedef name `size_t' is defined
+     using the contents of the string. */
+#define SIZE_TYPE "unsigned int"
+
+/*   A C expression for a string describing the name of the data type
+     to use for the result of subtracting two pointers.  The typedef
+     name `ptrdiff_t' is defined using the contents of the string.  See
+     `SIZE_TYPE' above for more information.
+
+     If you don't define this macro, the default is `"long int"'. */
+#define PTRDIFF_TYPE "int"
+
+/*---------------------------*/
+/* Standard register usage.  */
+/*---------------------------*/
+
+/* Number of actual hardware registers.
+   The hardware registers are assigned numbers for the compiler
+   from 0 to just below FIRST_PSEUDO_REGISTER.
+   All registers that the compiler knows about must be given numbers,
+   even those that are not normally considered general registers.  
+   If this is changed, you should also update glibc/sysdeps/lm32/gccframe.h */
+#define FIRST_PSEUDO_REGISTER  32
+
+#define RV_REGNUM   1
+#define GP_REGNUM   26
+#define FP_REGNUM   27
+#define SP_REGNUM   28
+#define RA_REGNUM   29
+
+#define G_REG_P(X)      ((X)<32)
+#define PSEUDO_REG_P(X) ((X)>=FIRST_PSEUDO_REGISTER)
+
+/* An initializer that says which registers are used for fixed
+   purposes all throughout the compiled code and are therefore not
+   available for general allocation.  These would include the stack
+   pointer, the frame pointer (except on machines where that can be
+   used as a general register when no frame pointer is needed), the
+   program counter on machines where that is considered one of the
+   addressable registers, and any other numbered register with a
+   standard use.
+    
+   This information is expressed as a sequence of numbers, separated
+   by commas and surrounded by braces.  The Nth number is 1 if
+   register N is fixed, 0 otherwise.
+    
+   The table initialized from this macro, and the table initialized by
+   the following one, may be overridden at run time either
+   automatically, by the actions of the macro
+   `CONDITIONAL_REGISTER_USAGE', or by the user with the command
+   options `-ffixed-REG', `-fcall-used-REG' and `-fcall-saved-REG'. */
+#define FIXED_REGISTERS   \
+{ 1, 0, 0, 0, 0, 0, 0, 0, \
+  0, 0, 0, 0, 0, 0, 0, 0, \
+  0, 0, 0, 0, 0, 0, 0, 0, \
+  0, 0, 1, 0, 1, 0, 1, 1}
+
+/* 1 for registers not available across function calls.
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you like. */
+/* Slightly confusing that ra is 0 here, but register renaming requires it
+   Its more useful to consider this as registers not saved by the prolog. */
+#define CALL_USED_REGISTERS \
+{ 1, 1, 1, 1, 1, 1, 1, 1,   \
+  1, 1, 1, 0, 0, 0, 0, 0,   \
+  0, 0, 0, 0, 0, 0, 0, 0,   \
+  0, 0, 1, 0, 1, 0, 1, 1}
+  
+/* Zero or more C statements that may conditionally modify two variables
+   `fixed_regs' and `call_used_regs' (both of type `char []') after they have
+   been initialized from the two preceding macros. */
+/*#define CONDITIONAL_REGISTER_USAGE {lm32_conditional_register_usage();}*/
+
+/* Return number of consecutive hard regs needed starting at reg REGNO
+   to hold something of mode MODE.
+   This is ordinarily the length in words of a value of mode MODE
+   but can be less for certain modes in special long registers. */
+#define HARD_REGNO_NREGS(REGNO, MODE)                                   \
+    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)      
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */
+#define HARD_REGNO_MODE_OK(REGNO, MODE) G_REG_P(REGNO)
+
+/* Tie QI/HI/SI modes together.  */
+#define MODES_TIEABLE_P(MODE1, MODE2)           \
+(      GET_MODE_CLASS (MODE1) == MODE_INT		\
+    && GET_MODE_CLASS (MODE2) == MODE_INT		\
+    && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD	\
+    && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)
+
+/*   Define this macro if the compiler should avoid copies to/from
+     `CCmode' registers.  You should only define this macro if support
+     for copying to/from `CCmode' is incomplete. */
+#define AVOID_CCMODE_COPIES
+
+/*----------------------------------*/
+/* Register classes and constants.  */
+/*----------------------------------*/
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.
+
+   It is important that any condition codes have class NO_REGS.
+   See `register_operand'.  */
+
+enum reg_class {
+  NO_REGS, 
+  GENERAL_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.  */
+#define REG_CLASS_NAMES { "NO_REGS", "GENERAL_REGS", "ALL_REGS" }
+
+/* Define which registers fit in which classes.
+   This is an initializer for a vector of HARD_REG_SET
+   of length N_REG_CLASSES.  */
+#define REG_CLASS_CONTENTS      \
+{ {0x00000000},                 \
+  {0xffffffff},                 \
+  {0xffffffff}                  \
+}
+
+/* The same information, inverted:
+   Return the class number of the smallest class containing
+   reg number REGNO.  This could be a conditional expression
+   or could index an array.  */
+#define REGNO_REG_CLASS(REGNO) \
+    (G_REG_P(REGNO) ? GENERAL_REGS : NO_REGS)
+    
+/* Return the maximum number of consecutive registers
+   needed to represent mode MODE in a register of class CLASS.  */
+#define CLASS_MAX_NREGS(CLASS, MODE) \
+    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)      
+    
+/*   A macro whose definition is the name of the class to which a valid
+     index register must belong.  An index register is one used in an
+     address where its value is either multiplied by a scale factor or
+     added to another register (as well as added to a displacement). */
+#define INDEX_REG_CLASS NO_REGS
+
+/*   A macro whose definition is the name of the class to which a valid
+     base register must belong.  A base register is one used in an
+     address which is the register value plus a displacement. */
+#define BASE_REG_CLASS GENERAL_REGS
+
+/*   A C expression which defines the machine-dependent operand
+     constraint letters for register classes.  If CHAR is such a
+     letter, the value should be the register class corresponding to
+     it.  Otherwise, the value should be `NO_REGS'.  The register
+     letter `r', corresponding to class `GENERAL_REGS', will not be
+     passed to this macro; you do not need to handle it. */
+#define REG_CLASS_FROM_LETTER(C) NO_REGS
+
+/*   A C expression which is nonzero if register number NUM is suitable
+     for use as a base register in operand addresses.  It may be either
+     a suitable hard register or a pseudo register that has been
+     allocated such a hard register. */
+#ifdef REG_OK_STRICT
+#define REGNO_OK_FOR_BASE_P(REGNO) 					\
+(G_REG_P (REGNO) || G_REG_P (reg_renumber[REGNO]))
+#else
+#define REGNO_OK_FOR_BASE_P(REGNO) 					\
+(G_REG_P (REGNO) || PSEUDO_REG_P (REGNO))
+#endif
+
+/*   A C expression which is nonzero if register number NUM is suitable
+     for use as an index register in operand addresses.  It may be
+     either a suitable hard register or a pseudo register that has been
+     allocated such a hard register.
+
+     The difference between an index register and a base register is
+     that the index register may be scaled.  If an address involves the
+     sum of two registers, neither one of them scaled, then either one
+     may be labeled the "base" and the other the "index"; but whichever
+     labeling is used must fit the machine's constraints of which
+     registers may serve in each capacity.  The compiler will try both
+     labelings, looking for one that is valid, and will reload one or
+     both registers only if neither labeling works. */
+#define REGNO_OK_FOR_INDEX_P(REGNO) 0
+
+/* Given an rtx X being reloaded into a reg required to be
+   in class CLASS, return the class of reg to actually use.
+   In general this is just CLASS; but on some machines
+   in some cases it is preferable to use a more restrictive class.  */
+#define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)
+
+/* The letters I, J, K, L, M, N, O, P in a register constraint string
+   can be used to stand for particular ranges of immediate operands.
+   This macro defines what the ranges are.
+   C is the letter, and VALUE is a constant value.
+   Return 1 if VALUE is in the range specified by C.  
+   
+   Lattice usage:
+   
+   J - 0
+   K - 16-bit signed
+   L - 16-bit unsigned
+   M - 32-bit signed 
+   */
+#define MEDIUM_INT(X)  (((X) >= -32768) && ((X) < 32768))
+#define MEDIUM_UINT(X) (((unsigned)(X)) < 65536)
+#define LARGE_INT(X)                                    \
+((X) >= (-(HOST_WIDE_INT) 0x7fffffff - 1)               \
+ && (X) <= (unsigned HOST_WIDE_INT) 0xffffffff)
+ 
+#define CONST_OK_FOR_LETTER_P(VALUE, C)                 \
+(  (C) == 'J' ? (VALUE) == 0                            \
+ : (C) == 'K' ? MEDIUM_INT (VALUE)                      \
+ : (C) == 'L' ? MEDIUM_UINT (VALUE)                     \
+ : (C) == 'M' ? LARGE_INT (VALUE)                       \
+ : 0                                                    \
+)
+
+/* Similar, but for floating constants, and defining letters G and H.
+   Here VALUE is the CONST_DOUBLE rtx itself.  */
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0
+
+/*----------------------------------------*/
+/* Stack Layout and Calling Conventions.  */
+/*----------------------------------------*/
+
+/* Define this macro if pushing a word onto the stack moves the stack
+   pointer to a smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Offset from the stack pointer register to the first location at
+   which outgoing arguments are placed.  If not specified, the
+   default value of zero is used.  This is the proper value for most
+   machines.
+
+   If `ARGS_GROW_DOWNWARD', this is the offset to the location above
+   the first location at which outgoing arguments are placed. */
+#define STACK_POINTER_OFFSET (UNITS_PER_WORD)
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated. */
+#define STARTING_FRAME_OFFSET (UNITS_PER_WORD)
+
+/* Offset of first parameter from the argument pointer register value.  */
+#define FIRST_PARM_OFFSET(FNDECL) (UNITS_PER_WORD)
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM SP_REGNUM
+
+/* Base register for access to local variables of the function.  */
+#define FRAME_POINTER_REGNUM FP_REGNUM
+
+/* Base register for access to arguments of the function.  */
+#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM
+
+/* A C expression which is nonzero if a function must have and use a
+   frame pointer.  This expression is evaluated in the reload pass.
+   If its value is nonzero the function will have a frame pointer.  */
+#define FRAME_POINTER_REQUIRED (current_function_calls_alloca) 
+
+/* A C expression whose value is RTL representing the value of the
+   return address for the frame COUNT steps up from the current
+   frame, after the prologue.  FRAMEADDR is the frame pointer of the
+   COUNT frame, or the frame pointer of the COUNT - 1 frame if
+   `RETURN_ADDR_IN_PREVIOUS_FRAME' is defined.
+
+   The value of the expression must always be the correct address when
+   COUNT is zero, but may be `NULL_RTX' if there is not way to
+   determine the return address of other frames. */
+#define RETURN_ADDR_RTX(count, frame)                               \
+  lm32_return_addr_rtx (count, frame)
+
+/* FIXME! */
+#define STATIC_CHAIN_REGNUM 3
+
+/* Definitions for register eliminations.
+
+   This is an array of structures.  Each structure initializes one pair
+   of eliminable registers.  The "from" register number is given first,
+   followed by "to".  Eliminations of the same "from" register are listed
+   in order of preference. */
+#define ELIMINABLE_REGS \
+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },        \
+ { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },          \
+}
+
+/* Given FROM and TO register numbers, say whether this elimination is
+   allowed.  Frame pointer elimination is automatically handled.
+
+   All eliminations are permissible.  Note that ARG_POINTER_REGNUM and
+   HARD_FRAME_POINTER_REGNUM are in fact the same thing.  If we need a frame
+   pointer, we must eliminate FRAME_POINTER_REGNUM into
+   HARD_FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM or
+   ARG_POINTER_REGNUM.  */
+#define CAN_ELIMINATE(FROM, TO)						    \
+   (((TO) == STACK_POINTER_REGNUM && frame_pointer_needed) ? 0 : 1)
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)    \
+  (OFFSET) = lm32_compute_initial_elimination_offset (FROM, TO)
+
+/*-----------------------------*/
+/* Function argument passing.  */
+/*-----------------------------*/
+
+/* If defined, the maximum amount of space required for outgoing
+   arguments will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue should
+   increase the stack frame size by this amount. 
+
+   Defining both `PUSH_ROUNDING' and `ACCUMULATE_OUTGOING_ARGS' is not
+   proper. */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* Value is the number of bytes of arguments automatically
+   popped when returning from a subroutine call.
+   FUNDECL is the declaration node of the function (as a tree),
+   FUNTYPE is the data type of the function (as a tree),
+   or for a library call it is an identifier node for the subroutine name.
+   SIZE is the number of bytes of arguments passed on the stack.  */
+#define RETURN_POPS_ARGS(DECL, FUNTYPE, SIZE) 0
+
+/*--------------------------------*/
+/* Passing Arguments in Registers */
+/*--------------------------------*/
+
+/* The first argument register */
+#define LM32_FIRST_ARG_REG 1
+
+/* The number of (integer) argument register available.  */
+#define LM32_NUM_ARG_REGS 8
+
+/* A C expression that controls whether a function argument is passed
+   in a register, and which register.
+
+   The arguments are CUM, which summarizes all the previous arguments;
+   MODE, the machine mode of the argument; TYPE, the data type of the
+   argument as a tree node or 0 if that is not known (which happens
+   for C support library functions); and NAMED, which is 1 for an
+   ordinary argument and 0 for nameless arguments that correspond to
+   `...' in the called function's prototype.
+
+   The value of the expression is usually either a `reg' RTX for the
+   hard register in which to pass the argument, or zero to pass the
+   argument on the stack.
+
+   For machines like the Vax and 68000, where normally all arguments
+   are pushed, zero suffices as a definition.
+
+   The value of the expression can also be a `parallel' RTX.  This is
+   used when an argument is passed in multiple locations.  The mode of
+   the of the `parallel' should be the mode of the entire argument.
+   The `parallel' holds any number of `expr_list' pairs; each one
+   describes where part of the argument is passed.  In each
+   `expr_list' the first operand must be a `reg' RTX for the hard
+   register in which to pass this part of the argument, and the mode
+   of the register RTX indicates how large this part of the argument
+   is.  The second operand of the `expr_list' is a `const_int' which
+   gives the offset in bytes into the entire argument of where this
+   part starts.  As a special exception the first `expr_list' in the
+   `parallel' RTX may have a first operand of zero.  This indicates
+   that the bytes starting from the second operand of that `expr_list'
+   are stored on the stack and not held in a register.
+
+   The usual way to make the ANSI library `stdarg.h' work on a machine
+   where some arguments are usually passed in registers, is to cause
+   nameless arguments to be passed on the stack instead.  This is done
+   by making `FUNCTION_ARG' return 0 whenever NAMED is 0.
+
+   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the
+   definition of this macro to determine if this argument is of a type
+   that must be passed in the stack.  If `REG_PARM_STACK_SPACE' is not
+   defined and `FUNCTION_ARG' returns non-zero for such an argument,
+   the compiler will abort.  If `REG_PARM_STACK_SPACE' is defined, the
+   argument will be computed in the stack and then loaded into a
+   register. */
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  lm32_function_arg ((CUM), (MODE), (TYPE), (NAMED))
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+#define CUMULATIVE_ARGS int
+
+/* A C statement (sans semicolon) for initializing the variable CUM
+   for the state at the beginning of the argument list.  The variable
+   has type `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node
+   for the data type of the function which will receive the args, or 0
+   if the args are to a compiler support library function.  The value
+   of INDIRECT is nonzero when processing an indirect call, for
+   example a call through a function pointer.  The value of INDIRECT
+   is zero for a call to an explicitly named function, a library
+   function call, or when `INIT_CUMULATIVE_ARGS' is used to find
+   arguments for the function being compiled.
+
+   When processing a call to a compiler support library function,
+   LIBNAME identifies which one.  It is a `symbol_ref' rtx which
+   contains the name of the function, as a string.  LIBNAME is 0 when
+   an ordinary C function call is being processed.  Thus, each time
+   this macro is called, either LIBNAME or FNTYPE is nonzero, but
+   never both of them at once. */
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT,N_NAMED_ARGS) \
+  (CUM) = 0
+
+/* A C statement (sans semicolon) to update the summarizer variable
+   CUM to advance past an argument in the argument list.  The values
+   MODE, TYPE and NAMED describe that argument.  Once this is done,
+   the variable CUM is suitable for analyzing the *following* argument
+   with `FUNCTION_ARG', etc.
+
+   This macro need not do anything if the argument in question was
+   passed on the stack.  The compiler knows how to track the amount of
+   stack space used for arguments without any special help. */
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+  (CUM) += LM32_NUM_REGS2 (MODE, TYPE)
+
+/* 1 if N is a possible register number for function argument passing.  */
+#define FUNCTION_ARG_REGNO_P(r)	(((r) >= 1) && ((r) <= LM32_NUM_ARG_REGS))
+
+/*--------------------*/
+/* Function results.  */
+/*--------------------*/
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its FUNCTION_DECL;
+   otherwise, FUNC is 0.  
+   As we define PROMOTE_FUNCTION_RETURN, we must implement that here. */
+#define FUNCTION_VALUE(VALTYPE, FUNC)                                   \
+   gen_rtx_REG ((INTEGRAL_TYPE_P (VALTYPE)                              \
+                 && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)           \
+	            ? word_mode                                             \
+	            : TYPE_MODE (VALTYPE),				                    \
+	            RV_REGNUM)
+
+/* Define how to find the value returned by a library function
+   assuming the value has mode MODE.  */
+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, RV_REGNUM)
+
+/* 1 if N is a possible register number for a function value
+   as seen by the caller.  */
+#define FUNCTION_VALUE_REGNO_P(N) ((N) == RV_REGNUM)
+
+/* A C expression which can inhibit the returning of certain function
+   values in registers, based on the type of value.  A nonzero value says
+   to return the function value in memory, just as large structures are
+   always returned.  Here TYPE will be a C expression of type `tree',
+   representing the data type of the value.  */
+#define RETURN_IN_MEMORY(TYPE) lm32_return_in_memory (TYPE)
+
+/*   Define this macro to be 1 if all structure and union return values
+     must be in memory.  Since this results in slower code, this should
+     be defined only if needed for compatibility with other compilers
+     or with an ABI.  If you define this macro to be 0, then the
+     conventions used for structure and union return values are decided
+     by the `RETURN_IN_MEMORY' macro.
+
+     If not defined, this defaults to the value 1. */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Convert fron bytes to ints.  */
+#define LM32_NUM_INTS(X) (((X) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* The number of (integer) registers required to hold a quantity of
+   type MODE.  */
+#define LM32_NUM_REGS(MODE) LM32_NUM_INTS (GET_MODE_SIZE (MODE))
+
+/* The number of (integer) registers required to hold a quantity of
+   TYPE MODE.  */
+#define LM32_NUM_REGS2(MODE, TYPE)                       \
+  LM32_NUM_INTS ((MODE) == BLKmode ?                     \
+  int_size_in_bytes (TYPE) : GET_MODE_SIZE (MODE))
+
+/*   If the structure value address is not passed in a register, define
+     `STRUCT_VALUE' as an expression returning an RTX for the place
+     where the address is passed.  If it returns 0, the address is
+     passed as an "invisible" first argument. */
+#define STRUCT_VALUE 0
+
+/*---------------------------*/
+/* Function entry and exit.  */
+/*---------------------------*/
+
+/*-------------*/
+/* Profiling.  */
+/*-------------*/
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+#define FUNCTION_PROFILER(FILE, LABELNO)
+
+/*---------------*/
+/* Trampolines.  */
+/*---------------*/
+
+#define INITIALIZE_TRAMPOLINE	
+#define TRAMPOLINE_SIZE		0
+
+/*---------------------*/ 
+/*  Addressing Modes.  */
+/*---------------------*/ 
+
+/* A C expression that is 1 if the RTX X is a constant which is a
+   valid address.  This is defined to be the same as 'CONSTANT_P (X)',
+   but rejecting CONST_DOUBLE.  */
+#define CONSTANT_ADDRESS_P(X)						\
+  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF		\
+    || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH		\
+    || (GET_CODE (X) == CONST)))
+
+/*   A number, the maximum number of registers that can appear in a
+     valid memory address.  Note that it is up to you to specify a
+     value equal to the maximum number that `GO_IF_LEGITIMATE_ADDRESS'
+     would ever accept. */
+#define MAX_REGS_PER_ADDRESS 1
+
+/* Nonzero if X is the hard frame-pointer register. This test no
+   longer allows a pseudo register which might later be replaced
+   with the frame pointer. 
+   (REGNO (X) >= FIRST_PSEUDO_REGISTER) */
+#ifdef REG_OK_STRICT
+#define REG_OK_FOR_FRAME_PTR_P(X) (REGNO (X) == FRAME_POINTER_REGNUM)
+#else
+#define REG_OK_FOR_FRAME_PTR_P(X) (REGNO (X) == FRAME_POINTER_REGNUM)
+#endif
+
+#define RTX_OK_FOR_BASE_P(X)                    (REG_P (X) && REG_OK_FOR_BASE_P (X))
+#define RTX_OK_FOR_STACK_P(X)                   (REG_P (X) && (REGNO (X) == STACK_POINTER_REGNUM))
+#define CONST_OK_FOR_BASE_OFFSET(X, MODE)       const_ok_for_base_offset ((X), (MODE))
+               
+#define LEGITIMATE_BASE_INDEX_P(ADDR, MODE)                     \
+(   GET_CODE (ADDR)==PLUS                                       \
+ && RTX_OK_FOR_BASE_P (XEXP (ADDR, 0))                          \
+ && GET_CODE (XEXP (ADDR, 1)) == CONST_INT                      \
+ && CONST_OK_FOR_BASE_OFFSET (XEXP ((ADDR), 1), (MODE)))        
+
+#define LEGITIMATE_GPREL_P(ADDR)                                \
+(   GET_CODE (ADDR) == SYMBOL_REF                               \
+ && SYMBOL_REF_SMALL_P (ADDR))
+ 
+/*   A C expression that is nonzero if X (assumed to be a `reg' RTX) is
+     valid for use as a base register.  For hard registers, it should
+     always accept those which the hardware permits and reject the
+     others.  Whether the macro accepts or rejects pseudo registers
+     must be controlled by `REG_OK_STRICT' as described above.  This
+     usually requires two variant definitions, of which `REG_OK_STRICT'
+     controls the one actually used. */
+#ifdef REG_OK_STRICT
+#define REG_OK_FOR_BASE_P(X) (G_REG_P (REGNO (X)))
+#else
+#define REG_OK_FOR_BASE_P(X) (G_REG_P (REGNO (X)) || PSEUDO_REG_P (REGNO (X)))
+#endif
+
+/*   A C expression that is nonzero if X (assumed to be a `reg' RTX) is
+     valid for use as an index register.
+
+     The difference between an index register and a base register is
+     that the index register may be scaled.  If an address involves the
+     sum of two registers, neither one of them scaled, then either one
+     may be labeled the "base" and the other the "index"; but whichever
+     labeling is used must fit the machine's constraints of which
+     registers may serve in each capacity.  The compiler will try both
+     labelings, looking for one that is valid, and will reload one or
+     both registers only if neither labeling works. */
+#ifdef REG_OK_STRICT
+#define REG_OK_FOR_INDEX_P(X) (G_REG_P (REGNO (X)))
+#else
+#define REG_OK_FOR_INDEX_P(X) (G_REG_P (REGNO (X)) || PSEUDO_REG_P (REGNO (X)))
+#endif
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression
+   that is a valid memory address for an instruction.
+   The MODE argument is the machine mode for the MEM expression
+   that wants to use this address. */
+#define GO_IF_LEGITIMATE_ADDRESS(m,x,l)	                                                                                             \
+{                                                                                                                                    \
+  if (RTX_OK_FOR_BASE_P (x)) goto l;                            /* (rM) */                                                      \
+  else if (LEGITIMATE_BASE_INDEX_P (x, m)) goto l;              /* (rM)+literal) */                                            \
+  else if (LEGITIMATE_GPREL_P (x)) goto l;                                                                                      \
+}
+
+/*   A C compound statement that attempts to replace X with a valid
+     memory address for an operand of mode MODE.  WIN will be a C
+     statement label elsewhere in the code; the macro definition may use
+
+          GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);
+
+     to avoid further processing if the address has become legitimate.
+
+     X will always be the result of a call to `break_out_memory_refs',
+     and OLDX will be the operand that was given to that function to
+     produce X.
+
+     The code generated by this macro should not alter the substructure
+     of X.  If it transforms X into a more legitimate form, it should
+     assign X (which will always be a C variable) a new value.
+
+     It is not necessary for this macro to come up with a legitimate
+     address.  The compiler has standard ways of doing so in all cases.
+     In fact, it is safe for this macro to do nothing.  But often a
+     machine-dependent strategy can generate better code. */
+#define ARM_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)	     \
+do {							     \
+  if (flag_pic)                                              \
+    X = lm32_legitimize_pic_address (OLDX, MODE, NULL_RTX);  \
+} while (0)
+
+/*   A C statement or compound statement with a conditional `goto
+     LABEL;' executed if memory address X (an RTX) can have different
+     meanings depending on the machine mode of the memory reference it
+     is used for or if the address is valid for some modes but not
+     others.
+
+     Autoincrement and autodecrement addresses typically have
+     mode-dependent effects because the amount of the increment or
+     decrement is the size of the operand being addressed.  Some
+     machines have other mode-dependent addresses.  Many RISC machines
+     have no mode-dependent addresses.
+
+     You may assume that ADDR is a valid address for the machine. */
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) 			\
+  if (GET_CODE (ADDR) == PLUS) goto LABEL;		      		\
+
+/*   A C expression that is nonzero if X is a legitimate constant for
+     an immediate operand on the target machine.  You can assume that X
+     satisfies `CONSTANT_P', so you need not check this.  In fact, `1'
+     is a suitable definition for this macro on machines where anything
+     `CONSTANT_P' is valid. */
+#define LEGITIMATE_CONSTANT_P(X) 1
+
+/*-------------------------*/
+/* Condition Code Status.  */
+/*-------------------------*/
+
+/* A C expression whose value is one if it is always safe to reverse a
+   comparison whose mode is MODE.  If `SELECT_CC_MODE' can ever return
+   MODE for a floating-point inequality comparison, then
+   `REVERSIBLE_CC_MODE (MODE)' must be zero. */
+#define REVERSIBLE_CC_MODE(MODE) 1
+
+/*---------*/
+/* Costs.  */
+/*---------*/
+
+/* Nonzero if access to memory by bytes is slow and undesirable.
+   For RISC chips, it means that access to memory by bytes is no
+   better than access by words when possible, so grab a whole word
+   and maybe make use of that.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Define this macro if it is as good or better to call a constant
+   function address than to call an address kept in a register.  */
+#define NO_FUNCTION_CSE
+
+/* Provide the cost of a branch.  */
+#define BRANCH_COST 4
+
+/*------------*/
+/* Sections.  */
+/*------------*/
+
+/* A set of symbol definitions for assembly pseudo-ops which will
+   get us switched to various sections of interest.  These are used
+   in all places where we simply want to switch to a section, and
+   *not* to push the previous section name onto the assembler's
+   section names stack (as we do often in dwarfout.c).  */
+#define TEXT_SECTION_ASM_OP             "\t.section\t.text"
+#define DATA_SECTION_ASM_OP             "\t.section\t.data"
+#define SDATA_SECTION_ASM_OP            "\t.section\t.sdata,\"aw\""
+#define READONLY_DATA_SECTION_ASM_OP    "\t.section\t.rodata"
+#define BSS_SECTION_ASM_OP              "\t.section\t.bss"
+#define SBSS_SECTION_ASM_OP             "\t.section\t.sbss,\"aw\""
+#define INIT_SECTION_ASM_OP             "\t.section\t.init"
+#define FINI_SECTION_ASM_OP             "\t.section\t.fini"
+
+/*-------*/
+/* PIC.  */
+/*-------*/
+
+/* The register number of the register used to address a table of
+   static data addresses in memory.  In some cases this register is
+   defined by a processor's "application binary interface" (ABI).
+   When this macro is defined, RTL is generated for this register
+   once, as with the stack pointer and frame pointer registers.  If
+   this macro is not defined, it is up to the machine-dependent
+   files to allocate such a register (if necessary).  */
+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? GP_REGNUM : INVALID_REGNUM)
+
+/* Indicate that jump tables go in the text section.  This is
+   necessary when compiling PIC code.  */
+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
+
+/* A C expression that is nonzero if X is a legitimate immediate
+   operand on the target machine when generating position independent code.
+   You can assume that X satisfies CONSTANT_P, so you need not
+   check this.  You can also assume `flag_pic' is true, so you need not
+   check it either.  You need not define this macro if all constants
+   (including SYMBOL_REF) can be immediate operands when generating
+   position independent code.  */
+/* We can't directly access anything that contains a symbol,
+   One exception is UNSPEC_TLS, which is always PIC.  */
+#define LEGITIMATE_PIC_OPERAND_P(X)                                    \
+	(!(nonpic_symbol_mentioned_p (X)))
+
+/*-------------*/
+/* Assembler.  */
+/*-------------*/
+
+/* A C string constant describing how to begin a comment in the target
+   assembler language.  The compiler assumes that the comment will
+   end at the end of the line.  */
+#define ASM_COMMENT_START "#"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+#define ASM_APP_ON "#APP\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* Output to assembler file a define */
+#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)				\
+ do {									\
+	fputc ( '\t', FILE);						\
+	assemble_name (FILE, LABEL1);					\
+	fputs ( " = ", FILE);						\
+	assemble_name (FILE, LABEL2);					\
+	fputc ( '\n', FILE);						\
+ } while (0)
+
+/* This says how to define a local common symbol (ie, not visible to
+   linker).  */
+#undef  ASM_OUTPUT_ALIGNED_LOCAL
+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
+do {									\
+  if ((SIZE) <= g_switch_value)						\
+    switch_to_section (sbss_section);					\
+  else									\
+    switch_to_section (bss_section);					\
+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");			\
+  if (!flag_inhibit_size_directive)					\
+    ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);			\
+  ASM_OUTPUT_ALIGN ((FILE), exact_log2((ALIGN) / BITS_PER_UNIT));	\
+  ASM_OUTPUT_LABEL(FILE, NAME);						\
+  ASM_OUTPUT_SKIP((FILE), (SIZE) ? (SIZE) : 1);				\
+} while (0)
+
+/* This says how to define a global common symbol.  */
+#undef  ASM_OUTPUT_ALIGNED_COMMON
+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)		\
+do 									\
+{									\
+  if ((SIZE) <= g_switch_value)						\
+    {									\
+      switch_to_section (sbss_section);					\
+      (*targetm.asm_out.globalize_label) (FILE, NAME);			\
+      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");			\
+      if (!flag_inhibit_size_directive)					\
+	ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);			\
+      ASM_OUTPUT_ALIGN ((FILE), exact_log2((ALIGN) / BITS_PER_UNIT));	\
+      ASM_OUTPUT_LABEL(FILE, NAME);					\
+      ASM_OUTPUT_SKIP((FILE), (SIZE) ? (SIZE) : 1);			\
+    }									\
+  else									\
+    {									\
+      switch_to_section (bss_section);					\
+      fprintf ((FILE), "%s", COMMON_ASM_OP);				\
+      assemble_name ((FILE), (NAME));					\
+      fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%u\n", (SIZE), (ALIGN) / BITS_PER_UNIT);	\
+    }									\
+}									\
+while (0)
+
+/* This is how to output the definition of a user-level label named NAME,
+   such as the label on a static function or variable NAME.  */
+#define ASM_OUTPUT_LABEL(FILE, NAME) \
+  do { assemble_name (FILE, NAME); fputs (":\n", FILE); } while (0)
+
+/* This is how to output a reference to a user-level label named NAME.
+   `assemble_name' uses this.  */
+#define ASM_OUTPUT_LABELREF(FILE,NAME)	\
+  do {					\
+    const char *xname = (NAME);		\
+    if (xname[0] == '@')		\
+      xname += 1;			\
+    if (xname[0] == '*')		\
+      xname += 1;			\
+    fputs (xname, FILE);		\
+  } while (0)
+
+#define ASM_OUTPUT_SYMBOL_REF(STREAM, SYMBOL)				\
+  do {									                    \
+    assemble_name (STREAM, XSTR (SYMBOL, 0));				\
+  } while (0)
+
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP "\t.global\t"
+
+/* This is how to output an assembler line to advance the location
+   counter by SIZE bytes.  */
+#undef ASM_OUTPUT_SKIP   
+#define ASM_OUTPUT_SKIP(STREAM,SIZE)					\
+  fprintf (STREAM, "\t.space\t%u\n", (SIZE))
+
+/* Store in OUTPUT a string (made with alloca) containing
+   an assembler-name for a local static variable named NAME.
+   LABELNO is an integer which is different for each call.  */
+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)			\
+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),			\
+  sprintf ((OUTPUT), "%s_%d", (NAME), (LABELNO)))
+
+/* How to refer to registers in assembler output.
+   This sequence is indexed by compiler's hard-register-number (see above).  */
+#define REGISTER_NAMES 					 \
+{                                                        \
+ "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",	 \
+ "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15", \
+ "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23", \
+ "r24", "r25",  "gp",  "fp",  "sp",  "ra",  "ea",  "ba"}
+
+/* A C expression which evaluates to true if CODE is a valid
+   punctuation character for use in the `PRINT_OPERAND' macro.  If
+   `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no
+   punctuation characters (except for the standard one, `%') are
+   used in this way.  */
+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \
+  (((CHAR) == '&') || ((CHAR) == '@') || ((CHAR) == '*'))
+
+/* Print operand X (an rtx) in assembler syntax to file FILE.
+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.
+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */
+#define PRINT_OPERAND(FILE, X, CODE)                    \
+  lm32_print_operand (FILE, X, CODE)
+
+/* A C compound statement to output to stdio stream STREAM the
+   assembler syntax for an instruction operand that is a memory
+   reference whose address is ADDR.  ADDR is an RTL expression.
+
+   On some machines, the syntax for a symbolic address depends on
+   the section that the address refers to.  On these machines,
+   define the macro `ENCODE_SECTION_INFO' to store the information
+   into the `symbol_ref', and then check for it here.  */
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) 				\
+  lm32_print_operand_address (FILE, ADDR)
+
+/* Local compiler-generated symbols must have a prefix that the assembler
+   understands.  */
+#ifndef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX	"."
+#endif
+
+/* By default external symbols are prefixed with the following character. */
+#ifndef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX	""
+#endif
+
+/* This is how to store into the string LABEL
+   the symbol_ref name of an internal numbered label where
+   PREFIX is the class of label and NUM is the number within the class.
+   This is suitable for output with `assemble_name'.  */
+#undef ASM_GENERATE_INTERNAL_LABEL   
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)			\
+  sprintf ((LABEL), "*%s%s%ld", (LOCAL_LABEL_PREFIX), (PREFIX), (long)(NUM))
+
+/* This is how to output an assembler line
+   that says to advance the location counter
+   to a multiple of 2**LOG bytes.  */
+#define ASM_OUTPUT_ALIGN(FILE,LOG) 					\
+  do { if ((LOG) != 0) fprintf (FILE, "\t.align %d\n", (1 << (LOG))); } while (0)
+
+/* This is how to output an element of a case-vector that is absolute.  */
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)                    \
+do {                                                            \
+  char label[64];                                               \
+  ASM_GENERATE_INTERNAL_LABEL (label, "L", VALUE);              \
+  fprintf (FILE, "\n\t.word\t");                                \
+  assemble_name (FILE, label);                                  \
+  fprintf (FILE, "\n");                                         \
+} while (0)
+
+/* This is how to output an element of a case-vector that is relative.  */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)        \
+do {                                                            \
+  char label[64];                                               \
+  fprintf (FILE, "\t.word\t(");                                 \
+  ASM_GENERATE_INTERNAL_LABEL (label, "L", VALUE);		\
+  assemble_name (FILE, label);                                  \
+  fprintf (FILE, "-");                                          \
+  ASM_GENERATE_INTERNAL_LABEL (label, "L", REL);                \
+  assemble_name (FILE, label);                                  \
+  fprintf (FILE, ")\n");                                        \
+} while (0)
+
+/*-------------*/
+/* Debugging.  */
+/*-------------*/
+
+/* A C expression that returns the type of debugging output GNU CC produces
+   when the user specifies `-g' or `-ggdb'.  Define this if you have arranged
+   for GNU CC to support more than one format of debugging output.  Currently,
+   the allowable values are `DBX_DEBUG', `SDB_DEBUG', `DWARF_DEBUG',
+   `DWARF2_DEBUG', and `XCOFF_DEBUG'.
+
+   The value of this macro only affects the default debugging output; the user
+   can always get a specific type of output by using `-gstabs', `-gcoff',
+   `-gdwarf-1', `-gdwarf-2', or `-gxcoff'.
+
+   Defined in svr4.h.  */
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+#define DBX_REGISTER_NUMBER(REGNO) (REGNO) 
+
+/* Define this macro if debugging can be performed even without a
+   frame pointer.  If this macro is defined, GNU CC will turn on the
+   `-fomit-frame-pointer' option whenever `-O' is specified.  */
+#define CAN_DEBUG_WITHOUT_FP
+     
+/* By default, turn on GDB extensions.  */
+#define DEFAULT_GDB_EXTENSIONS 1
+
+/*--------*/
+/* Misc.  */
+/*--------*/
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE Pmode
+
+/* Define if operations between registers always perform the operation
+   on the full register even if a narrower mode is specified.  */
+#define WORD_REGISTER_OPERATIONS
+
+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD
+   will either zero-extend or sign-extend.  The value of this macro should
+   be the code that says which one of the two operations is implicitly
+   done, NIL if none. */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+/* Define this macro if loading short immediate values into registers
+   sign extends. */
+#define SHORT_IMMEDIATES_SIGN_EXTEND
+
+/* Max number of bytes we can move from memory to memory
+   in one reasonably fast instruction.  */
+#define MOVE_MAX        UNITS_PER_WORD
+#define MAX_MOVE_MAX    4
+
+/* Define this to be nonzero if shift instructions ignore all but the low-order
+   few bits. */
+#define SHIFT_COUNT_TRUNCATED 1
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode SImode
+
+/* A function address in a call instruction.  */
+#define FUNCTION_MODE SImode
+
+/* Define this macro if the system header files support C++ as well
+   as C.  This macro inhibits the usual method of using system header
+   files in C++, which is to pretend that the file's contents are
+   enclosed in `extern "C" {...}'. */
+#ifndef NO_IMPLICIT_EXTERN_C
+#define NO_IMPLICIT_EXTERN_C 1
+#endif
+
+#define STORE_FLAG_VALUE 1
diff --git a/gcc/config/lm32/lm32.md b/gcc/config/lm32/lm32.md
new file mode 100644
index 0000000..f676e9a
--- /dev/null
+++ b/gcc/config/lm32/lm32.md
@@ -0,0 +1,1151 @@
+;; Machine description of the LatticeMico32 architecture for GNU C compiler
+;; Contributed by Jon Beniston <jon@beniston.com>
+
+;; This file is part of GNU CC.
+
+;; GNU CC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; GNU CC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU CC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+;; Include predicate definitions
+(include "predicates.md")
+
+;; Register numbers
+(define_constants
+  [(RA_REGNUM           29)		; return address register.
+  ]
+)
+
+;; LM32 specific volatile operations
+(define_constants
+  [(UNSPECV_BLOCKAGE    1)]     ; use to prevent scheduler from optimising accross bounaries
+)
+  
+;; --------------------------------- 
+;;      instruction types
+;; ---------------------------------
+
+(define_attr "type"
+  "unknown,load,store,arith,compare,shift,multiply,divide,call,icall,ubranch,uibranch,cbranch"
+  (const_string "unknown"))
+  
+;; ---------------------------------
+;;      instruction lengths
+;; ---------------------------------
+  
+; All instructions are 4 bytes
+; Except for branches that are out of range, and have to be implemented
+; as two instructions
+(define_attr "length" "" 
+        (cond [
+                (eq_attr "type" "cbranch")
+                (if_then_else
+                        (lt (abs (minus (match_dup 2) (pc)))
+                                (const_int 32768)
+                        )
+                        (const_int 4)
+                        (const_int 8)               
+                )
+              ] 
+        (const_int 4))
+)
+                    
+;; ---------------------------------
+;;           scheduling 
+;; ---------------------------------
+
+(define_automaton "lm32")
+
+(define_cpu_unit "x" "lm32")
+(define_cpu_unit "m" "lm32")
+(define_cpu_unit "w" "lm32")
+
+(define_insn_reservation "singlecycle" 1
+  (eq_attr "type" "store,arith,call,icall,ubranch,uibranch,cbranch")
+ "x")
+
+(define_insn_reservation "twocycle" 2
+  (eq_attr "type" "compare,shift,divide")
+ "x,m") 
+
+(define_insn_reservation "threecycle" 3
+  (eq_attr "type" "load,multiply")
+ "x,m,w")
+
+;; ---------------------------------
+;;               mov 
+;; ---------------------------------
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "general_operand" "")
+        (match_operand:QI 1 "general_operand" ""))]
+  ""
+  "
+{
+  if (!no_new_pseudos)
+    {
+      if (GET_CODE (operand0) == MEM)
+        {
+          /* Source operand for store must be in a register */
+          operands[1] = force_reg (QImode, operands[1]);
+        }
+    }
+  if (   GET_CODE (operands[1]) == CONST_INT 
+      && GET_CODE (operands[0]) == REG)
+    {
+      operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);
+      emit_insn (gen_movsi (operands[0], operands[1]));
+      DONE;
+    }
+}")
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "general_operand" "")
+        (match_operand:HI 1 "general_operand" ""))]
+  ""
+  "
+{
+  if (!no_new_pseudos)
+    {
+      if (GET_CODE (operands[0]) == MEM)
+        {
+          /* Source operand for store must be in a register */
+          operands[1] = force_reg (HImode, operands[1]);
+        }
+    }
+  if (GET_CODE (operands[1]) == CONST_INT)
+    {
+      operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);          
+      if (MEDIUM_INT (INTVAL (operands[1])))      
+        emit_insn (gen_movsi_kimm (operands[0], operands[1]));
+      else if (MEDIUM_UINT (INTVAL (operands[1])))   
+        emit_insn (gen_movsi_limm (operands[0], operands[1]));
+      else
+        {
+          emit_insn (gen_movsi_imm_hi (operands[0], GEN_INT (INTVAL (operands[1]))));
+          emit_insn (gen_movsi_imm_lo (operands[0], operands[0], GEN_INT (INTVAL (operands[1]))));
+        }
+      DONE;
+    }
+}")
+
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "general_operand" "")
+        (match_operand:SI 1 "general_operand" ""))]
+  ""
+  "
+{
+  if (!no_new_pseudos)
+    {
+      /* Note that in the absence of explict movsf patterns the move
+         emiting code will attempt to move SF values by subreg'ing
+	 both source and destination operands as SI values. Strictly no
+         subreg should enclose a MEM before the combiner, so this is
+         rather naughty. We circumvent problems created by having the
+         source of a move appear as a subreg(mem) by explictly
+         detecting this construct and forcing the source into a
+         register */
+	
+      if (GET_CODE (operands[0]) == MEM 
+	  || (GET_CODE (operands[0]) == SUBREG 
+	      && GET_CODE (SUBREG_REG (operands[0])) == MEM))
+        {
+          /* Source operand for store must be in a register */
+          operands[1] = force_reg (SImode, operands[1]);
+        }
+    }
+
+  if (flag_pic && symbolic_operand (operands[1], SImode)) 
+    {
+      /*
+      rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);
+      operands[1] = lm32_legitimize_pic_address (operands[1], SImode, temp);
+      */
+      emit_insn (gen_movsi_got (operands[0], operands[1]));
+      current_function_uses_pic_offset_table = 1;
+      DONE;
+    }
+  else if (flag_pic && GET_CODE (operands[1]) == CONST) 
+    {
+      rtx op = XEXP (operands[1], 0);
+      if (GET_CODE (op) == PLUS)
+        {
+          rtx arg0 = XEXP (op, 0);
+          rtx arg1 = XEXP (op, 1);
+          emit_insn (gen_movsi_got (operands[0], arg0));
+          emit_insn (gen_addsi3 (operands[0], operands[0], arg1));
+          current_function_uses_pic_offset_table = 1;
+          DONE;
+        }     
+    }
+  else if (!flag_pic && (   GET_CODE (operands[1]) == SYMBOL_REF
+                         && SYMBOL_REF_SMALL_P (operands[1])
+                        ) 
+          ) 
+    {
+      emit_insn (gen_movsi_reloc_gprel (operands[0], operands[1]));
+      DONE;
+    }
+  else if (!flag_pic && (   GET_CODE (operands[1]) == LABEL_REF
+                         || GET_CODE (operands[1]) == SYMBOL_REF
+                         || GET_CODE (operands[1]) == CONST                         
+                        )
+          )
+    {
+      emit_insn (gen_movsi_reloc_hi (operands[0], operands[1]));
+      emit_insn (gen_movsi_reloc_lo (operands[0], operands[0], operands[1]));
+      DONE;
+    }
+  else if (GET_CODE (operands[1]) == CONST_INT)
+    {
+      if (MEDIUM_INT (INTVAL (operands[1])))      
+        emit_insn (gen_movsi_kimm (operands[0], operands[1]));
+      else if (MEDIUM_UINT (INTVAL (operands[1])))   
+        emit_insn (gen_movsi_limm (operands[0], operands[1]));
+      else
+        {
+          emit_insn (gen_movsi_imm_hi (operands[0], GEN_INT (INTVAL (operands[1]))));
+          emit_insn (gen_movsi_imm_lo (operands[0], operands[0], GEN_INT (INTVAL (operands[1]))));
+        }
+      DONE;
+    }    
+}")
+
+(define_expand "movmemsi"
+  [(parallel [(set (match_operand:BLK 0 "general_operand" "")
+		   (match_operand:BLK 1 "general_operand" ""))
+	      (use (match_operand:SI 2 "" ""))
+	      (use (match_operand:SI 3 "const_int_operand" ""))])]
+  ""
+{
+  if (!lm32_expand_block_move (operands))
+    FAIL;
+  DONE;
+})
+
+;; ---------------------------------
+;;        load/stores/moves 
+;; ---------------------------------
+
+(define_insn "movsi_kimm"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (match_operand:SI 1 "constant_K_operand" "K"))]
+  ""
+  "addi     %0, r0, %1"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "movsi_limm"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (match_operand:SI 1 "constant_L_operand" "L"))]
+  ""
+  "ori      %0, r0, %1"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "movsi_imm_hi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (match_operand:SI 1 "immediate_operand" "i")))]
+  ""
+  "orhi     %0, r0, hi(%1)"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "movsi_imm_lo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (lo_sum:SI (match_operand:SI 1 "register_operand" "0")
+                   (match_operand:SI 2 "immediate_operand" "i")))]
+  ""
+  "ori      %0, %0, lo(%2)"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "movsi_reloc_gprel"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (match_operand:SI 1 "reloc_operand" "i"))]
+  "GET_CODE (operands[1]) == SYMBOL_REF && SYMBOL_REF_SMALL_P (operands[1])"
+  "mva      %0, gp(%1)"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "movsi_got"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (match_operand:SI 1 "symbolic_operand" "X"))]
+  "flag_pic"
+  "lw       %0, (gp+got(%1))"
+  [(set_attr "type" "load")]
+)
+  
+(define_insn "movsi_reloc_hi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (match_operand:SI 1 "reloc_operand" "i")))]
+  "!flag_pic"
+  "orhi     %0, r0, hi(%1)"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "movsi_reloc_lo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (lo_sum:SI (match_operand:SI 1 "register_operand" "0")
+                   (match_operand:SI 2 "reloc_operand" "i")))]
+  "!flag_pic"
+  "ori      %0, %0, lo(%2)"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "*movqi_insn"
+  [(set (match_operand:QI 0 "register_or_memory_operand" "=r,r,m")
+        (match_operand:QI 1 "register_or_memory_operand" "m,r,r"))]
+  ""
+  "@
+   lbu      %0, %1
+   or       %0, %1, r0
+   sb       %0, %1"
+  [(set_attr "type" "load,arith,store")]   
+)
+   
+(define_insn "*movhi_insn"
+  [(set (match_operand:HI 0 "register_or_memory_operand" "=r,r,m")
+        (match_operand:HI 1 "register_or_memory_operand" "m,r,r"))]
+  ""
+  "@
+   lhu      %0, %1
+   or       %0, %1, r0
+   sh       %0, %1"
+  [(set_attr "type" "load,arith,store")]   
+)
+
+(define_insn "*movsi_insn"
+  [(set (match_operand:SI 0 "register_or_memory_operand" "=r,r,m")
+        (match_operand:SI 1 "register_or_memory_operand" "m,r,r"))]
+  ""
+  "@
+   lw       %0, %1
+   or       %0, %1, r0
+   sw       %0, %1"
+  [(set_attr "type" "load,arith,store")]   
+)
+
+;; ---------------------------------
+;;      sign and zero extension 
+;; ---------------------------------
+
+(define_insn "*extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+        (sign_extend:HI (match_operand:QI 1 "register_or_memory_operand" "m,r")))]
+  "TARGET_SIGN_EXTEND_ENABLED || (GET_CODE (operands[1]) != REG)"
+  "@
+   lb       %0, %1
+   sextb    %0, %1"
+  [(set_attr "type" "load,arith")]
+)
+
+(define_insn "zero_extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+        (zero_extend:HI (match_operand:QI 1 "register_or_memory_operand" "m,r")))]
+  ""
+  "@
+   lbu      %0, %1
+   andi     %0, %1, 0xff"
+  [(set_attr "type" "load,arith")]  
+)
+
+(define_insn "*extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (sign_extend:SI (match_operand:QI 1 "register_or_memory_operand" "m,r")))]
+  "TARGET_SIGN_EXTEND_ENABLED || (GET_CODE (operands[1]) != REG)"
+  "@
+   lb       %0, %1
+   sextb    %0, %1"
+  [(set_attr "type" "load,arith")]
+)
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	    (zero_extend:SI (match_operand:QI 1 "register_or_memory_operand" "m,r")))]
+  ""
+  "@
+   lbu      %0, %1
+   andi     %0, %1, 0xff"
+  [(set_attr "type" "load,arith")]  
+)
+
+(define_insn "*extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (sign_extend:SI (match_operand:HI 1 "register_or_memory_operand" "m,r")))]
+  "TARGET_SIGN_EXTEND_ENABLED || (GET_CODE (operands[1]) != REG)"
+  "@
+   lh       %0, %1
+   sexth    %0, %1"
+  [(set_attr "type" "load,arith")]
+)
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (zero_extend:SI (match_operand:HI 1 "register_or_memory_operand" "m,r")))]
+  ""
+  "@
+   lhu      %0, %1
+   andi     %0, %1, 0xffff"
+  [(set_attr "type" "load,arith")]  
+)
+
+;; ---------------------------------
+;;             compare 
+;; ---------------------------------
+
+(define_expand "cmpsi"
+  [(set (cc0)
+   (compare:CC (match_operand:SI 0 "register_operand" "")
+               (match_operand:SI 1 "register_or_K_operand" "")))]
+  ""
+  "
+{
+  lm32_compare_op0 = operands[0];
+  lm32_compare_op1 = operands[1];
+  DONE;
+}")
+
+
+(define_expand "tstsi"
+  [(set (cc0)
+   (match_operand:SI 0 "register_operand" ""))]
+  ""
+  "
+{
+  lm32_compare_op0 = operands[0];
+  lm32_compare_op1 = const0_rtx;
+  DONE;
+}")
+
+(define_expand "seq"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(eq:SI (match_dup 1)
+	       (match_dup 2)))]
+  ""
+{
+  operands[1] = lm32_compare_op0;
+  operands[2] = lm32_compare_op1;
+  gen_int_relational (EQ, operands[0], operands[1], operands[2], NULL_RTX);
+  DONE;
+})
+
+(define_insn "*seq"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (eq:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+               (match_operand:SI 2 "register_or_K_operand" "r,K")))]
+  ""
+  "@
+   cmpe     %0, %z1, %2
+   cmpei    %0, %z1, %2"
+  [(set_attr "type" "compare")]
+)
+
+(define_expand "sne"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ne:SI (match_dup 1)
+	       (match_dup 2)))]
+  ""
+{
+  operands[1] = lm32_compare_op0;
+  operands[2] = lm32_compare_op1;
+  gen_int_relational (NE, operands[0], operands[1], operands[2], NULL_RTX);
+  DONE;
+})
+
+(define_insn "*sne"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ne:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+               (match_operand:SI 2 "register_or_K_operand" "r,K")))]
+  ""
+  "@
+   cmpne    %0, %z1, %2
+   cmpnei   %0, %z1, %2"
+  [(set_attr "type" "compare")]
+)
+
+(define_expand "sgt"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(gt:SI (match_dup 1)
+	       (match_dup 2)))]
+  ""
+{
+  operands[1] = lm32_compare_op0;
+  operands[2] = lm32_compare_op1;
+  gen_int_relational (GT, operands[0], operands[1], operands[2], NULL_RTX);
+  DONE;
+})
+
+(define_insn "*sgt"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (gt:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+               (match_operand:SI 2 "register_or_K_operand" "r,K")))]
+  ""
+  "@
+   cmpg     %0, %z1, %2
+   cmpgi    %0, %z1, %2"
+  [(set_attr "type" "compare")]
+)
+
+(define_expand "sge"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ge:SI (match_dup 1)
+	       (match_dup 2)))]
+  ""
+{
+  operands[1] = lm32_compare_op0;
+  operands[2] = lm32_compare_op1;
+  gen_int_relational (GE, operands[0], operands[1], operands[2], NULL_RTX);
+  DONE;
+})
+
+(define_insn "*sge"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ge:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+               (match_operand:SI 2 "register_or_K_operand" "r,K")))]
+  ""
+  "@
+   cmpge    %0, %z1, %2
+   cmpgei   %0, %z1, %2"
+  [(set_attr "type" "compare")]
+)
+
+(define_expand "sgtu"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(gtu:SI (match_dup 1)
+	        (match_dup 2)))]
+  ""
+{
+  operands[1] = lm32_compare_op0;
+  operands[2] = lm32_compare_op1;
+  gen_int_relational (GTU, operands[0], operands[1], operands[2], NULL_RTX);
+  DONE;
+})
+
+(define_insn "*sgtu"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (gtu:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                (match_operand:SI 2 "register_or_K_operand" "r,L")))]
+  ""
+  "@
+   cmpgu    %0, %z1, %2
+   cmpgui   %0, %z1, %2"
+  [(set_attr "type" "compare")]
+)
+
+(define_expand "sgeu"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(geu:SI (match_dup 1)
+	        (match_dup 2)))]
+  ""
+{
+  operands[1] = lm32_compare_op0;
+  operands[2] = lm32_compare_op1;
+  gen_int_relational (GEU, operands[0], operands[1], operands[2], NULL_RTX);
+  DONE;
+})
+
+(define_insn "*sgeu"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (geu:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                (match_operand:SI 2 "register_or_K_operand" "r,L")))]
+  ""
+  "@
+   cmpgeu   %0, %z1, %2
+   cmpgeui  %0, %z1, %2"
+  [(set_attr "type" "compare")]
+)
+
+;; ---------------------------------
+;;       unconditional branch
+;; ---------------------------------
+
+(define_insn "jump"
+  [(set (pc) (label_ref (match_operand 0 "" "")))]
+  ""
+  "bi       %0"
+  [(set_attr "type" "ubranch")]
+)
+
+(define_expand "indirect_jump"
+  [(set (pc) (match_operand 0 "register_operand" ""))]
+  ""
+  "
+{
+  emit_jump_insn (gen_indirect_jumpsi (operands[0]));
+  DONE;
+}")
+
+(define_insn "indirect_jumpsi"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "b        %0"
+  [(set_attr "type" "uibranch")]
+)
+
+;; ---------------------------------
+;;        conditional branch
+;; ---------------------------------
+
+(define_expand "beq"
+  [(set (pc)
+   (if_then_else (eq:CC (cc0)
+                        (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{   
+  gen_int_relational (EQ, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "bne"
+  [(set (pc)
+   (if_then_else (ne:CC (cc0)
+                        (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (NE, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "bgt"
+  [(set (pc)
+   (if_then_else (gt:CC (cc0)
+                        (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (GT, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "bge"
+  [(set (pc)
+   (if_then_else (ge:CC (cc0)
+                        (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (GE, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "ble"
+  [(set (pc)
+   (if_then_else (le:CC (cc0)
+                        (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (LE, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "blt"
+  [(set (pc)
+   (if_then_else (lt:CC (cc0)
+                        (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (LT, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "bgtu"
+  [(set (pc)
+   (if_then_else (gtu:CC (cc0)
+                         (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (GTU, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "bgeu"
+  [(set (pc)
+   (if_then_else (geu:CC (cc0)
+                         (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (GEU, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "bleu"
+  [(set (pc)
+   (if_then_else (leu:CC (cc0)
+                         (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (LEU, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_expand "bltu"
+  [(set (pc)
+   (if_then_else (ltu:CC (cc0)
+                         (const_int 0))
+                 (label_ref (match_operand 0 "" ""))
+                 (pc)))]
+  ""
+  "
+{ 
+  gen_int_relational (LTU, NULL_RTX, lm32_compare_op0, lm32_compare_op1, operands[0]);
+  DONE;
+}")
+
+(define_insn "*beq"
+  [(set (pc)
+        (if_then_else (eq:SI (match_operand:SI 0 "register_or_zero_operand" "rJ")
+                             (match_operand:SI 1 "register_or_zero_operand" "rJ"))
+                      (label_ref (match_operand 2 "" ""))
+                      (pc)))]
+  ""
+{
+  return get_attr_length (insn) == 4
+        ? "be     %z0,%z1,%2"
+        : "bne    %z0,%z1,8\n\tbi     %2";
+}  
+  [(set_attr "type" "cbranch")])
+
+(define_insn "*bne"
+  [(set (pc)
+        (if_then_else (ne:SI (match_operand:SI 0 "register_or_zero_operand" "rJ")
+                             (match_operand:SI 1 "register_or_zero_operand" "rJ"))
+                      (label_ref (match_operand 2 "" ""))
+                      (pc)))]
+  ""
+{
+  return get_attr_length (insn) == 4
+        ? "bne    %z0,%z1,%2"
+        : "be     %z0,%z1,8\n\tbi     %2";
+}  
+  [(set_attr "type" "cbranch")])
+
+(define_insn "*bgt"
+  [(set (pc)
+        (if_then_else (gt:SI (match_operand:SI 0 "register_or_zero_operand" "rJ")
+                             (match_operand:SI 1 "register_or_zero_operand" "rJ"))
+                      (label_ref (match_operand 2 "" ""))
+                      (pc)))]
+  ""
+{
+  return get_attr_length (insn) == 4
+        ? "bg     %z0,%z1,%2"
+        : "bge    %z1,%z0,8\n\tbi     %2";
+}  
+  [(set_attr "type" "cbranch")])
+
+(define_insn "*bge"
+  [(set (pc)
+        (if_then_else (ge:SI (match_operand:SI 0 "register_or_zero_operand" "rJ")
+                             (match_operand:SI 1 "register_or_zero_operand" "rJ"))
+                      (label_ref (match_operand 2 "" ""))
+                      (pc)))]
+  ""
+{
+  return get_attr_length (insn) == 4
+        ? "bge    %z0,%z1,%2"
+        : "bg     %z1,%z0,8\n\tbi     %2";
+}  
+  [(set_attr "type" "cbranch")])
+
+(define_insn "*bgtu"
+  [(set (pc)
+        (if_then_else (gtu:SI (match_operand:SI 0 "register_or_zero_operand" "rJ")
+                              (match_operand:SI 1 "register_or_zero_operand" "rJ"))
+                      (label_ref (match_operand 2 "" ""))
+                      (pc)))]
+  ""
+{
+  return get_attr_length (insn) == 4
+        ? "bgu    %z0,%z1,%2"
+        : "bgeu   %z1,%z0,8\n\tbi     %2";
+}  
+  [(set_attr "type" "cbranch")])
+
+(define_insn "*bgeu"
+  [(set (pc)
+        (if_then_else (geu:SI (match_operand:SI 0 "register_or_zero_operand" "rJ")
+                              (match_operand:SI 1 "register_or_zero_operand" "rJ"))
+                      (label_ref (match_operand 2 "" ""))
+                      (pc)))]
+  ""
+{
+  return get_attr_length (insn) == 4
+        ? "bgeu   %z0,%z1,%2"
+        : "bgu    %z1,%z0,8\n\tbi     %2";
+}  
+  [(set_attr "type" "cbranch")])
+
+;; ---------------------------------
+;;               call 
+;; ---------------------------------
+
+(define_expand "call"
+  [(parallel [(call (match_operand 0 "memory_operand" "m")
+                    (match_operand 1 "" ""))
+              (clobber (reg:SI RA_REGNUM))
+             ])]
+  ""
+  "
+{
+  rtx addr = XEXP (operands[0], 0);
+  if (!CONSTANT_ADDRESS_P (addr))
+    {
+      emit_call_insn (gen_call_via_regsi (addr, operands[1]));
+      DONE;
+    }
+}")
+
+(define_insn "call_via_regsi"
+  [(call (mem:SI (match_operand:SI 0 "register_operand" "r"))
+         (match_operand 1 "" ""))
+   (clobber (reg:SI RA_REGNUM))]
+  ""
+  "call     %0"
+  [(set_attr "type" "icall")]  
+)
+
+(define_insn "*call_via_labelsi"
+  [(call (mem:SI (match_operand:SI 0 "symbolic_operand" "X"))
+         (match_operand 1 "" ""))
+   (clobber (reg:SI RA_REGNUM))]
+  ""
+  "calli    %0"
+  [(set_attr "type" "call")]  
+)
+
+(define_expand "call_value"
+  [(parallel [(set (match_operand 0 "register_operand" "=r")
+                   (call (match_operand 1 "memory_operand" "m")
+                         (match_operand 2 "" "")))
+              (clobber (reg:SI RA_REGNUM))
+             ])]
+  ""
+  "
+{
+  rtx addr = XEXP (operands[1], 0);
+  if (!CONSTANT_ADDRESS_P (addr))
+    {
+      emit_call_insn (gen_call_value_via_regsi (operands[0], addr, operands[2]));
+      DONE;
+    }
+}")
+
+(define_insn "call_value_via_regsi"
+  [(set (match_operand 0 "register_operand" "=r")
+        (call (mem:SI (match_operand:SI 1 "register_operand" "r"))
+              (match_operand 2 "" "")))
+   (clobber (reg:SI RA_REGNUM))]
+  ""
+  "call      %1"
+  [(set_attr "type" "icall")]  
+)
+
+(define_insn "*call_value_via_labelsi"
+  [(set (match_operand 0 "register_operand" "=r")
+        (call (mem:SI (match_operand:SI 1 "symbolic_operand" "X"))
+              (match_operand 2 "" "")))
+   (clobber (reg:SI RA_REGNUM))]
+  ""
+  "calli    %1"
+  [(set_attr "type" "call")]  
+)
+
+(define_insn "return_internalsi"
+  [(use (match_operand:SI 0 "register_operand" "r"))
+   (return)]
+  ""
+  "b        %0"
+  [(set_attr "type" "uibranch")]  
+)
+
+(define_insn "return"
+  [(return)]
+  "lm32_can_use_return ()"
+  "ret"
+  [(set_attr "type" "uibranch")]  
+) 
+
+;; ---------------------------------
+;;       switch/case statements 
+;; ---------------------------------
+  
+(define_expand "tablejump"
+  [(set (pc) (match_operand 0 "register_operand" ""))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "
+{
+  rtx target = operands[0];
+  if (flag_pic)
+    {
+      /* For PIC, the table entry is relative to the start of the table.  */
+      rtx label = gen_reg_rtx (SImode);
+      target = gen_reg_rtx (SImode);
+      emit_move_insn (label, gen_rtx_LABEL_REF (SImode, operands[1]));
+      emit_insn (gen_addsi3 (target, operands[0], label));
+    }
+  emit_jump_insn (gen_tablejumpsi (target, operands[1]));
+  DONE;
+}")
+
+(define_insn "tablejumpsi"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "b        %0"
+  [(set_attr "type" "ubranch")]  
+)
+
+;; ---------------------------------
+;;            arithmetic 
+;; ---------------------------------
+
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (plus:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                 (match_operand:SI 2 "register_or_K_operand" "r,K")))]
+  ""
+  "@
+   add      %0, %z1, %2
+   addi     %0, %z1, %2"
+  [(set_attr "type" "arith")]  
+)
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (minus:SI (match_operand:SI 1 "register_or_zero_operand" "rJ")
+                  (match_operand:SI 2 "register_or_zero_operand" "rJ")))]
+  ""
+  "sub      %0, %z1, %z2"
+  [(set_attr "type" "arith")]  
+)
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (mult:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                 (match_operand:SI 2 "register_or_K_operand" "r,K")))]
+  "TARGET_MULTIPLY_ENABLED"
+  "@
+   mul      %0, %z1, %2
+   muli     %0, %z1, %2"
+  [(set_attr "type" "multiply")]
+)
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (udiv:SI (match_operand:SI 1 "register_or_zero_operand" "rJ")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_DIVIDE_ENABLED"
+  "divu     %0, %z1, %2"
+  [(set_attr "type" "divide")]
+)
+
+(define_insn "umodsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (umod:SI (match_operand:SI 1 "register_or_zero_operand" "rJ")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_DIVIDE_ENABLED"
+  "modu     %0, %z1, %2"
+  [(set_attr "type" "divide")]
+)
+
+;; ---------------------------------
+;;      negation and inversion 
+;; ---------------------------------
+               
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (neg:SI (match_operand:SI 1 "register_or_zero_operand" "rJ")))]
+  ""
+  "sub      %0, r0, %z1"
+  [(set_attr "type" "arith")]
+)      
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (not:SI (match_operand:SI 1 "register_or_zero_operand" "rJ")))]
+  ""
+  "not      %0, %z1"
+  [(set_attr "type" "arith")]
+)
+
+;; ---------------------------------
+;;             logical 
+;; ---------------------------------
+
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (and:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                (match_operand:SI 2 "register_or_L_operand" "r,L")))]
+  ""
+  "@
+   and      %0, %z1, %2
+   andi     %0, %z1, %2"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ior:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                (match_operand:SI 2 "register_or_L_operand" "r,L")))]
+  ""
+  "@
+   or       %0, %z1, %2
+   ori      %0, %z1, %2"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (xor:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                (match_operand:SI 2 "register_or_L_operand" "r,L")))]
+  ""
+  "@
+   xor      %0, %z1, %2
+   xori     %0, %z1, %2"
+  [(set_attr "type" "arith")]
+)
+
+(define_insn "*norsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(not:SI (ior:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+			(match_operand:SI 2 "register_or_L_operand" "r,L"))))]
+  ""
+  "@ 
+   nor      %0, %z1, %2
+   nori     %0, %z1, %2"     		
+  [(set_attr "type" "arith")]
+)                
+
+(define_insn "*xnorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(not:SI (xor:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+			(match_operand:SI 2 "register_or_L_operand" "r,L"))))]
+  ""
+  "@
+   xnor     %0, %z1, %2
+   xnori    %0, %z1, %2"     		
+  [(set_attr "type" "arith")]
+)                
+
+;; ---------------------------------
+;;              shifts 
+;; ---------------------------------
+
+(define_insn "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashift:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                   (match_operand:SI 2 "register_or_L_operand" "r,L")))]
+  "TARGET_BARREL_SHIFT_ENABLED"
+  "@ 
+   sl       %0, %z1, %2
+   sli      %0, %z1, %2"
+  [(set_attr "type" "shift")]
+)
+
+(define_insn "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashiftrt:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                     (match_operand:SI 2 "register_or_L_operand" "r,L")))]
+  "TARGET_BARREL_SHIFT_ENABLED"
+  "@
+   sr       %0, %z1, %2
+   sri      %0, %z1, %2"
+  [(set_attr "type" "shift")]
+)
+
+(define_insn "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (lshiftrt:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+                     (match_operand:SI 2 "register_or_L_operand" "r,L")))]
+  "TARGET_BARREL_SHIFT_ENABLED"
+  "@ 
+   sru      %0, %z1, %2
+   srui     %0, %z1, %2"
+  [(set_attr "type" "shift")]   
+)
+
+;; ---------------------------------
+;;     function entry / exit 
+;; ---------------------------------
+
+(define_expand "prologue"
+  [(const_int 1)]
+  ""
+  "
+{
+  lm32_expand_prologue ();
+  DONE;
+}")
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+  "
+{
+  lm32_expand_epilogue ();
+  DONE;
+}")
+
+;; ---------------------------------
+;;              nop 
+;; ---------------------------------
+
+(define_insn "nop"  
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "type" "arith")]
+)
+
+;; ---------------------------------
+;;             blockage 
+;; ---------------------------------
+
+;; used to stop the scheduler from 
+;; scheduling code across certain boundaries
+
+(define_insn "blockage"
+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]
+  ""
+  ""
+  [(set_attr "length" "0")]
+)
+
diff --git a/gcc/config/lm32/lm32.opt b/gcc/config/lm32/lm32.opt
new file mode 100644
index 0000000..43bdd9c
--- /dev/null
+++ b/gcc/config/lm32/lm32.opt
@@ -0,0 +1,41 @@
+; Options for the LatticeMico32 port of the compiler
+; Contributed by Jon Beniston <jon@beniston.com>
+;
+; Copyright (C) 2006 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 2, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT
+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+; License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING.  If not, write to the Free
+; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+; 02110-1301, USA.
+
+mmultiply-enabled
+Target Report Mask(MULTIPLY_ENABLED)
+Enable multiply instructions
+
+mdivide-enabled
+Target Report Mask(DIVIDE_ENABLED)
+Enable divide and modulus instructions
+
+mbarrel-shift-enabled
+Target Report Mask(BARREL_SHIFT_ENABLED)
+Enable barrel shift instructions
+
+msign-extend-enabled
+Target Report Mask(SIGN_EXTEND_ENABLED)
+Enable sign extend instructions
+
+muser-enabled
+Target Report Mask(USER_ENABLED)
+Enable user-defined instructions
diff --git a/gcc/config/lm32/predicates.md b/gcc/config/lm32/predicates.md
new file mode 100644
index 0000000..52cd732
--- /dev/null
+++ b/gcc/config/lm32/predicates.md
@@ -0,0 +1,59 @@
+;; Predicate definitions for LatticeMico32
+;; Contributed by Jon Beniston <jon@beniston.com>
+
+;; Copyright (C) 2006 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 2, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+(define_predicate "const0_operand"
+  (and (match_code "const_int,const_double,const_vector")
+       (match_test "op == CONST0_RTX (GET_MODE (op))")))
+
+(define_predicate "constant_K_operand"
+  (and (match_code "const_int")
+       (match_test "MEDIUM_INT (INTVAL (op))")))
+       
+(define_predicate "constant_L_operand"
+  (and (match_code "const_int")
+       (match_test "MEDIUM_UINT (INTVAL (op))")))
+
+(define_predicate "register_or_zero_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "const0_operand")))
+
+(define_predicate "register_or_memory_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "memory_operand")))
+       
+(define_predicate "register_or_K_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "constant_K_operand")))
+         
+(define_predicate "register_or_L_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "constant_L_operand")))
+
+(define_predicate "reloc_operand"
+  (ior (ior (match_code "label_ref")
+            (match_code "symbol_ref"))
+       (match_code "const")))
+
+(define_predicate "symbolic_operand"
+  (ior (match_code "label_ref")
+       (match_code "symbol_ref")))
+       
diff --git a/gcc/config/lm32/t-lm32 b/gcc/config/lm32/t-lm32
new file mode 100644
index 0000000..996e490
--- /dev/null
+++ b/gcc/config/lm32/t-lm32
@@ -0,0 +1,47 @@
+LIB1ASMSRC = lm32/lib1funcs.S
+LIB1ASMFUNCS = _ashlsi3 _ashrsi3 _lshrsi3
+
+LIB2FUNCS_EXTRA = _mulsi3.c \
+                  _udivmodsi4.c _divsi3.c _modsi3.c _udivsi3.c _umodsi3.c \
+#	          _ashlsi3.c _ashrsi3.c _lshrsi3.c 
+	          	          
+LM32_LIB1CSRC = $(srcdir)/config/lm32/arithmetic.c
+
+# The fixed-point arithmetic code is in one file
+# similar to libgcc2.c (or the old libgcc1.c).  We need to
+# "split it up" with one file per define.
+$(LIB2FUNCS_EXTRA): $(LM32_LIB1CSRC)
+	name=`echo $@ | sed -e 's,.*/,,' | sed -e 's,.c$$,,'`; \
+	echo "#define L$$name" > tmp-$@ \
+	&& echo '#include "$<"' >> tmp-$@ \
+	&& mv -f tmp-$@ $@
+
+CRTSTUFF_T_CFLAGS = -fPIC
+TARGET_LIBGCC2_CFLAGS = -fPIC
+
+# Assemble startup files.
+
+$(T)crti.o: $(srcdir)/config/lm32/crti.S $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/lm32/crti.S
+
+$(T)crtn.o: $(srcdir)/config/lm32/crtn.S $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/lm32/crtn.S
+
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
+
+MULTILIB_OPTIONS = mmultiply-enabled mbarrel-shift-enabled 
+# Don't bother building multilib with mdivide-enabled, not much of a gain
+
+# Include floating-point emulation library
+
+FPBIT = fp-bit.c
+DPBIT = dp-bit.c
+
+fp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#define FLOAT' > fp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
+
+dp-bit.c: $(srcdir)/config/fp-bit.c
+	cat $(srcdir)/config/fp-bit.c > dp-bit.c
diff --git a/gcc/config/lm32/uclinux-elf.h b/gcc/config/lm32/uclinux-elf.h
new file mode 100644
index 0000000..5b0b19b
--- /dev/null
+++ b/gcc/config/lm32/uclinux-elf.h
@@ -0,0 +1,84 @@
+/* Definitions for LM32 running Linux-based GNU systems using ELF
+   Copyright (C) 1993, 1994, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   Contributed by Philip Blundell <philb@gnu.org>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 2, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* elfos.h should have already been included.  Now just override
+   any conflicting definitions and add any extras.  */
+
+/* Run-time Target Specification.  */
+#undef  TARGET_VERSION
+#define TARGET_VERSION  fputs (" (LM32 GNU/Linux with ELF)", stderr);
+
+/* Do not assume anything about header files.  */
+#undef NO_IMPLICIT_EXTERN_C
+#define NO_IMPLICIT_EXTERN_C
+
+/* The GNU C++ standard library requires that these macros be defined.  */
+#undef CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
+
+/* Now we define the strings used to build the spec file.  */
+#undef  LIB_SPEC
+#define LIB_SPEC \
+  "%{pthread:-lpthread} \
+   %{shared:-lc} \
+   %{!shared:-lc} "
+
+#define LIBGCC_SPEC "-lgcc"
+
+/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add
+   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main'.  */
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC \
+  "%{!shared: \
+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \
+                       %{!p:%{profile:gcrt1.o%s} \
+                         %{!profile:crt1.o%s}}}} \
+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+
+/* Provide a ENDFILE_SPEC appropriate for GNU/Linux.  Here we tack on
+   the GNU/Linux magical crtend.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main', followed by a normal
+   GNU/Linux "finalizer" file, `crtn.o'.  */
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s"
+
+#undef  LINK_SPEC
+#define LINK_SPEC "%{h*} %{version:-v} \
+   %{b} %{Wl,*:%*} \
+   %{static:-Bstatic} \
+   %{shared:-shared} \
+   %{symbolic:-Bsymbolic} \
+   %{rdynamic:-export-dynamic} \
+   %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}"
+
+#define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()
+
+#define LINK_GCC_C_SEQUENCE_SPEC \
+  "%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}"
+
+
diff --git a/gcc/config/lm32/xm-lm32.h b/gcc/config/lm32/xm-lm32.h
new file mode 100644
index 0000000..2763019
--- /dev/null
+++ b/gcc/config/lm32/xm-lm32.h
@@ -0,0 +1,43 @@
+/* Configuration for GNU C-compiler for the LatticeMico32 architecture.
+   Contributed by Jon Beniston <jon@beniston.com>
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* #defines that need visibility everywhere.  */
+#define FALSE 0
+#define TRUE 1
+
+/* This describes the machine the compiler is hosted on.  */
+#define HOST_BITS_PER_CHAR 8
+#define HOST_BITS_PER_SHORT 16
+#define HOST_BITS_PER_INT 32
+#define HOST_BITS_PER_LONG 32
+#define HOST_BITS_PER_LONGLONG 64
+
+/* target machine dependencies.
+   tm.h is a symbolic link to the actual target specific file.   */
+#include "tm.h"
+
+/* Arguments to use with `exit'.  */
+#define SUCCESS_EXIT_CODE 0
+#define FATAL_EXIT_CODE 33
+
+/* If compiled with Sun CC, the use of alloca requires this #include.  */
+#ifndef __GNUC__
+#include "alloca.h"
+#endif
diff --git a/gcc/doc/contrib.texi b/gcc/doc/contrib.texi
index 16c8af5..59c800e 100644
--- a/gcc/doc/contrib.texi
+++ b/gcc/doc/contrib.texi
@@ -1,5 +1,5 @@
 @c Copyright (C) 1988,1989,1992,1993,1994,1995,1996,1997,1998,1999,2000,
-@c 2001,2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
+@c 2001,2002,2003,2004,2005,2006 Free Software Foundation, Inc.
 @c This is part of the GCC manual.
 @c For copying conditions, see the file gcc.texi.
 
@@ -55,7 +55,7 @@ Scott Bambrough for help porting the Java compiler.
 Wolfgang Bangerth for processing tons of bug reports.
 
 @item
-Jon Beniston for his Microsoft Windows port of Java.
+Jon Beniston for his Microsoft Windows port of Java and LatticeMico32 port.
 
 @item
 Daniel Berlin for better DWARF2 support, faster/better optimizations,
@@ -551,7 +551,7 @@ improvements, and string clean up and testsuites.
 
 @item
 All of the Mauve project
-@uref{http://sourceware.org/cgi-bin/cvsweb.cgi/~checkout~/mauve/THANKS?rev=1.2&cvsroot=mauve&only_with_tag=HEAD,,contributors},
+@uref{http://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/mauve/THANKS?rev=1.2&cvsroot=mauve&only_with_tag=HEAD,,contributors},
 for Java test code.
 
 @item
diff --git a/gcc/testsuite/g++.dg/other/packed1.C b/gcc/testsuite/g++.dg/other/packed1.C
index 5d19eb0..c3f25fe 100644
--- a/gcc/testsuite/g++.dg/other/packed1.C
+++ b/gcc/testsuite/g++.dg/other/packed1.C
@@ -1,4 +1,4 @@
-// { dg-do run { xfail arm-*-* sh-*-* ia64-hp-hpux* } }
+// { dg-do run { xfail arm-*-* sh-*-* ia64-hp-hpux* lm32-*-* } }
 
 // NMS:2003-04-21 this fails on strict aligned architectures again,
 // the patch was reverted because it broke something more important.
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/thunk3.C b/gcc/testsuite/g++.old-deja/g++.jason/thunk3.C
index 1b235ef..d280265 100644
--- a/gcc/testsuite/g++.old-deja/g++.jason/thunk3.C
+++ b/gcc/testsuite/g++.old-deja/g++.jason/thunk3.C
@@ -1,4 +1,4 @@
-// { dg-do run { xfail rs6000-*-* powerpc-*-eabi m68k-*-coff mn10300-*-* v850-*-* sh-*-* sh64-*-* h8*-*-* xtensa-*-* m32r*-*-* } }
+// { dg-do run { xfail rs6000-*-* powerpc-*-eabi m68k-*-coff mn10300-*-* v850-*-* sh-*-* sh64-*-* h8*-*-* xtensa-*-* m32r*-*-* lm32-*-* } }
 // Test that variadic function calls using thunks work right.
 // Note that this will break on any target that uses the generic thunk
 //  support, because it doesn't support variadic functions.
@@ -55,4 +55,5 @@ int main ()
 
   if (test(c) != &c)
     return 1;
+  return 0;
 }
diff --git a/gcc/testsuite/gcc.dg/20020312-2.c b/gcc/testsuite/gcc.dg/20020312-2.c
index 6acc1e6..edfb86d 100644
--- a/gcc/testsuite/gcc.dg/20020312-2.c
+++ b/gcc/testsuite/gcc.dg/20020312-2.c
@@ -70,6 +70,8 @@ extern void abort (void);
 # define PIC_REG  "r12"
 #elif defined(__x86_64__)
 /* No pic register.  */
+#elif defined(__lm32__)
+/* No pic register.  */
 #elif defined(__m32c__)
 /* No pic register.  */
 #else
diff --git a/gcc/testsuite/gcc.dg/builtins-config.h b/gcc/testsuite/gcc.dg/builtins-config.h
index e61d02a..5593f61 100644
--- a/gcc/testsuite/gcc.dg/builtins-config.h
+++ b/gcc/testsuite/gcc.dg/builtins-config.h
@@ -15,6 +15,8 @@
 /* Irix6 doesn't have the entire C99 runtime.  */
 #elif defined(__FreeBSD__) && (__FreeBSD__ < 5)
 /* FreeBSD before version 5 doesn't have the entire C99 runtime. */
+#elif defined(__lm32__) 
+/* LatticeMico32 doesn't have the entire C99 runtime. */
 #elif defined(__netware__)
 /* NetWare doesn't have the entire C99 runtime.  */
 #elif (defined(__APPLE__) && defined(__ppc__) \
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 3803c9d..75f181d 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -1,4 +1,4 @@
-#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007
+#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006
 #   Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
@@ -344,6 +344,7 @@ proc check_profiling_available { test_what } {
 	     || [istarget strongarm*-*-elf]
 	     || [istarget xscale*-*-elf]
 	     || [istarget cris-*-*]
+	     || [istarget lm32-*-*]
 	     || [istarget h8300-*-*]
 	     || [istarget m32c-*-elf]
 	     || [istarget m68k-*-elf]

diff -ruN linux-2.6.28.10_o/arch/ubicom32/configs/IP5160EVAL_defconfig linux-2.6.28.10/arch/ubicom32/configs/IP5160EVAL_defconfig
--- linux-2.6.28.10_o/arch/ubicom32/configs/IP5160EVAL_defconfig	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/configs/IP5160EVAL_defconfig	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,524 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28.10
+#
+CONFIG_RAMBASE=0x40000000
+CONFIG_UBICOM32=y
+CONFIG_RAMKERNEL=y
+CONFIG_CPU_BIG_ENDIAN=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_HAVE_CLK=y
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_ZONE_DMA=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GPIOLIB=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_TIME=y
+CONFIG_TIME_LOW_RES=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_NO_IOPORT=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_IRQ_PER_CPU=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+
+#
+# Processor type and features
+#
+CONFIG_BRD_32MB=y
+
+#
+# Processor type will be selected by Board
+#
+CONFIG_UBICOM32_V3=y
+
+#
+# Board
+#
+# CONFIG_NOBOARD is not set
+# CONFIG_IP5170DPF is not set
+# CONFIG_IP5160DEV is not set
+CONFIG_IP5160EVAL=y
+# CONFIG_IP7145DPF is not set
+# CONFIG_IP7160RGW is not set
+# CONFIG_IP7160BRINGUP is not set
+# CONFIG_IP7160DPF is not set
+# CONFIG_IP7500MODULE is not set
+# CONFIG_IP7500AV is not set
+# CONFIG_IP7500MEDIA is not set
+
+#
+# Kernel Options
+#
+# CONFIG_SMP is not set
+CONFIG_TIMER_EXTRA_ALLOC=0
+# CONFIG_IRQSTACKS is not set
+CONFIG_UBICOM32_OCM_MODULES=y
+CONFIG_OCM_MODULES_RESERVATION=41
+CONFIG_OCM_MODULES_MAY_CONSUME_REMAINING_CODESPACE=y
+CONFIG_HZ=1000
+
+#
+# RAM configuration
+#
+CONFIG_RAMSIZE=0x02000000
+CONFIG_KERNELBASE=0x40400000
+
+#
+# Build options
+#
+CONFIG_LINKER_RELAXATION=y
+
+#
+# Driver options
+#
+
+#
+# PCI Bus
+#
+# CONFIG_PCI is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+
+#
+# Input devices
+#
+# CONFIG_UBICOM_INPUT is not set
+# CONFIG_UBICOM_INPUT_I2C is not set
+CONFIG_UBICOM_SWITCH=y
+
+#
+# Misc devices
+#
+# CONFIG_UBICOM_HID is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyUM0"
+# CONFIG_CMDLINE_OVERRIDE is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PROTECT_KERNEL=y
+# CONFIG_NO_KERNEL_MSG is not set
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_STOP_ON_TRAP is not set
+# CONFIG_STOP_ON_BUG is not set
+# CONFIG_DEBUG_IRQMEASURE is not set
+# CONFIG_DEBUG_PCIMEASURE is not set
+# CONFIG_ACCESS_OK_CHECKS_ENABLED is not set
+CONFIG_UNALIGNED_ACCESS_ENABLED=y
+# CONFIG_UNALIGNED_ACCESS_USERSPACE_ONLY is not set
+# CONFIG_UNALIGNED_ACCESS_DISABLED is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+
+#
+# Tracers
+#
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+# CONFIG_SIGNALFD is not set
+# CONFIG_TIMERFD is not set
+# CONFIG_EVENTFD is not set
+CONFIG_AIO=y
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_CLASSIC_RCU=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_DEBUG_DRIVER=y
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_MISC_DEVICES is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_UBI32_SERDES=y
+CONFIG_SERIAL_UBI32_SERDES_CONSOLE=y
+# CONFIG_SERIAL_UBI32_MAILBOX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_DEBUG_GPIO is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_REGULATOR is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_SOUND is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+# CONFIG_SYSFS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+
+#
+# Layered filesystems
+#
+# CONFIG_UNION_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# OCF Configuration
+#
+# CONFIG_OCF_OCF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
diff -ruN linux-2.6.28.10_o/arch/ubicom32/configs/IP7160RGW_defconfig linux-2.6.28.10/arch/ubicom32/configs/IP7160RGW_defconfig
--- linux-2.6.28.10_o/arch/ubicom32/configs/IP7160RGW_defconfig	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/configs/IP7160RGW_defconfig	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,1301 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28.10
+#
+CONFIG_RAMBASE=0x40000000
+CONFIG_UBICOM32=y
+CONFIG_RAMKERNEL=y
+CONFIG_CPU_BIG_ENDIAN=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_HAVE_CLK=y
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_ZONE_DMA=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GPIOLIB=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_TIME=y
+CONFIG_TIME_LOW_RES=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_NO_IOPORT=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_IRQ_PER_CPU=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+
+#
+# Processor type and features
+#
+CONFIG_BRD_64MB=y
+
+#
+# Processor type will be selected by Board
+#
+CONFIG_UBICOM32_V4=y
+
+#
+# Board
+#
+# CONFIG_NOBOARD is not set
+# CONFIG_IP5170DPF is not set
+# CONFIG_IP5160DEV is not set
+# CONFIG_IP5160EVAL is not set
+# CONFIG_IP7145DPF is not set
+CONFIG_IP7160RGW=y
+# CONFIG_IP7160BRINGUP is not set
+# CONFIG_IP7160DPF is not set
+# CONFIG_IP7500MODULE is not set
+# CONFIG_IP7500AV is not set
+# CONFIG_IP7500MEDIA is not set
+
+#
+# Kernel Options
+#
+# CONFIG_SMP is not set
+CONFIG_TIMER_EXTRA_ALLOC=0
+# CONFIG_IRQSTACKS is not set
+CONFIG_UBICOM32_OCM_MODULES=y
+CONFIG_OCM_MODULES_RESERVATION=41
+CONFIG_OCM_MODULES_MAY_CONSUME_REMAINING_CODESPACE=y
+CONFIG_HZ=100
+
+#
+# RAM configuration
+#
+CONFIG_RAMSIZE=0x04000000
+CONFIG_KERNELBASE=0x40400000
+
+#
+# Build options
+#
+# CONFIG_LINKER_RELAXATION is not set
+
+#
+# Driver options
+#
+
+#
+# PCI Bus
+#
+CONFIG_PCI=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCI_LEGACY is not set
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_DEV0_IDSEL=0x001000000
+CONFIG_PCI_DEV1_IDSEL=0x002000000
+
+#
+# Input devices
+#
+CONFIG_UBICOM_INPUT=y
+# CONFIG_UBICOM_INPUT_I2C is not set
+CONFIG_UBICOM_SWITCH=y
+CONFIG_UBICOM_SWITCH_BCM539X=y
+
+#
+# Misc devices
+#
+# CONFIG_UBICOM_HID is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyUM0 console=ttyUS0 serdes=0x02004000,61,250000000"
+# CONFIG_CMDLINE_OVERRIDE is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PROTECT_KERNEL=y
+# CONFIG_NO_KERNEL_MSG is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_STOP_ON_TRAP is not set
+# CONFIG_STOP_ON_BUG is not set
+# CONFIG_DEBUG_IRQMEASURE is not set
+# CONFIG_DEBUG_PCIMEASURE is not set
+# CONFIG_ACCESS_OK_CHECKS_ENABLED is not set
+CONFIG_UNALIGNED_ACCESS_ENABLED=y
+# CONFIG_UNALIGNED_ACCESS_USERSPACE_ONLY is not set
+# CONFIG_UNALIGNED_ACCESS_DISABLED is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+
+#
+# Tracers
+#
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+# CONFIG_SIGNALFD is not set
+# CONFIG_TIMERFD is not set
+# CONFIG_EVENTFD is not set
+CONFIG_AIO=y
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_PCI_QUIRKS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_CLASSIC_RCU=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_VIRT_TO_BUS=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE=y
+# CONFIG_NET_IPGRE_BROADCAST is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CT_ACCT is not set
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+CONFIG_NF_CT_PROTO_GRE=y
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+CONFIG_IP_NF_MATCH_AH=y
+# CONFIG_IP_NF_MATCH_ECN is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+# CONFIG_NF_QOS_UBICOM_STREAMENGINE_DEFAULT_CLASSIFIER is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_SNMP_BASIC=y
+CONFIG_NF_NAT_PROTO_GRE=y
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+CONFIG_NF_NAT_PPTP=y
+# CONFIG_NF_NAT_H323 is not set
+# CONFIG_NF_NAT_SIP is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+CONFIG_IP_NF_TARGET_TTL=y
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+CONFIG_MTD_UBI32_M25P80=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# Enable only one of the two stacks, unless you know what you are doing
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_MII=y
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_JME is not set
+CONFIG_UBICOM32_GMAC=y
+CONFIG_UBICOM32_NAPI=y
+CONFIG_UBICOM32_OCM_FOR_SKB=y
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UBI32_SERDES is not set
+CONFIG_SERIAL_UBI32_MAILBOX=y
+CONFIG_SERIAL_UBI32_MAILBOX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_UBICOM32=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_I2C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_UBICOM32_GPIO=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ALIM7101_WDT is not set
+CONFIG_UBI32_WDT=y
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_REGULATOR is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_MUSB_HDRC=y
+# CONFIG_USB_TUSB6010 is not set
+CONFIG_USB_MUSB_HOST=y
+# CONFIG_USB_MUSB_PERIPHERAL is not set
+# CONFIG_USB_MUSB_OTG is not set
+CONFIG_USB_MUSB_HDRC_HCD=y
+CONFIG_MUSB_PIO_ONLY=y
+# CONFIG_USB_MUSB_DEBUG is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+CONFIG_LEDS_GPIO=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Layered filesystems
+#
+CONFIG_UNION_FS=y
+# CONFIG_UNION_FS_XATTR is not set
+# CONFIG_UNION_FS_DEBUG is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+CONFIG_LDM_PARTITION=y
+CONFIG_LDM_DEBUG=y
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# OCF Configuration
+#
+# CONFIG_OCF_OCF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/a.out.h linux-2.6.28.10/arch/ubicom32/include/asm/a.out.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/a.out.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/a.out.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,47 @@
+/*
+ * arch/ubicom32/include/asm/a.out.h
+ *   Definitions for Ubicom32 a.out executable format.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_A_OUT_H
+#define _ASM_UBICOM32_A_OUT_H
+
+struct exec
+{
+  unsigned long a_info;		/* Use macros N_MAGIC, etc for access */
+  unsigned a_text;		/* length of text, in bytes */
+  unsigned a_data;		/* length of data, in bytes */
+  unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
+  unsigned a_syms;		/* length of symbol table data in file, in bytes */
+  unsigned a_entry;		/* start address */
+  unsigned a_trsize;		/* length of relocation info for text, in bytes */
+  unsigned a_drsize;		/* length of relocation info for data, in bytes */
+};
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#endif /* _ASM_UBICOM32_A_OUT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/atomic.h linux-2.6.28.10/arch/ubicom32/include/asm/atomic.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/atomic.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/atomic.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,352 @@
+/*
+ * arch/ubicom32/include/asm/atomic.h
+ *   Atomic operations definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_ATOMIC_H
+#define _ASM_UBICOM32_ATOMIC_H
+
+#include <asm/system.h>
+#include <asm/ubicom32-common.h>
+#include <asm/types.h>
+
+/*
+ * Most instructions on the Ubicom32 processor are atomic in that they
+ * execute in one clock cycle.  However, Linux has several operations
+ * (e.g. compare and swap) which will require more than a single instruction
+ * to perform.   To achieve this, the Ubicom32 processor uses a single
+ * global bit in a scratchpad register as a critical section lock. All
+ * atomic operations acquire this lock.
+ *
+ * NOTE: To AVOID DEADLOCK(s), the atomic lock must only be used for atomic
+ * operations or by the ldsr to avoid disabling a thread performing an atomic
+ * operation.
+ *
+ * Do not attempt to disable interrupts while holding the atomic operations
+ * lock or you will DEADLOCK the system.
+ */
+
+typedef struct {
+	volatile int counter;
+} atomic_t;
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+/*
+ * __atomic_add()
+ * 	Add i to v and return the result.
+ */
+static inline void __atomic_add(int i, atomic_t *v)
+{
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	vt->counter += i;
+	__atomic_lock_release();
+}
+
+/*
+ * __atomic_sub()
+ * 	Subtract i from v and return the result.
+ */
+static inline void __atomic_sub(int i, atomic_t *v)
+{
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	vt->counter -= i;
+	__atomic_lock_release();
+}
+
+/*
+ * __atomic_add_return()
+ * 	Add i to v and return the result.
+ *
+ * The implementation here looks rather odd because we appear to be doing
+ * the addition twice.  In fact that's exactly what we're doing but with
+ * the ubicom32 instruction set we can do the inner load and add with two
+ * instructions whereas generating both the atomic result and the "ret"
+ * result requires three instructions.  The second add is generally only as
+ * costly as a move instruction and in cases where we compare the result
+ * with a constant the compiler can fold two constant values and do a
+ * single instruction, thus saving an instruction overall!
+ *
+ * At the worst we save one instruction inside the atomic lock.
+ */
+static inline int __atomic_add_return(int i, atomic_t *v)
+{
+	int ret;
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	ret = vt->counter;
+	vt->counter = ret + i;
+	__atomic_lock_release();
+
+	return ret + i;
+}
+
+/*
+ * __atomic_sub_return()
+ * 	Subtract i from v and return the result.
+ *
+ * The implementation here looks rather odd because we appear to be doing
+ * the subtraction twice.  In fact that's exactly what we're doing but with
+ * the ubicom32 instruction set we can do the inner load and sub with two
+ * instructions whereas generating both the atomic result and the "ret"
+ * result requires three instructions.  The second sub is generally only as
+ * costly as a move instruction and in cases where we compare the result
+ * with a constant the compiler can fold two constant values and do a
+ * single instruction, thus saving an instruction overall!
+ *
+ * At the worst we save one instruction inside the atomic lock.
+ */
+static inline int __atomic_sub_return(int i, atomic_t *v)
+{
+	int ret;
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	ret = vt->counter;
+	vt->counter = ret - i;
+	__atomic_lock_release();
+
+	return ret - i;
+}
+
+/*
+ * PUBLIC API FOR ATOMIC!
+ */
+#define atomic_add(i,v)	(__atomic_add( ((int)i),(v)))
+#define atomic_sub(i,v)	(__atomic_sub( ((int)i),(v)))
+#define atomic_inc(v)	(__atomic_add(   1,(v)))
+#define atomic_dec(v)	(__atomic_sub(   1,(v)))
+#define atomic_add_return(i,v)	(__atomic_add_return( ((int)i),(v)))
+#define atomic_sub_return(i,v)	(__atomic_sub_return( ((int)i),(v)))
+#define atomic_inc_return(v)	(__atomic_add_return(   1,(v)))
+#define atomic_dec_return(v)	(__atomic_sub_return(   1,(v)))
+#define atomic_inc_and_test(v)	(atomic_inc_return(v) == 0)
+#define atomic_dec_and_test(v)	(atomic_dec_return(v) == 0)
+#define atomic_add_negative(a, v)	(atomic_add_return((a), (v)) < 0)
+#define atomic_sub_and_test(i,v)	(atomic_sub_return((i),(v)) == 0)
+
+/*
+ * atomic_read()
+ * 	Acquire the atomic lock and read the variable.
+ */
+static inline int atomic_read(const atomic_t *v)
+{
+	int ret;
+	const atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	ret = vt->counter;
+	__atomic_lock_release();
+
+	return ret;
+}
+
+/*
+ * atomic_set()
+ * 	Acquire the atomic lock and set the variable.
+ */
+static inline void atomic_set(atomic_t *v, int i)
+{
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	vt->counter = i;
+	__atomic_lock_release();
+}
+
+/*
+ * atomic_cmpxchg
+ * 	Acquire the atomic lock and exchange if current == old.
+ */
+static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
+{
+	int prev;
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	prev = vt->counter;
+	if (prev == old) {
+		vt->counter = new;
+	}
+	__atomic_lock_release();
+
+	return prev;
+}
+
+/*
+ * atomic_xchg()
+ * 	Acquire the atomic lock and exchange values.
+ */
+static inline int atomic_xchg(atomic_t *v, int new)
+{
+	int prev;
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	prev = vt->counter;
+	vt->counter = new;
+	__atomic_lock_release();
+
+	return prev;
+}
+
+/*
+ * atomic_add_unless()
+ * 	Acquire the atomic lock and add a unless the value is u.
+ */
+static inline int atomic_add_unless(atomic_t *v, int a, int u)
+{
+	int prev;
+	atomic_t *vt = v;
+
+	__atomic_lock_acquire();
+	prev = vt->counter;
+	if (prev != u) {
+		vt->counter += a;
+		__atomic_lock_release();
+		return 1;
+	}
+
+	__atomic_lock_release();
+	return 0;
+}
+
+#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+
+#include <asm-generic/atomic.h>
+
+/* 
+ * The following is not a real function.  The compiler should remove the function
+ * call as long as the user does not pass in a size that __xchg and __cmpxchg
+ * are not prepared for.  If the user does pass in an unknown size, the user
+ * will get a link time error.
+ *
+ * The no return is to prevent a compiler error that can occur when dealing with
+ * uninitialized variables. Given that the function doesn't exist there is no
+ * net effect (and if it did it would not return).
+ */
+extern void __xchg_called_with_bad_pointer(void) __attribute__((noreturn));
+
+/*
+ * __xchg()
+ *	Xchange *ptr for x atomically.
+ *
+ * Must be both locally atomic and atomic on SMP. Ubicom32 does not have an
+ * atomic exchange instruction so we use the global atomic_lock.
+ */
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	unsigned long ret;
+
+	__atomic_lock_acquire();
+
+	switch (size) {
+	case 1:
+		ret = *(volatile unsigned char *)ptr;
+		*(volatile unsigned char *)ptr = x;
+		break;
+
+	case 2:
+		ret = *(volatile unsigned short *)ptr;
+		*(volatile unsigned short *)ptr = x;
+		break;
+
+	case 4:
+		ret = *(volatile unsigned int *)ptr;
+		*(volatile unsigned int *)ptr = x;
+		break;
+
+	default:
+		__xchg_called_with_bad_pointer();
+		break;
+	}
+	__atomic_lock_release();
+	return ret;
+}
+
+#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+
+/*
+ * __cmpxchg()
+ *	Compare and Xchange *ptr for x atomically.
+ *
+ * Must be both locally atomic and atomic on SMP. Ubicom32 does not have an
+ * atomic exchange instruction so we use the global atomic_lock.
+ */
+static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old, unsigned long next, int size)
+{
+	unsigned long prev;
+
+	__atomic_lock_acquire();
+	switch (size) {
+	case 1: 
+		prev = *(u8 *)ptr;
+		if (prev == old) {
+			*(u8 *)ptr = (u8)next;
+		}
+		break;
+
+	case 2: 
+		prev = *(u16 *)ptr;
+		if (prev == old) {
+			*(u16 *)ptr = (u16)next;
+		}
+		break;
+
+	case 4: 
+		prev = *(u32 *)ptr;
+		if (prev == old) {
+			*(u32 *)ptr = (u32)next;
+		}
+		break;
+
+	default:
+		__xchg_called_with_bad_pointer();
+		break;
+	}
+	__atomic_lock_release();
+	return prev;
+}
+
+/*
+ * cmpxchg_local and cmpxchg64_local are atomic wrt current CPU. Always make
+ * them available.
+ */
+#define cmpxchg_local(ptr, o, n) \
+	((__typeof__(*(ptr)))__cmpxchg((ptr), (unsigned long)(o), (unsigned long)(n), sizeof(*(ptr))))
+
+#define cmpxchg(ptr, o, n) __cmpxchg((ptr), (o), (n), sizeof(*(ptr)))
+
+#define smp_mb__before_atomic_inc() asm volatile ("" : : : "memory")
+#define smp_mb__after_atomic_inc() asm volatile ("" : : : "memory")
+#define smp_mb__before_atomic_dec() asm volatile ("" : : : "memory")
+#define smp_mb__after_atomic_dec() asm volatile ("" : : : "memory")
+
+#endif /* _ASM_UBICOM32_ATOMIC_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/audio_tio.h linux-2.6.28.10/arch/ubicom32/include/asm/audio_tio.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/audio_tio.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/audio_tio.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,124 @@
+/*
+ * arch/ubicom32/include/asm/audio_tio.h
+ *	AudioTIO include file
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _AUDIO_TIO_H
+#define _AUDIO_TIO_H
+
+#include <asm/devtree.h>
+#include <asm/ubi32-pcm.h>
+
+#define UBI32_AUDIO_INT_FLAG_MORE_SAMPLES 0x00000001
+#define UBI32_AUDIO_INT_FLAG_COMMAND      0x00000002
+
+/*
+ * Commands the Primary OS sends to the audio device
+ */
+enum ubi32_audio_command {
+	UBI32_AUDIO_CMD_NONE,
+	UBI32_AUDIO_CMD_START,
+	UBI32_AUDIO_CMD_STOP,
+	UBI32_AUDIO_CMD_PAUSE,
+	UBI32_AUDIO_CMD_RESUME,
+	UBI32_AUDIO_CMD_MUTE,
+	UBI32_AUDIO_CMD_UNMUTE,
+	UBI32_AUDIO_CMD_SETUP,
+	UBI32_AUDIO_CMD_ENABLE,
+	UBI32_AUDIO_CMD_DISABLE,
+};
+
+/*
+ * Flag bits passed in the registers
+ */
+#define UBI32_CMD_SETUP_FLAG_LE		(1 << 0)	/* Use Little Endian Mode */
+
+/*
+ * Status bits that audio device can set to indicate reason
+ * for interrupting the Primary OS
+ */
+#define UBI32_AUDIO_STATUS_PLAY_DMA0_REQUEST (1 << 0) /* Audio device needs samples in DMA0 for playback */
+#define UBI32_AUDIO_STATUS_PLAY_DMA1_REQUEST (1 << 1) /* Audio device needs samples in DMA1 for playback */
+
+struct ubi32_audio_dma {
+	/*
+	 * NOTE: The active flag shall only be SET by the producer and CLEARED
+	 * by the consumer, NEVER the other way around.  For playback, the
+	 * Primary OS sets this flag and ipAudioTIO clears it.
+	 *
+	 * The producer shall not modify the ptr or ctr fields when the transfer
+	 * is marked as active, as these are used by the consumer to do the
+	 * transfer.
+	 */
+	volatile uint32_t active; 		/* Nonzero if data in ptr/ctr ready to be transferred */
+	//volatile u32_t active; 		/* Nonzero if data in ptr/ctr ready to be transferred */
+	volatile void *ptr;		/* Pointer to data to be transferred */
+	volatile uint32_t ctr; 	/* Counter: number of data units to transfer */
+	//volatile u32_t ctr; 		/* Counter: number of data units to transfer */
+};
+
+#define AUDIOTIONODE_CAP_BE	(1 << 0)
+#define AUDIOTIONODE_CAP_LE	(1 << 1)
+
+/*
+ * Resource indices used to access IRQs via platform_get_resource
+ */
+#define AUDIOTIO_MEM_RESOURCE		0
+#define AUDIOTIO_TX_IRQ_RESOURCE	0
+#define AUDIOTIO_RX_IRQ_RESOURCE	1
+
+#define AUDIOTIONODE_VERSION	5
+struct audiotionode {
+	struct devtree_node dn;
+	uint32_t version;				/* Version of this node */
+	struct audiotioregs *regs;
+};
+
+#define AUDIOTIOREGS_VERSION	3
+struct audiotioregs {
+	uint32_t version;
+	uint32_t caps;					/* Capabilities of the driver */
+	u32_t *sample_rates;				/* Sample Rates supported by this driver */
+	u32_t n_sample_rates;				/* Number of sample rates supported by this driver */
+	u32_t channel_mask;				/* The channel configs supported by this driver (bit 1 = 1 channel, etc) */
+	volatile uint32_t int_flags;			/* Reason for interrupting audio device */
+	volatile enum ubi32_audio_command command;	/* Command from Primary OS */
+	volatile uint32_t flags;			/* Flag bits for this command */
+	volatile uint32_t channels;			/* Number of channels in stream */
+	volatile uint32_t sample_rate;			/* Sample rate */
+	volatile uint32_t status;			/* Status bits sent from AudioTIO to Primary OS */
+	volatile void *current_read_pos;		/* Position of next sample to be removed from Primary OS sample buffer */
+
+	/*
+	 * These are the transfer requests.  They are used in alternating
+	 * order so that when ipAudioTIO is processing one request, the
+	 * Primary OS can fill in the other one.
+	 *
+	 * NOTE: The active bit shall always be SET by the producer and
+	 * CLEARED by the consumer, NEVER the other way around.
+	 */
+	struct ubi32_audio_dma playback_xfer_requests[2];
+};
+
+extern struct platform_device * __init audio_tio_alloc(const char *driver_name, const char *node_name, int priv_size);
+
+#define audio_tio_priv(pdev) (((struct ubi32pcm_platform_data *)(((struct platform_device *)(pdev))->dev.platform_data))->priv_data)
+#endif
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/auxvec.h linux-2.6.28.10/arch/ubicom32/include/asm/auxvec.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/auxvec.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/auxvec.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,32 @@
+/*
+ * arch/ubicom32/include/asm/auxvec.h
+ *   Symbolic values for the entries in the auxiliary table
+ *   put on the initial stack.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_AUXVEC_H
+#define _ASM_UBICOM32_AUXVEC_H
+
+#endif /* _ASM_UBICOM32_AUXVEC_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/bitops.h linux-2.6.28.10/arch/ubicom32/include/asm/bitops.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/bitops.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/bitops.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,171 @@
+/*
+ * arch/ubicom32/include/asm/bitops.h
+ *   Bit manipulation definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_BITOPS_H
+#define _ASM_UBICOM32_BITOPS_H
+
+/*
+ * Copyright 1992, Linus Torvalds.
+ */
+
+#include <linux/compiler.h>
+#include <asm/byteorder.h>	/* swab32 */
+
+#ifdef __KERNEL__
+
+#ifndef _LINUX_BITOPS_H
+#error only <linux/bitops.h> can be included directly
+#endif
+
+#include <asm-generic/bitops/ffs.h>
+#include <asm-generic/bitops/__ffs.h>
+
+#include <asm-generic/bitops/sched.h>
+#include <asm-generic/bitops/ffz.h>
+
+#include <asm/ubicom32-common.h>
+
+static inline void set_bit(int bit, volatile unsigned long *p)
+{
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	__atomic_lock_acquire();
+	*p |= mask;
+	__atomic_lock_release();
+}
+
+static inline void clear_bit(int bit, volatile unsigned long *p)
+{
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	__atomic_lock_acquire();
+	*p &= ~mask;
+	__atomic_lock_release();
+}
+
+/*
+ * clear_bit() doesn't provide any barrier for the compiler.
+ */
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+static inline void change_bit(int bit, volatile unsigned long *p)
+{
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	__atomic_lock_acquire();
+	*p ^= mask;
+	__atomic_lock_release();
+}
+
+static inline int test_and_set_bit(int bit, volatile unsigned long *p)
+{
+	unsigned int res;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	__atomic_lock_acquire();
+	res = *p;
+	*p = res | mask;
+	__atomic_lock_release();
+
+	return res & mask;
+}
+
+static inline int test_and_clear_bit(int bit, volatile unsigned long *p)
+{
+	unsigned int res;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	__atomic_lock_acquire();
+	res = *p;
+	*p = res & ~mask;
+	__atomic_lock_release();
+
+	return res & mask;
+}
+
+static inline int test_and_change_bit(int bit, volatile unsigned long *p)
+{
+	unsigned int res;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	__atomic_lock_acquire();
+	res = *p;
+	*p = res ^ mask;
+	__atomic_lock_release();
+
+	return res & mask;
+}
+
+#include <asm-generic/bitops/non-atomic.h>
+
+/*
+ * This routine doesn't need to be atomic.
+ */
+static inline int __constant_test_bit(int nr, const volatile unsigned long *addr)
+{
+	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) addr)[nr >> 5])) != 0;
+}
+
+static inline int __test_bit(int nr, const volatile unsigned long *addr)
+{
+	int 	* a = (int *) addr;
+	int	mask;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	return ((mask & *a) != 0);
+}
+
+#define test_bit(nr,addr) (__builtin_constant_p(nr) ?  __constant_test_bit((nr),(addr)) :  __test_bit((nr),(addr)))
+
+#include <asm-generic/bitops/find.h>
+#include <asm-generic/bitops/hweight.h>
+#include <asm-generic/bitops/lock.h>
+
+#include <asm-generic/bitops/ext2-non-atomic.h>
+#include <asm-generic/bitops/ext2-atomic.h>
+#include <asm-generic/bitops/minix.h>
+
+#endif /* __KERNEL__ */
+
+#include <asm-generic/bitops/fls.h>
+#include <asm-generic/bitops/fls64.h>
+
+#endif /* _ASM_UBICOM32_BITOPS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/board.h linux-2.6.28.10/arch/ubicom32/include/asm/board.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/board.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/board.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * arch/ubicom32/include/asm/board.h
+ *   Board init and revision definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_BOARD_H
+#define _ASM_UBICOM32_BOARD_H
+
+extern const char *board_get_revision(void);
+extern void __init board_init(void);
+
+#endif /* _ASM_UBICOM32_BOARD_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/bootargs.h linux-2.6.28.10/arch/ubicom32/include/asm/bootargs.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/bootargs.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/bootargs.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * arch/ubicom32/include/asm/bootargs.h
+ *   Kernel command line via the devtree API.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_BOOTARGS_H
+#define _ASM_UBICOM32_BOOTARGS_H
+
+extern const char *bootargs_get_cmdline(void);
+extern void __init bootargs_init(void);
+
+#endif /* _ASM_UBICOM32_BOOTARGS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/bootinfo.h linux-2.6.28.10/arch/ubicom32/include/asm/bootinfo.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/bootinfo.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/bootinfo.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * arch/ubicom32/include/asm/bootinfo.h
+ *   Definitions of firmware boot parameters passed to the kernel.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_BOOTINFO_H
+#define _ASM_UBICOM32_BOOTINFO_H
+
+/* Nothing for ubicom32 */
+
+#endif /* _ASM_UBICOM32_BOOTINFO_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/bug.h linux-2.6.28.10/arch/ubicom32/include/asm/bug.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/bug.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/bug.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,53 @@
+/*
+ * arch/ubicom32/include/asm/bug.h
+ *   Generic bug.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_BUG_H
+#define _ASM_UBICOM32_BUG_H
+
+#include <linux/kernel.h>
+#include <asm/thread.h>
+
+#if defined(CONFIG_STOP_ON_BUG)
+/*
+ *  __BUG_ON()
+ *  	Stall all threads to enable debugging.
+ */
+static inline void __BUG_ON(unsigned long c)
+{
+	if (unlikely(c)) {
+		THREAD_STALL;
+	}
+	return;
+}
+
+#define BUG_ON(c) __BUG_ON((unsigned long)(c))
+#define HAVE_ARCH_BUG_ON
+#endif
+
+#include <asm-generic/bug.h>
+
+#endif /* _ASM_UBICOM32_BUG_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/bugs.h linux-2.6.28.10/arch/ubicom32/include/asm/bugs.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/bugs.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/bugs.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * arch/ubicom32/include/asm/bugs.h
+ *   Definition of check_bugs() for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 1994  Linus Torvalds
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+/*
+ * This is included by init/main.c to check for architecture-dependent bugs.
+ *
+ * Needs:
+ *	void check_bugs(void);
+ */
+
+#ifndef _ASM_UBICOM32_BUGS_H
+#define _ASM_UBICOM32_BUGS_H
+
+static void check_bugs(void)
+{
+}
+
+#endif /* _ASM_UBICOM32_BUGS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/byteorder.h linux-2.6.28.10/arch/ubicom32/include/asm/byteorder.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/byteorder.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/byteorder.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,48 @@
+/*
+ * arch/ubicom32/include/asm/byteorder.h
+ *   Byte order swapping utility routines.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_BYTEORDER_H
+#define _ASM_UBICOM32_BYTEORDER_H
+
+#include <linux/types.h>
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#if defined(IP7000) || defined(IP7000_REV2)
+
+#define __arch__swab16 __builtin_ubicom32_swapb_2
+#define __arch__swab32 __builtin_ubicom32_swapb_4
+
+#endif /* IP7000 */
+
+#include <linux/byteorder/big_endian.h>
+
+#endif /* _ASM_UBICOM32_BYTEORDER_H */
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/cachectl.h linux-2.6.28.10/arch/ubicom32/include/asm/cachectl.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/cachectl.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/cachectl.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,39 @@
+/*
+ * arch/ubicom32/include/asm/cachectl.h
+ *   Ubicom32 cache control definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_CACHECTL_H
+#define _ASM_UBICOM32_CACHECTL_H
+
+#include <asm/ip5000.h>
+
+/*
+ * mem_cache_control()
+ *	Special cache control operation
+ */
+extern void mem_cache_control(unsigned long cc, unsigned long begin_addr, unsigned long end_addr, unsigned long op);
+
+#endif /* _ASM_UBICOM32_CACHECTL_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/cacheflush.h linux-2.6.28.10/arch/ubicom32/include/asm/cacheflush.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/cacheflush.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/cacheflush.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,104 @@
+/*
+ * arch/ubicom32/include/asm/cacheflush.h
+ *   Cache flushing definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_CACHEFLUSH_H
+#define _ASM_UBICOM32_CACHEFLUSH_H
+
+/*
+ * (C) Copyright 2000-2004, Greg Ungerer <gerg@snapgear.com>
+ */
+#include <linux/mm.h>
+#include <asm/cachectl.h>
+#include <asm/ip5000.h>
+
+#define flush_cache_all()			__flush_cache_all()
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_dup_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	__flush_cache_all()
+#define flush_cache_page(vma, vmaddr)		do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+
+#define flush_dcache_range(start, end)					\
+do {									\
+	/* Flush the data cache and invalidate the I cache. */		\
+	local_irq_disable();						\
+	mem_cache_control(DCCR_BASE, start, end, CCR_CTRL_FLUSH_ADDR);	\
+	mem_cache_control(ICCR_BASE, start, end, CCR_CTRL_INV_ADDR);	\
+	local_irq_enable();						\
+} while (0)
+
+#define flush_icache_range(start, end)					\
+do {									\
+	/* Flush the data cache and invalidate the I cache. */		\
+	local_irq_disable();						\
+	mem_cache_control(DCCR_BASE, start, end, CCR_CTRL_FLUSH_ADDR);	\
+	mem_cache_control(ICCR_BASE, start, end, CCR_CTRL_INV_ADDR);	\
+	local_irq_enable();						\
+} while (0)
+
+#define flush_icache_page(vma,pg)		do { } while (0)
+#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
+#define flush_cache_vmap(start, end)		do { } while (0)
+#define flush_cache_vunmap(start, end)		do { } while (0)
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+
+/*
+ * Cache handling for IP5000
+ */
+extern inline void mem_cache_invalidate_all(unsigned long cc)
+{
+	asm volatile (
+	"	bset	"D(CCR_CTRL)"(%0), "D(CCR_CTRL)"(%0), #"D(CCR_CTRL_RESET)"	\n\t"
+	"	nop									\n\t"
+	"	bclr	"D(CCR_CTRL)"(%0), "D(CCR_CTRL)"(%0), #"D(CCR_CTRL_RESET)"	\n\t"
+	"	pipe_flush 0								\n\t"
+		:
+		: "a"(cc)
+		: "cc"
+	);
+}
+
+static inline void __flush_cache_all(void)
+{
+	/*
+	 * Flush Icache
+	 */
+	mem_cache_invalidate_all(ICCR_BASE);
+
+	/*
+	 * Flush Dcache
+	 */
+	mem_cache_invalidate_all(DCCR_BASE);
+}
+
+#endif /* _ASM_UBICOM32_CACHEFLUSH_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/cache.h linux-2.6.28.10/arch/ubicom32/include/asm/cache.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/cache.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/cache.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,40 @@
+/*
+ * arch/ubicom32/include/asm/cache.h
+ *   Cache line definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_CACHE_H
+#define _ASM_UBICOM32_CACHE_H
+
+/*
+ * bytes per L1 cache line
+ */
+#define L1_CACHE_SHIFT  5
+#define L1_CACHE_BYTES  (1 << L1_CACHE_SHIFT)
+
+#define __cacheline_aligned
+#define ____cacheline_aligned
+
+#endif /* _ASM_UBICOM32_CACHE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/checksum.h linux-2.6.28.10/arch/ubicom32/include/asm/checksum.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/checksum.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/checksum.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,149 @@
+/*
+ * arch/ubicom32/include/asm/checksum.h
+ *   Checksum utilities for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_CHECKSUM_H
+#define _ASM_UBICOM32_CHECKSUM_H
+
+#include <linux/in6.h>
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+__wsum csum_partial(const void *buff, int len, __wsum sum);
+
+/*
+ * the same as csum_partial, but copies from src while it
+ * checksums
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+__wsum csum_partial_copy_nocheck(const void *src, void *dst,
+	int len, __wsum sum);
+
+
+/*
+ * the same as csum_partial_copy, but copies from user space.
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+extern __wsum csum_partial_copy_from_user(const void __user *src,
+	void *dst, int len, __wsum sum, int *csum_err);
+
+__sum16 ip_fast_csum(const void *iph, unsigned int ihl);
+
+/*
+ *	Fold a partial checksum
+ */
+
+static inline __sum16 csum_fold(__wsum sum)
+{
+	asm volatile (
+	"	lsr.4	d15, %0, #16	\n\t"
+	"	bfextu	%0, %0, #16	\n\t"
+	"	add.4	%0, d15, %0	\n\t"
+	"	lsr.4	d15, %0, #16	\n\t"
+	"	bfextu	%0, %0, #16	\n\t"
+	"	add.4	%0, d15, %0	\n\t"
+		: "=&d" (sum)
+		: "0"(sum)
+		: "d15"
+	);
+	return (__force __sum16)~sum;
+}
+
+
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+
+static inline __wsum
+csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len,
+		  unsigned short proto, __wsum sum)
+{
+	asm volatile (
+	"	add.4	%0, %2, %0	\n\t"
+	"	addc	%0, %3, %0	\n\t"
+	"	addc	%0, %4, %0	\n\t"
+	"	addc	%0, %5, %0	\n\t"
+	"	addc	%0, #0, %0	\n\t"
+		: "=&d" (sum)
+		: "0"(sum), "r" (saddr), "r" (daddr), "r" (len), "r"(proto)
+	);
+	return sum;
+}
+
+static inline __sum16
+csum_tcpudp_magic(__be32 saddr, __be32 daddr, unsigned short len,
+		  unsigned short proto, __wsum sum)
+{
+	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+extern __sum16 ip_compute_csum(const void *buff, int len);
+
+#define _HAVE_ARCH_IPV6_CSUM
+
+static __inline__ __sum16
+csum_ipv6_magic(const struct in6_addr *saddr, const struct in6_addr *daddr,
+		__u32 len, unsigned short proto, __wsum sum)
+{
+	asm volatile (
+	"	add.4	%0, 0(%2), %0	\n\t"
+	"	addc	%0, 4(%2), %0	\n\t"
+	"	addc	%0, 8(%2), %0	\n\t"
+	"	addc	%0, 12(%2), %0	\n\t"
+	"	addc	%0, 0(%3), %0	\n\t"
+	"	addc	%0, 4(%3), %0	\n\t"
+	"	addc	%0, 8(%3), %0	\n\t"
+	"	addc	%0, 12(%3), %0	\n\t"
+	"	addc	%0, %4, %0	\n\t"
+	"	addc	%0, #0, %0	\n\t"
+		: "=&d" (sum)
+		: "0" (sum), "a" (saddr), "a" (daddr), "d" (len + proto)
+	);
+	return csum_fold(sum);
+}
+
+#endif /* _ASM_UBICOM32_CHECKSUM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/cpu.h linux-2.6.28.10/arch/ubicom32/include/asm/cpu.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/cpu.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/cpu.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,45 @@
+/*
+ * arch/ubicom32/include/asm/cpu.h
+ *   CPU definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2004-2005 ARM Ltd.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_CPU_H
+#define _ASM_UBICOM32_CPU_H
+
+#include <linux/percpu.h>
+
+struct cpuinfo_ubicom32 {
+	unsigned long tid;			/* Hardware thread number */
+
+#ifdef CONFIG_SMP
+	volatile unsigned long ipi_pending;	/* Bit map of operations to execute */
+	unsigned long ipi_count;		/* Number of IPI(s) taken on this cpu */
+#endif
+};
+
+DECLARE_PER_CPU(struct cpuinfo_ubicom32, cpu_data);
+
+#endif /* _ASM_UBICOM32_CPU_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/cputime.h linux-2.6.28.10/arch/ubicom32/include/asm/cputime.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/cputime.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/cputime.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/cputime.h
+ *   Generic cputime.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_CPUTIME_H
+#define _ASM_UBICOM32_CPUTIME_H
+
+#include <asm-generic/cputime.h>
+
+#endif /* _ASM_UBICOM32_CPUTIME_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/current.h linux-2.6.28.10/arch/ubicom32/include/asm/current.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/current.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/current.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * arch/ubicom32/include/asm/current.h
+ *   Definition of get_current() for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * (C) Copyright 2000, Lineo, David McCullough <davidm@uclinux.org>
+ * (C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_CURRENT_H
+#define _ASM_UBICOM32_CURRENT_H
+
+#include <linux/thread_info.h>
+
+struct task_struct;
+
+static inline struct task_struct *get_current(void)
+{
+	return(current_thread_info()->task);
+}
+
+#define	current	get_current()
+
+#endif /* _ASM_UBICOM32_CURRENT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/delay.h linux-2.6.28.10/arch/ubicom32/include/asm/delay.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/delay.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/delay.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,75 @@
+/*
+ * arch/ubicom32/include/asm/delay.h
+ *   Definition of delay routines for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_DELAY_H
+#define _ASM_UBICOM32_DELAY_H
+
+#include <asm/param.h>
+#include <asm/ip5000.h>
+
+static inline void __delay(unsigned long loops)
+{
+	if (loops == 0) {
+		return;
+	}
+
+	asm volatile (
+	"1:	add.4	%0, #-1, %0		\n\t"
+	"	jmpne.t	1b			\n\t"
+	: "+d" (loops)
+	);
+}
+
+/*
+ *	Ubicom32 processor uses fixed 12MHz external OSC.
+ *	So we use that as reference to count 12 cycles/us
+ */
+
+extern unsigned long loops_per_jiffy;
+
+static inline void _udelay(unsigned long usecs)
+{
+#if defined(CONFIG_UBICOM32_V4) || defined(CONFIG_UBICOM32_V3)
+	asm volatile (
+		"	add.4		d15, 0(%0), %1			\n\t"
+		"	sub.4		#0, 0(%0), d15			\n\t"
+		"	jmpmi.w.f	.-4				\n\t"
+		:
+		: "a"(TIMER_BASE + TIMER_MPTVAL), "d"(usecs * (12000000/1000000))
+		: "d15"
+	);
+#else
+	BUG();
+#endif
+}
+
+/*
+ *	Moved the udelay() function into library code, no longer inlined.
+ */
+extern void udelay(unsigned long usecs);
+
+#endif /* _ASM_UBICOM32_DELAY_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/device.h linux-2.6.28.10/arch/ubicom32/include/asm/device.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/device.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/device.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,35 @@
+/*
+ * arch/ubicom32/include/asm/device.h
+ *   Generic device.h for Ubicom32 architecture.
+ *
+ *   Used for arch specific extensions to struct device
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_DEVICE_H
+#define _ASM_UBICOM32_DEVICE_H
+
+#include <asm-generic/device.h>
+
+#endif /* _ASM_UBICOM32_DEVICE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/devtree.h linux-2.6.28.10/arch/ubicom32/include/asm/devtree.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/devtree.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/devtree.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,52 @@
+/*
+ * arch/ubicom32/include/asm/devtree.h
+ *   Device Tree Header File (Shared between ultra and the Host OS)
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_DEVTREE_H
+#define _ASM_UBICOM32_DEVTREE_H
+
+#define DEVTREE_MAX_NAME 32
+#define DEVTREE_IRQ_NONE 0xff
+#define DEVTREE_IRQ_DONTCARE 0xff
+#define DEVTREE_NODE_MAGIC 0x10203040
+
+struct devtree_node {
+	struct devtree_node *next;
+	unsigned char sendirq;
+	unsigned char recvirq;
+	char name[DEVTREE_MAX_NAME];
+	unsigned int magic;
+};
+
+extern struct devtree_node *devtree;
+extern struct devtree_node *devtree_find_by_irq(uint8_t sendirq, uint8_t recvirq);
+extern struct devtree_node *devtree_find_node(const char *str);
+extern struct devtree_node *devtree_find_next(struct devtree_node **cur);
+extern int devtree_irq(struct devtree_node *dn, unsigned char *sendirq, unsigned char *recvirq);
+extern void devtree_print(void);
+
+#endif /* _ASM_UBICOM32_DEVTREE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/div64.h linux-2.6.28.10/arch/ubicom32/include/asm/div64.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/div64.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/div64.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/div64.h
+ *   Generic div64.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_DIV64_H
+#define _ASM_UBICOM32_DIV64_H
+
+#include <asm-generic/div64.h>
+
+#endif /* _ASM_UBICOM32_DIV64_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/dma.h linux-2.6.28.10/arch/ubicom32/include/asm/dma.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/dma.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/dma.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * arch/ubicom32/include/asm/dma.h
+ *   DMA definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_DMA_H
+#define _ASM_UBICOM32_DMA_H
+
+/* Nothing so far */
+#define MAX_DMA_ADDRESS 0x00	/* This is quite suspicious */
+
+#endif /* _ASM_UBICOM32_DMA_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/dma-mapping.h linux-2.6.28.10/arch/ubicom32/include/asm/dma-mapping.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/dma-mapping.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/dma-mapping.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * arch/ubicom32/include/asm/dma-mapping.h
+ *   Generic dma-mapping.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_DMA_MAPPING_H
+#define _ASM_UBICOM32_DMA_MAPPING_H
+
+#include <linux/scatterlist.h>
+#include <asm-generic/dma-mapping.h>
+
+#endif /* _ASM_UBICOM32_DMA_MAPPING_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/elf.h linux-2.6.28.10/arch/ubicom32/include/asm/elf.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/elf.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/elf.h	2009-08-18 22:35:42.571202890 +0300
@@ -0,0 +1,167 @@
+/*
+ * arch/ubicom32/include/asm/elf.h
+ *   Definitions for elf executable format for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_ELF_H
+#define _ASM_UBICOM32_ELF_H
+
+/*
+ * ELF register definitions..
+ */
+
+#include <asm/ptrace.h>
+#include <asm/user.h>
+
+/*
+ * Processor specific flags for the ELF header e_flags field.
+ */
+#define EF_UBICOM32_V3		0x00000001	/* -fmarch=ubicom32v3 */
+#define EF_UBICOM32_V4		0x00000002	/* -fmarch=ubicom32v4 */
+#define EF_UBICOM32_PIC		0x80000000	/* -fpic */
+#define EF_UBICOM32_FDPIC	0x40000000	/* -mfdpic */
+
+/*
+ * Ubicom32 ELF relocation types
+ */
+#define R_UBICOM32_NONE			0
+#define R_UBICOM32_16			1
+#define R_UBICOM32_32			2
+#define R_UBICOM32_LO16			3
+#define R_UBICOM32_HI16			4
+#define R_UBICOM32_21_PCREL		5
+#define R_UBICOM32_24_PCREL		6
+#define R_UBICOM32_HI24			7
+#define R_UBICOM32_LO7_S		8
+#define R_UBICOM32_LO7_2_S		9
+#define R_UBICOM32_LO7_4_S		10
+#define R_UBICOM32_LO7_D		11
+#define R_UBICOM32_LO7_2_D		12
+#define R_UBICOM32_LO7_4_D		13
+#define R_UBICOM32_32_HARVARD		14
+#define R_UBICOM32_LO7_CALLI		15
+#define R_UBICOM32_LO16_CALLI		16
+#define R_UBICOM32_GOT_HI24		17
+#define R_UBICOM32_GOT_LO7_S		18
+#define R_UBICOM32_GOT_LO7_2_S		19
+#define R_UBICOM32_GOT_LO7_4_S		20
+#define R_UBICOM32_GOT_LO7_D		21
+#define R_UBICOM32_GOT_LO7_2_D		22
+#define R_UBICOM32_GOT_LO7_4_D		23
+#define R_UBICOM32_FUNCDESC_GOT_HI24    24
+#define R_UBICOM32_FUNCDESC_GOT_LO7_S   25
+#define R_UBICOM32_FUNCDESC_GOT_LO7_2_S 26
+#define R_UBICOM32_FUNCDESC_GOT_LO7_4_S 27
+#define R_UBICOM32_FUNCDESC_GOT_LO7_D   28
+#define R_UBICOM32_FUNCDESC_GOT_LO7_2_D 29
+#define R_UBICOM32_FUNCDESC_GOT_LO7_4_D 30
+#define R_UBICOM32_GOT_LO7_CALLI        31
+#define R_UBICOM32_FUNCDESC_GOT_LO7_CALLI 32
+#define R_UBICOM32_FUNCDESC_VALUE       33
+#define R_UBICOM32_FUNCDESC             34
+#define R_UBICOM32_GOTOFFSET_LO         35
+#define R_UBICOM32_GOTOFFSET_HI         36
+#define R_UBICOM32_FUNCDESC_GOTOFFSET_LO 37
+#define R_UBICOM32_FUNCDESC_GOTOFFSET_HI 38
+#define R_UBICOM32_GNU_VTINHERIT        200
+#define R_UBICOM32_GNU_VTENTRY          201
+
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG (sizeof(struct pt_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct user_ubicom32fp_struct elf_fpregset_t;
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) ((x)->e_machine == EM_UBICOM32)
+
+#define elf_check_fdpic(x) ((x)->e_flags & EF_UBICOM32_FDPIC)
+
+#define elf_check_const_displacement(x) ((x)->e_flags & EF_UBICOM32_PIC)
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#define ELF_DATA	ELFDATA2MSB
+#define ELF_ARCH	EM_UBICOM32
+
+/* For SVR4/m68k the function pointer to be registered with `atexit' is
+   passed in %a1.  Although my copy of the ABI has no such statement, it
+   is actually used on ASV.  */
+#define ELF_PLAT_INIT(_r, load_addr)	_r->a1 = 0
+
+#define ELF_FDPIC_PLAT_INIT(_regs, _exec_map_addr, _interp_map_addr,	\
+			    _dynamic_addr)				\
+	do {								\
+		_regs->dn[1]	= _exec_map_addr;			\
+		_regs->dn[2]	= _interp_map_addr;			\
+		_regs->dn[3]	= _dynamic_addr;			\
+		_regs->an[1]	= 0; /* dl_fini will be set by ldso */	\
+	} while (0)
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	4096
+
+#ifdef __KERNEL__
+#ifdef CONFIG_UBICOM32_V4
+#define ELF_FDPIC_CORE_EFLAGS	(EF_UBICOM32_FDPIC | EF_UBICOM32_V4)
+#elif defined CONFIG_UBICOM32_V3
+#define ELF_FDPIC_CORE_EFLAGS	(EF_UBICOM32_FDPIC | EF_UBICOM32_V3)
+#else
+#error Unknown/Unsupported ubicom32 architecture.
+#endif
+#endif
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+#define ELF_ET_DYN_BASE         0xD0000000UL
+
+/*
+ * For Ubicom32, the elf_gregset_t and struct pt_regs are the same size
+ * data structure so a copy is performed instead of providing the
+ * ELF_CORE_COPY_REGS macro.
+ */
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this cpu supports.  */
+
+#define ELF_HWCAP	(0)
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.  */
+
+#define ELF_PLATFORM  (NULL)
+
+#define SET_PERSONALITY(ex, ibcs2) set_personality((ibcs2)?PER_SVR4:PER_LINUX)
+
+#endif /* _ASM_UBICOM32_ELF_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/emergency-restart.h linux-2.6.28.10/arch/ubicom32/include/asm/emergency-restart.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/emergency-restart.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/emergency-restart.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/emergency-restart.h
+ *   Generic emergency-restart.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_EMERGENCY_RESTART_H
+#define _ASM_UBICOM32_EMERGENCY_RESTART_H
+
+#include <asm-generic/emergency-restart.h>
+
+#endif /* _ASM_UBICOM32_EMERGENCY_RESTART_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/entry.h linux-2.6.28.10/arch/ubicom32/include/asm/entry.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/entry.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/entry.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * arch/ubicom32/include/asm/entry.h
+ *   Entry register/stack definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_ENTRY_H
+#define _ASM_UBICOM32_ENTRY_H
+
+#include <asm/setup.h>
+#include <asm/page.h>
+
+#endif /* _ASM_UBICOM32_ENTRY_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/errno.h linux-2.6.28.10/arch/ubicom32/include/asm/errno.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/errno.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/errno.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/errno.h
+ *   Generic errno.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_ERRNO_H
+#define _ASM_UBICOM32_ERRNO_H
+
+#include <asm-generic/errno.h>
+
+#endif /* _ASM_UBICOM32_ERRNO_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/fb.h linux-2.6.28.10/arch/ubicom32/include/asm/fb.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/fb.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/fb.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,39 @@
+/*
+ * arch/ubicom32/include/asm/fb.h
+ *   Definition of fb_is_primary_device() for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_FB_H
+#define _ASM_UBICOM32_FB_H
+#include <linux/fb.h>
+
+#define fb_pgprotect(...) do {} while (0)
+
+static inline int fb_is_primary_device(struct fb_info *info)
+{
+	return 0;
+}
+
+#endif /* _ASM_UBICOM32_FB_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/fcntl.h linux-2.6.28.10/arch/ubicom32/include/asm/fcntl.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/fcntl.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/fcntl.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,38 @@
+/*
+ * arch/ubicom32/include/asm/fcntl.h
+ *   File control bit definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_FCNTL_H
+#define _ASM_UBICOM32_FCNTL_H
+
+#define O_DIRECTORY	040000	/* must be a directory */
+#define O_NOFOLLOW	0100000	/* don't follow links */
+#define O_DIRECT	0200000	/* direct disk access hint - currently ignored */
+#define O_LARGEFILE	0400000
+
+#include <asm-generic/fcntl.h>
+
+#endif /* _ASM_UBICOM32_FCNTL_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/flat.h linux-2.6.28.10/arch/ubicom32/include/asm/flat.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/flat.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/flat.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,73 @@
+/*
+ * arch/ubicom32/include/asm/flat.h
+ *   Definitions to support flat-format executables.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_FLAT_H
+#define _ASM_UBICOM32_FLAT_H
+
+#define ARCH_FLAT_ALIGN 0x80
+#define ARCH_FLAT_ALIGN_TEXT 1
+
+#define  R_UBICOM32_32		2
+#define  R_UBICOM32_HI24	7
+#define  R_UBICOM32_LO7_S	8
+#define  R_UBICOM32_LO7_2_S	9
+#define  R_UBICOM32_LO7_4_S	10
+#define  R_UBICOM32_LO7_D	11
+#define  R_UBICOM32_LO7_2_D	12
+#define  R_UBICOM32_LO7_4_D	13
+#define  R_UBICOM32_LO7_CALLI	15
+#define  R_UBICOM32_LO16_CALLI	16
+
+extern void ubicom32_flat_put_addr_at_rp(unsigned long *rp, u32_t val, u32_t rval, unsigned long  *p);
+extern unsigned long ubicom32_flat_get_addr_from_rp(unsigned long *rp, u32_t relval, u32_t flags, unsigned long *p);
+
+#define	flat_stack_align(sp)			/* nothing needed */
+#define	flat_argvp_envp_on_stack()		1
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
+#define	flat_get_addr_from_rp(rp, relval, flags, p)	(ubicom32_flat_get_addr_from_rp(rp, relval,flags, p))
+#define	flat_put_addr_at_rp(rp, val, relval)	do {ubicom32_flat_put_addr_at_rp(rp, val, relval, &persistent);} while(0)
+#define	flat_get_relocate_addr(rel)		((persistent) ? (persistent & 0x07ffffff) : (rel & 0x07ffffff))
+
+static inline int flat_set_persistent(unsigned int relval, unsigned long *p)
+{
+	if (*p) {
+		return 0;
+	} else {
+		if ((relval >> 27) != R_UBICOM32_32) {
+			/*
+			 * Something other than UBICOM32_32. The next entry has the relocation.
+			 */
+			*p = relval;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+#endif /* _ASM_UBICOM32_FLAT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/fpu.h linux-2.6.28.10/arch/ubicom32/include/asm/fpu.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/fpu.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/fpu.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,37 @@
+/*
+ * arch/ubicom32/include/asm/fpu.h
+ *   Floating point state definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_FPU_H
+#define _ASM_UBICOM32_FPU_H
+
+/*
+ * MAX floating point unit state size (FSAVE/FRESTORE)
+ */
+/* No FP unit present then... */
+#define FPSTATESIZE (2) /* dummy size */
+
+#endif /* _ASM_UBICOM32_FPU_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/futex.h linux-2.6.28.10/arch/ubicom32/include/asm/futex.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/futex.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/futex.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/futex.h
+ *   Generic futex.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_FUTEX_H
+#define _ASM_UBICOM32_FUTEX_H
+
+#include <asm-generic/futex.h>
+
+#endif /* _ASM_UBICOM32_FUTEX_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/gpio.h linux-2.6.28.10/arch/ubicom32/include/asm/gpio.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/gpio.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/gpio.h	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,451 @@
+/*
+ * arch/ubicom32/include/asm/gpio.h
+ *   Definitions for GPIO operations on Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_GPIO_H
+#define _ASM_UBICOM32_GPIO_H
+
+#include <linux/compiler.h>
+#include <asm/irq.h>
+
+#include <asm/ip5000.h>
+
+#define ARCH_NR_GPIOS	         512
+#define MAX_UBICOM_ONCHIP_GPIO   (9 * 32)
+
+/*
+ * Macros for manipulating GPIO numbers
+ */
+#define gpio_bit(gn)			(1 << (gn & 0x1f))
+#define gpio_bank(gn)			(gn >> 5)
+
+#define gpio_pin_index(gn)		(gn & 0x1f)
+#define gpio_port_index(gn)		(gn >> 5)
+
+#define GPIO_RA_0    ((32 * 0) + 0)
+#define GPIO_RA_1    ((32 * 0) + 1)
+#define GPIO_RA_2    ((32 * 0) + 2)
+#define GPIO_RA_3    ((32 * 0) + 3)
+#define GPIO_RA_4    ((32 * 0) + 4)
+#define GPIO_RA_5    ((32 * 0) + 5)
+#define GPIO_RA_6    ((32 * 0) + 6)
+#define GPIO_RA_7    ((32 * 0) + 7)
+
+#define GPIO_RB_0    ((32 * 1) + 0)
+#define GPIO_RB_1    ((32 * 1) + 1)
+#define GPIO_RB_2    ((32 * 1) + 2)
+#define GPIO_RB_3    ((32 * 1) + 3)
+#define GPIO_RB_4    ((32 * 1) + 4)
+#define GPIO_RB_5    ((32 * 1) + 5)
+#define GPIO_RB_6    ((32 * 1) + 6)
+#define GPIO_RB_7    ((32 * 1) + 7)
+#define GPIO_RB_8    ((32 * 1) + 8)
+#define GPIO_RB_9    ((32 * 1) + 9)
+#define GPIO_RB_10   ((32 * 1) + 10)
+#define GPIO_RB_11   ((32 * 1) + 11)
+#define GPIO_RB_12   ((32 * 1) + 12)
+#define GPIO_RB_13   ((32 * 1) + 13)
+#define GPIO_RB_14   ((32 * 1) + 14)
+#define GPIO_RB_15   ((32 * 1) + 15)
+#define GPIO_RB_16   ((32 * 1) + 16)
+#define GPIO_RB_17   ((32 * 1) + 17)
+#define GPIO_RB_18   ((32 * 1) + 18)
+#define GPIO_RB_19   ((32 * 1) + 19)
+
+#define GPIO_RC_0    ((32 * 2) + 0)
+#define GPIO_RC_1    ((32 * 2) + 1)
+#define GPIO_RC_2    ((32 * 2) + 2)
+#define GPIO_RC_3    ((32 * 2) + 3)
+#define GPIO_RC_4    ((32 * 2) + 4)
+#define GPIO_RC_5    ((32 * 2) + 5)
+#define GPIO_RC_6    ((32 * 2) + 6)
+#define GPIO_RC_7    ((32 * 2) + 7)
+#define GPIO_RC_8    ((32 * 2) + 8)
+#define GPIO_RC_9    ((32 * 2) + 9)
+#define GPIO_RC_10   ((32 * 2) + 10)
+#define GPIO_RC_11   ((32 * 2) + 11)
+#define GPIO_RC_12   ((32 * 2) + 12)
+#define GPIO_RC_13   ((32 * 2) + 13)
+#define GPIO_RC_14   ((32 * 2) + 14)
+#define GPIO_RC_15   ((32 * 2) + 15)
+#define GPIO_RC_16   ((32 * 2) + 16)
+#define GPIO_RC_17   ((32 * 2) + 17)
+#define GPIO_RC_18   ((32 * 2) + 18)
+#define GPIO_RC_19   ((32 * 2) + 19)
+#define GPIO_RC_20   ((32 * 2) + 20)
+#define GPIO_RC_21   ((32 * 2) + 21)
+#define GPIO_RC_22   ((32 * 2) + 22)
+#define GPIO_RC_23   ((32 * 2) + 23)
+#define GPIO_RC_24   ((32 * 2) + 24)
+#define GPIO_RC_25   ((32 * 2) + 25)
+#define GPIO_RC_26   ((32 * 2) + 26)
+#define GPIO_RC_27   ((32 * 2) + 27)
+#define GPIO_RC_28   ((32 * 2) + 28)
+#define GPIO_RC_29   ((32 * 2) + 29)
+#define GPIO_RC_30   ((32 * 2) + 30)
+#define GPIO_RC_31   ((32 * 2) + 31)
+
+#define GPIO_RD_0    ((32 * 3) + 0)
+#define GPIO_RD_1    ((32 * 3) + 1)
+#define GPIO_RD_2    ((32 * 3) + 2)
+#define GPIO_RD_3    ((32 * 3) + 3)
+#define GPIO_RD_4    ((32 * 3) + 4)
+#define GPIO_RD_5    ((32 * 3) + 5)
+#define GPIO_RD_6    ((32 * 3) + 6)
+#define GPIO_RD_7    ((32 * 3) + 7)
+#define GPIO_RD_8    ((32 * 3) + 8)
+#define GPIO_RD_9    ((32 * 3) + 9)
+#define GPIO_RD_10   ((32 * 3) + 10)
+#define GPIO_RD_11   ((32 * 3) + 11)
+
+#define GPIO_RE_0    ((32 * 4) + 0)
+#define GPIO_RE_1    ((32 * 4) + 1)
+#define GPIO_RE_2    ((32 * 4) + 2)
+#define GPIO_RE_3    ((32 * 4) + 3)
+#define GPIO_RE_4    ((32 * 4) + 4)
+#define GPIO_RE_5    ((32 * 4) + 5)
+#define GPIO_RE_6    ((32 * 4) + 6)
+#define GPIO_RE_7    ((32 * 4) + 7)
+
+#define GPIO_RF_0    ((32 * 5) + 0)
+#define GPIO_RF_1    ((32 * 5) + 1)
+#define GPIO_RF_2    ((32 * 5) + 2)
+#define GPIO_RF_3    ((32 * 5) + 3)
+#define GPIO_RF_4    ((32 * 5) + 4)
+#define GPIO_RF_5    ((32 * 5) + 5)
+#define GPIO_RF_6    ((32 * 5) + 6)
+#define GPIO_RF_7    ((32 * 5) + 7)
+#define GPIO_RF_8    ((32 * 5) + 8)
+#define GPIO_RF_9    ((32 * 5) + 9)
+#define GPIO_RF_10   ((32 * 5) + 10)
+#define GPIO_RF_11   ((32 * 5) + 11)
+#define GPIO_RF_12   ((32 * 5) + 12)
+#define GPIO_RF_13   ((32 * 5) + 13)
+#define GPIO_RF_14   ((32 * 5) + 14)
+#define GPIO_RF_15   ((32 * 5) + 15)
+
+#define GPIO_RG_0    ((32 * 6) + 0)
+#define GPIO_RG_1    ((32 * 6) + 1)
+#define GPIO_RG_2    ((32 * 6) + 2)
+#define GPIO_RG_3    ((32 * 6) + 3)
+#define GPIO_RG_4    ((32 * 6) + 4)
+#define GPIO_RG_5    ((32 * 6) + 5)
+#define GPIO_RG_6    ((32 * 6) + 6)
+#define GPIO_RG_7    ((32 * 6) + 7)
+#define GPIO_RG_8    ((32 * 6) + 8)
+#define GPIO_RG_9    ((32 * 6) + 9)
+#define GPIO_RG_10   ((32 * 6) + 10)
+#define GPIO_RG_11   ((32 * 6) + 11)
+#define GPIO_RG_12   ((32 * 6) + 12)
+#define GPIO_RG_13   ((32 * 6) + 13)
+#define GPIO_RG_14   ((32 * 6) + 14)
+#define GPIO_RG_15   ((32 * 6) + 15)
+#define GPIO_RG_16   ((32 * 6) + 16)
+#define GPIO_RG_17   ((32 * 6) + 17)
+#define GPIO_RG_18   ((32 * 6) + 18)
+#define GPIO_RG_19   ((32 * 6) + 19)
+#define GPIO_RG_20   ((32 * 6) + 20)
+#define GPIO_RG_21   ((32 * 6) + 21)
+#define GPIO_RG_22   ((32 * 6) + 22)
+#define GPIO_RG_23   ((32 * 6) + 23)
+#define GPIO_RG_24   ((32 * 6) + 24)
+#define GPIO_RG_25   ((32 * 6) + 25)
+#define GPIO_RG_26   ((32 * 6) + 26)
+#define GPIO_RG_27   ((32 * 6) + 27)
+#define GPIO_RG_28   ((32 * 6) + 28)
+#define GPIO_RG_29   ((32 * 6) + 29)
+#define GPIO_RG_30   ((32 * 6) + 30)
+#define GPIO_RG_31   ((32 * 6) + 31)
+
+#define GPIO_RH_0    ((32 * 7) + 0)
+#define GPIO_RH_1    ((32 * 7) + 1)
+#define GPIO_RH_2    ((32 * 7) + 2)
+#define GPIO_RH_3    ((32 * 7) + 3)
+#define GPIO_RH_4    ((32 * 7) + 4)
+#define GPIO_RH_5    ((32 * 7) + 5)
+#define GPIO_RH_6    ((32 * 7) + 6)
+#define GPIO_RH_7    ((32 * 7) + 7)
+#define GPIO_RH_8    ((32 * 7) + 8)
+#define GPIO_RH_9    ((32 * 7) + 9)
+
+#define GPIO_RI_0    ((32 * 8) + 0)
+#define GPIO_RI_1    ((32 * 8) + 1)
+#define GPIO_RI_2    ((32 * 8) + 2)
+#define GPIO_RI_3    ((32 * 8) + 3)
+#define GPIO_RI_4    ((32 * 8) + 4)
+#define GPIO_RI_5    ((32 * 8) + 5)
+#define GPIO_RI_6    ((32 * 8) + 6)
+#define GPIO_RI_7    ((32 * 8) + 7)
+#define GPIO_RI_8    ((32 * 8) + 8)
+#define GPIO_RI_9    ((32 * 8) + 9)
+#define GPIO_RI_10   ((32 * 8) + 10)
+#define GPIO_RI_11   ((32 * 8) + 11)
+#define GPIO_RI_12   ((32 * 8) + 12)
+#define GPIO_RI_13   ((32 * 8) + 13)
+
+/*
+ * The following section defines extra GPIO available to some boards.
+ * These GPIO are generally external to the processor (i.e. SPI/I2C
+ * expander chips).
+ *
+ * Note that these defines show all possible GPIO available, however,
+ * depending on the actual board configuration, some GPIO are not
+ * available for use.
+ */
+#ifdef CONFIG_IP7500MEDIA
+/*
+ * U15
+ */
+#define IP7500MEDIA_U15_BASE	(32 * 10)
+#define IP7500MEDIA_IO0		(IP7500MEDIA_U15_BASE + 0)
+#define IP7500MEDIA_IO1		(IP7500MEDIA_U15_BASE + 1)
+#define IP7500MEDIA_IO2		(IP7500MEDIA_U15_BASE + 2)
+#define IP7500MEDIA_IO3		(IP7500MEDIA_U15_BASE + 3)
+#define IP7500MEDIA_IO4		(IP7500MEDIA_U15_BASE + 4)
+#define IP7500MEDIA_IO5		(IP7500MEDIA_U15_BASE + 5)
+#define IP7500MEDIA_IO6		(IP7500MEDIA_U15_BASE + 6)
+#define IP7500MEDIA_IO7		(IP7500MEDIA_U15_BASE + 7)
+
+/*
+ * U16
+ */
+#define IP7500MEDIA_U16_BASE	(32 * 11)
+#define IP7500MEDIA_IO8		(IP7500MEDIA_U16_BASE + 0)
+#define IP7500MEDIA_IO9		(IP7500MEDIA_U16_BASE + 1)
+#define IP7500MEDIA_IO10	(IP7500MEDIA_U16_BASE + 2)
+#define IP7500MEDIA_IO11	(IP7500MEDIA_U16_BASE + 3)
+#define IP7500MEDIA_IO12	(IP7500MEDIA_U16_BASE + 4)
+#define IP7500MEDIA_IO13	(IP7500MEDIA_U16_BASE + 5)
+#define IP7500MEDIA_IO14	(IP7500MEDIA_U16_BASE + 6)
+#define IP7500MEDIA_IO15	(IP7500MEDIA_U16_BASE + 7)
+
+/*
+ * U17
+ */
+#define IP7500MEDIA_U17_BASE	(32 * 12)
+#define IP7500MEDIA_IO16	(IP7500MEDIA_U17_BASE + 0)
+#define IP7500MEDIA_IO17	(IP7500MEDIA_U17_BASE + 1)
+#define IP7500MEDIA_IO18	(IP7500MEDIA_U17_BASE + 2)
+#define IP7500MEDIA_IO19	(IP7500MEDIA_U17_BASE + 3)
+#define IP7500MEDIA_IO20	(IP7500MEDIA_U17_BASE + 4)
+#define IP7500MEDIA_IO21	(IP7500MEDIA_U17_BASE + 5)
+#define IP7500MEDIA_IO22	(IP7500MEDIA_U17_BASE + 6)
+#define IP7500MEDIA_IO23	(IP7500MEDIA_U17_BASE + 7)
+
+/*
+ * U18
+ */
+#define IP7500MEDIA_U18_BASE	(32 * 13)
+#define IP7500MEDIA_IO24	(IP7500MEDIA_U18_BASE + 0)
+#define IP7500MEDIA_IO25	(IP7500MEDIA_U18_BASE + 1)
+#define IP7500MEDIA_IO26	(IP7500MEDIA_U18_BASE + 2)
+#define IP7500MEDIA_IO27	(IP7500MEDIA_U18_BASE + 3)
+#define IP7500MEDIA_IO28	(IP7500MEDIA_U18_BASE + 4)
+#define IP7500MEDIA_IO29	(IP7500MEDIA_U18_BASE + 5)
+#define IP7500MEDIA_IO30	(IP7500MEDIA_U18_BASE + 6)
+#define IP7500MEDIA_IO31	(IP7500MEDIA_U18_BASE + 7)
+#endif
+
+#ifdef CONFIG_IP7145DPF
+/*
+ * U48
+ */
+#define IP7145DPF_U48_BASE	(32 * 10)
+#define IP7145DPF_IO0		(IP7145DPF_U48_BASE + 0)
+#define IP7145DPF_IO1		(IP7145DPF_U48_BASE + 1)
+#define IP7145DPF_IO2		(IP7145DPF_U48_BASE + 2)
+#define IP7145DPF_IO3		(IP7145DPF_U48_BASE + 3)
+#define IP7145DPF_IO4		(IP7145DPF_U48_BASE + 4)
+#define IP7145DPF_IO5		(IP7145DPF_U48_BASE + 5)
+#define IP7145DPF_IO6		(IP7145DPF_U48_BASE + 6)
+#define IP7145DPF_IO7		(IP7145DPF_U48_BASE + 7)
+
+/*
+ * U72
+ */
+#define IP7145DPF_U72_BASE	(32 * 11)
+#define IP7145DPF_IOB0		(IP7145DPF_U72_BASE + 0)
+#define IP7145DPF_IOB1		(IP7145DPF_U72_BASE + 1)
+#define IP7145DPF_IOB2		(IP7145DPF_U72_BASE + 2)
+#define IP7145DPF_IOB3		(IP7145DPF_U72_BASE + 3)
+#define IP7145DPF_IOB4		(IP7145DPF_U72_BASE + 4)
+#define IP7145DPF_IOB5		(IP7145DPF_U72_BASE + 5)
+#define IP7145DPF_IOB6		(IP7145DPF_U72_BASE + 6)
+#define IP7145DPF_IOB7		(IP7145DPF_U72_BASE + 7)
+#endif
+
+#include <asm-generic/gpio.h>
+
+/*
+ * The following macros bypass gpiolib to generate direct references
+ * to the port registers.  These assume, minimally, that either
+ * gpio_direction_input() or gpio_direction_output() have already been
+ * called to setup the pin direction and to enable the pin function to
+ * be gpio.  These macros generate the hardware port address based on
+ * the assumption that all ports are 32 bits wide (even though we know
+ * they are not).  This is so we can efficiently turn pin numbers into
+ * port addresses without a lookup.
+ *
+ * These operations must be done in one instruction to prevent clobbering
+ * other thread's accesses to the same port.
+ */
+#define UBICOM32_GPIO_ENABLE(pin)				\
+	do {							\
+		asm volatile ("or.4 (%[port]), (%[port]), %[mask]\n\t"						\
+				:										\
+				: [port] "a" (&UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_mask),	\
+				  [mask] "d" (gpio_bit(pin))							\
+				: "cc", "memory"								\
+		);												\
+	} while (0);
+
+#define UBICOM32_GPIO_DISABLE(pin)				\
+	do {							\
+		asm volatile ("and.4 (%[port]), (%[port]), %[mask]\n\t"						\
+				:										\
+				: [port] "a" (&UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_mask),	\
+				  [mask] "d" (~gpio_bit(pin))							\
+				: "cc", "memory"								\
+		);												\
+	} while (0);
+
+#define UBICOM32_GPIO_SET_PIN_INPUT(pin)			\
+	do {							\
+		asm volatile ("and.4 (%[port]), (%[port]), %[mask]\n\t"						\
+				:										\
+				: [port] "a" (&UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_ctl),	\
+				  [mask] "d" (~gpio_bit(pin))							\
+				: "cc", "memory"								\
+		);												\
+	} while (0);
+
+#define UBICOM32_GPIO_SET_PIN_OUTPUT(pin)			\
+	do {							\
+		asm volatile ("or.4 (%[port]), (%[port]), %[mask]\n\t"						\
+				:										\
+				: [port] "a" (&UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_ctl),	\
+				  [mask] "d" (gpio_bit(pin))							\
+				: "cc", "memory"								\
+		);												\
+	} while (0);
+
+#define UBICOM32_GPIO_SET_PIN_TOGGLE(pin)			\
+	do {							\
+		asm volatile ("xor.4 (%[port]), (%[port]), %[mask]\n\t"						\
+				:										\
+				: [port] "a" (&UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_out),	\
+				  [mask] "d" (gpio_bit(pin))							\
+				: "cc", "memory"								\
+		);												\
+	} while (0);
+
+#define UBICOM32_GPIO_SET_PIN_HIGH(pin)				\
+	do {							\
+		asm volatile ("or.4 (%[port]), (%[port]), %[mask]\n\t"						\
+				:										\
+				: [port] "a" (&UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_out),	\
+				  [mask] "d" (gpio_bit(pin))							\
+				: "cc", "memory"								\
+		);												\
+	} while (0);
+
+#define UBICOM32_GPIO_SET_PIN_LOW(pin)				\
+	do {							\
+		asm volatile ("and.4 (%[port]), (%[port]), %[mask]\n\t"						\
+				:										\
+				: [port] "a" (&UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_out),	\
+				  [mask] "d" (~gpio_bit(pin))							\
+				: "cc", "memory"								\
+		);												\
+	} while (0);
+
+#define UBICOM32_GPIO_SET_PIN(pin, val) \
+  if ( val ) {                          \
+    UBICOM32_GPIO_SET_PIN_HIGH(pin);    \
+  } else {                              \
+    UBICOM32_GPIO_SET_PIN_LOW(pin);	\
+  }
+
+#define UBICOM32_GPIO_GET_PIN(pin)                                    \
+  (0 != (UBICOM32_IO_PORT(IO_BASE + (gpio_bank(pin) << 12))->gpio_in  \
+	 & gpio_bit(pin)))
+
+
+static inline int gpio_get_value(unsigned gpio) 
+{
+  if (gpio <= MAX_UBICOM_ONCHIP_GPIO)
+    return UBICOM32_GPIO_GET_PIN(gpio);
+  else
+    return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+  if (gpio <= MAX_UBICOM_ONCHIP_GPIO)
+    {
+      UBICOM32_GPIO_SET_PIN(gpio, value);
+    }
+  else
+    {
+      __gpio_set_value(gpio, value);
+    }
+}
+
+static inline int gpio_cansleep(unsigned gpio)
+{
+  return __gpio_cansleep(gpio);
+}
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+#if defined(IP5000) || defined(IP5000_REV2)
+  if ((gpio >= GPIO_RA_4) && (gpio <= GPIO_RA_6))
+    return 25;
+  else
+    return -ENXIO;
+
+#elif defined(IP7000) || defined(IP7000_REV2)
+  if ((gpio >= GPIO_RA_4) && (gpio <= GPIO_RA_6))
+    return 44 + (gpio - GPIO_RA_4);
+  else
+    return -ENXIO;
+
+#else
+    return -ENXIO;
+
+#endif
+}
+
+static inline int irq_to_gpio(unsigned gpio)
+{
+	return -ENXIO;
+}
+
+extern struct ubicom32_io_port *ubi_gpio_get_port(unsigned gpio);
+
+extern int __init ubi_gpio_init(void);
+
+#endif /* _ASM_UBICOM32_GPIO_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/hardirq.h linux-2.6.28.10/arch/ubicom32/include/asm/hardirq.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/hardirq.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/hardirq.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,55 @@
+/*
+ * arch/ubicom32/include/asm/hardirq.h
+ *   Definition of ack_bad_irq() for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 1997, 98, 99, 2000, 01, 05 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2001 MIPS Technologies, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_HARDIRQ_H
+#define _ASM_UBICOM32_HARDIRQ_H
+
+#include <linux/threads.h>
+#include <linux/irq.h>
+
+/*
+ * The hardirq mask has to be large enough to have space
+ * for potentially all IRQ sources in the system nesting
+ * on a single CPU.  For Ubicom32, we have 64 IRQ sources.
+ */
+#define HARDIRQ_BITS	6
+#if (1 << HARDIRQ_BITS) < NR_IRQS
+# error HARDIRQ_BITS is too low!
+#endif
+
+typedef struct {
+	unsigned int __softirq_pending;
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+extern void ack_bad_irq(unsigned int irq);
+
+#endif /* _ASM_UBICOM32_HARDIRQ_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/hw_irq.h linux-2.6.28.10/arch/ubicom32/include/asm/hw_irq.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/hw_irq.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/hw_irq.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,31 @@
+/*
+ * arch/ubicom32/include/asm/hw_irq.h
+ *   Ubicom32 architecture APIC support.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_HW_IRQ_H
+#define _ASM_UBICOM32_HW_IRQ_H
+
+#endif /* _ASM_UBICOM32_HW_IRQ_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ioctl.h linux-2.6.28.10/arch/ubicom32/include/asm/ioctl.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ioctl.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ioctl.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/ioctl.h
+ *   Generic ioctl.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_IOCTL_H
+#define _ASM_UBICOM32_IOCTL_H
+
+#include <asm-generic/ioctl.h>
+
+#endif /* _ASM_UBICOM32_IOCTL_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ioctls.h linux-2.6.28.10/arch/ubicom32/include/asm/ioctls.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ioctls.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ioctls.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,111 @@
+/*
+ * arch/ubicom32/include/asm/ioctls.h
+ *   Definitions of ioctls for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_IOCTLS_H
+#define _ASM_UBICOM32_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TCGETS2		_IOR('T',0x2A, struct termios2)
+#define TCSETS2		_IOW('T',0x2B, struct termios2)
+#define TCSETSW2	_IOW('T',0x2C, struct termios2)
+#define TCSETSF2	_IOW('T',0x2D, struct termios2)
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450  /* these numbers need to be adjusted. */
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define FIOQSIZE	0x545E
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+#endif /* _ASM_UBICOM32_IOCTLS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/io.h linux-2.6.28.10/arch/ubicom32/include/asm/io.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/io.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/io.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,313 @@
+/*
+ * arch/ubicom32/include/asm/io.h
+ *   I/O memory accessor functions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_IO_H
+#define _ASM_UBICOM32_IO_H
+
+#ifdef __KERNEL__
+#include <linux/string.h>
+#include <linux/compiler.h>
+
+static inline unsigned short _swapw(volatile unsigned short v)
+{
+    return ((v << 8) | (v >> 8));
+}
+
+static inline unsigned int _swapl(volatile unsigned long v)
+{
+    return ((v << 24) | ((v & 0xff00) << 8) | ((v & 0xff0000) >> 8) | (v >> 24));
+}
+
+#ifndef CONFIG_PCI
+#define readb(addr) \
+    ({ unsigned char __v = (*(volatile unsigned char *) (addr)); __v; })
+#define readw(addr) \
+    ({ unsigned short __v = (*(volatile unsigned short *) (addr)); __v; })
+#define readl(addr) \
+    ({ unsigned int __v = (*(volatile unsigned int *) (addr)); __v; })
+
+#define writeb(b,addr) (void)((*(volatile unsigned char *) (addr)) = (b))
+#define writew(b,addr) (void)((*(volatile unsigned short *) (addr)) = (b))
+#define writel(b,addr) (void)((*(volatile unsigned int *) (addr)) = (b))
+#else /*CONFIG_PCI */
+
+#define PCI_CPU_REG_BASE (0x00000000UL)   /* taking lower 2GB space */
+#define PCI_DEV_REG_BASE (0x80000000UL)
+
+#if PCI_CPU_REG_BASE > PCI_DEV_REG_BASE
+#define IS_PCI_ADDRESS(x) (((unsigned int)(x)&(PCI_CPU_REG_BASE)) == 0)
+#else
+#define IS_PCI_ADDRESS(x) ((unsigned int)(x)&(PCI_DEV_REG_BASE))
+#endif 
+
+extern unsigned int ubi32_pci_read_u32(const volatile void __iomem *addr);
+extern unsigned short ubi32_pci_read_u16(const volatile void __iomem *addr);
+extern unsigned char ubi32_pci_read_u8(const volatile void __iomem *addr);
+extern  void ubi32_pci_write_u32(unsigned int val, const volatile void __iomem *addr);
+extern  void ubi32_pci_write_u16(unsigned short val, const volatile void __iomem *addr);
+extern  void ubi32_pci_write_u8(unsigned char val, const volatile void __iomem *addr);
+
+static  inline unsigned char readb(const volatile void __iomem *addr)
+{
+	if (IS_PCI_ADDRESS(addr))
+		return ubi32_pci_read_u8(addr);
+	else 
+		return (unsigned char)(*(volatile unsigned char *)addr); 
+}
+static inline unsigned short readw(const volatile void __iomem *addr)
+{
+	if (IS_PCI_ADDRESS(addr))
+		return ubi32_pci_read_u16(addr);
+	else 
+		return (unsigned short)(*(volatile unsigned short *)addr);	
+}
+
+static  inline unsigned int  readl(const volatile void __iomem *addr)
+{
+	if (IS_PCI_ADDRESS(addr))
+		return ubi32_pci_read_u32(addr);
+	else 
+		return (unsigned int)(*(volatile unsigned int *)addr);
+}
+
+static inline void writel(unsigned int val, volatile void __iomem *addr)
+{
+  	if (IS_PCI_ADDRESS(addr))
+                ubi32_pci_write_u32(val, addr);
+        else
+               	*(volatile unsigned int *)addr = val; 
+}
+
+static inline void writew(unsigned short val, volatile void __iomem *addr)
+{
+  	if (IS_PCI_ADDRESS(addr))
+                ubi32_pci_write_u16(val, addr);
+        else
+               	*(volatile unsigned short *)addr = val; 
+}
+
+static inline void writeb(unsigned char val, volatile void __iomem *addr)
+{
+  	if (IS_PCI_ADDRESS(addr))
+                ubi32_pci_write_u8(val, addr);
+        else
+               	*(volatile unsigned char *)addr = val; 
+}
+#endif
+
+#define readb_relaxed(addr) readb(addr)
+#define readw_relaxed(addr) readw(addr)
+#define readl_relaxed(addr) readl(addr)
+
+
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+
+static inline void io_outsb(unsigned int addr, const void *buf, int len)
+{
+	volatile unsigned char *ap = (volatile unsigned char *) addr;
+	unsigned char *bp = (unsigned char *) buf;
+	while (len--)
+		*ap = *bp++;
+}
+
+static inline void io_outsw(unsigned int addr, const void *buf, int len)
+{
+	volatile unsigned short *ap = (volatile unsigned short *) addr;
+	unsigned short *bp = (unsigned short *) buf;
+	while (len--)
+		*ap = _swapw(*bp++);
+}
+
+static inline void io_outsl(unsigned int addr, const void *buf, int len)
+{
+	volatile unsigned int *ap = (volatile unsigned int *) addr;
+	unsigned int *bp = (unsigned int *) buf;
+	while (len--)
+		*ap = _swapl(*bp++);
+}
+
+static inline void io_insb(unsigned int addr, void *buf, int len)
+{
+	volatile unsigned char *ap = (volatile unsigned char *) addr;
+	unsigned char *bp = (unsigned char *) buf;
+	while (len--)
+		*bp++ = *ap;
+}
+
+static inline void io_insw(unsigned int addr, void *buf, int len)
+{
+	volatile unsigned short *ap = (volatile unsigned short *) addr;
+	unsigned short *bp = (unsigned short *) buf;
+	while (len--)
+		*bp++ = _swapw(*ap);
+}
+
+static inline void io_insl(unsigned int addr, void *buf, int len)
+{
+	volatile unsigned int *ap = (volatile unsigned int *) addr;
+	unsigned int *bp = (unsigned int *) buf;
+	while (len--)
+		*bp++ = _swapl(*ap);
+}
+
+#define mmiowb()
+
+/*
+ *	make the short names macros so specific devices
+ *	can override them as required
+ */
+#ifndef CONFIG_PCI
+#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
+#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+#else 
+extern void memcpy_fromio(void *to, const volatile void __iomem *from, unsigned len);
+extern void memcpy_toio(volatile void __iomem *to, const void *from, unsigned len);
+extern void memset_io(volatile void __iomem *addr, int val, size_t count);
+#endif
+
+#define inb(addr)    readb(addr)
+#define inw(addr)    readw(addr)
+#define inl(addr)    readl(addr)
+#define outb(x,addr) ((void) writeb(x,addr))
+#define outw(x,addr) ((void) writew(x,addr))
+#define outl(x,addr) ((void) writel(x,addr))
+
+#define inb_p(addr)    inb(addr)
+#define inw_p(addr)    inw(addr)
+#define inl_p(addr)    inl(addr)
+#define outb_p(x,addr) outb(x,addr)
+#define outw_p(x,addr) outw(x,addr)
+#define outl_p(x,addr) outl(x,addr)
+
+#define outsb(a,b,l) io_outsb(a,b,l)
+#define outsw(a,b,l) io_outsw(a,b,l)
+#define outsl(a,b,l) io_outsl(a,b,l)
+
+#define insb(a,b,l) io_insb(a,b,l)
+#define insw(a,b,l) io_insw(a,b,l)
+#define insl(a,b,l) io_insl(a,b,l)
+
+#ifndef CONFIG_PCI
+#define ioread8_rep(a,d,c)	insb(a,d,c)
+#define ioread16_rep(a,d,c)	insw(a,d,c)
+#define ioread32_rep(a,d,c)	insl(a,d,c)
+#define iowrite8_rep(a,s,c)	outsb(a,s,c)
+#define iowrite16_rep(a,s,c)	outsw(a,s,c)
+#define iowrite32_rep(a,s,c)	outsl(a,s,c)
+#else
+extern void  ioread8_rep(void __iomem *port, void *buf, unsigned long count);
+extern void  ioread16_rep(void __iomem *port, void *buf, unsigned long count);
+extern void  ioread32_rep(void __iomem *port, void *buf, unsigned long count);
+extern void  iowrite8_rep(void __iomem *port, const void *buf, unsigned long count);
+extern void  iowrite16_rep(void __iomem *port, const void *buf, unsigned long count);
+extern void  iowrite32_rep(void __iomem *port, const void *buf, unsigned long count);
+#endif
+
+
+#ifndef CONFIG_PCI
+#define ioread8(X)			readb(X)
+#define ioread16(X)			readw(X)
+#define ioread32(X)			readl(X)
+#define iowrite8(val,X)			writeb(val,X)
+#define iowrite16(val,X)		writew(val,X)
+#define iowrite32(val,X)		writel(val,X)
+#else /*CONFIG_PCI */
+extern  unsigned char  ioread8(void __iomem *addr);
+extern  unsigned short ioread16(void __iomem *addr);
+extern  unsigned int  ioread32(void __iomem *addr);
+extern  void iowrite8(unsigned char val, void __iomem *addr);
+extern  void iowrite16(unsigned short val, void __iomem *addr);
+extern  void iowrite32(unsigned int val, void __iomem *addr);
+#endif /* CONFIG_PCI */
+
+#define IO_SPACE_LIMIT 0xffff
+
+/* Values for nocacheflag and cmode */
+#define IOMAP_FULL_CACHING		0
+#define IOMAP_NOCACHE_SER		1
+#define IOMAP_NOCACHE_NONSER		2
+#define IOMAP_WRITETHROUGH		3
+
+extern void *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag);
+extern void __iounmap(void *addr, unsigned long size);
+
+static inline void *ioremap(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+static inline void *ioremap_nocache(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+static inline void *ioremap_writethrough(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
+}
+static inline void *ioremap_fullcache(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
+}
+
+extern void iounmap(void *addr);
+
+#define ioport_map(port, nr)            ((void __iomem*)(port))
+#define ioport_unmap(addr)
+
+
+/* Pages to physical address... */
+#define page_to_phys(page)      ((page - mem_map) << PAGE_SHIFT)
+#define page_to_bus(page)       ((page - mem_map) << PAGE_SHIFT)
+
+/*
+ * Macros used for converting between virtual and physical mappings.
+ */
+#define phys_to_virt(vaddr)	((void *) (vaddr))
+#define virt_to_phys(vaddr)	((unsigned long) (vaddr))
+
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_UBICOM32_IO_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ip5000-asm.h linux-2.6.28.10/arch/ubicom32/include/asm/ip5000-asm.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ip5000-asm.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ip5000-asm.h	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,156 @@
+/*
+ * arch/ubicom32/include/asm/ip5000-asm.h
+ *	Instruction macros for the IP5000.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_IP5000_ASM_H
+#define _ASM_UBICOM32_IP5000_ASM_H
+
+#if !defined(__LINKER__)
+
+#if defined(__ASSEMBLY__)
+.macro	cycles	quant
+.if	(\quant) == 1
+	nop
+.else
+.if	(((\quant) + 3) / 8) > 0
+.rept	(((\quant) + 3) / 8)
+	jmpt.f		.+4
+.endr
+.endif
+.if	((((\quant) + 3) % 8) / 4) > 0
+	jmpt.t		.+4
+.endif
+.endif
+.endm
+#else
+/*
+ * Same macro as above just in C inline asm
+ */
+asm ("					\n\
+.macro	cycles	quant			\n\
+.if	(\\quant) == 1			\n\
+	nop				\n\
+.else					\n\
+.if	(((\\quant) + 3) / 8) > 0	\n\
+.rept	(((\\quant) + 3) / 8)		\n\
+	jmpt.f		.+4		\n\
+.endr					\n\
+.endif					\n\
+.if	((((\\quant) + 3) % 8) / 4) > 0	\n\
+	jmpt.t		.+4		\n\
+.endif					\n\
+.endif					\n\
+.endm					\n\
+");
+#endif
+
+
+#if defined(__ASSEMBLY__)
+.macro	pipe_flush	cyc
+	cycles		11 - (\cyc)
+.endm
+#else
+/*
+ * Same macro as above just in C inline asm
+ */
+asm ("					\n\
+.macro	pipe_flush	cyc		\n\
+	cycles		11 - (\\cyc)	\n\
+.endm					\n\
+");
+
+#endif
+
+#if defined(__ASSEMBLY__)
+.macro	setcsr_flush	cyc
+	cycles		5 - (\cyc)
+.endm
+#else
+/*
+ * Same macro as above just in C inline asm
+ */
+asm ("					\n\
+.macro	setcsr_flush	cyc		\n\
+	cycles		5 - (\\cyc)	\n\
+.endm					\n\
+");
+#endif
+
+/*
+ * Macros for prefetch (using miss-aligned memory write)
+ */
+#if defined(__ASSEMBLY__)
+
+.macro	pre_fetch_macro	thread_num, Ascratch, Aaddress length
+	bclr		MT_TRAP_EN, MT_TRAP_EN, #(\thread_num)
+	bset		\Ascratch, \Aaddress, #0	; force a miss-aligned address
+	jmpt.t		.+4				; delay for both address setup and trap disable
+	move.4		(\Ascratch), #0
+	.if		(\length > 32)
+	move.4		32(\Ascratch), #0
+	.endif
+	.if		(\length > 64)
+	move.4		64(\Ascratch), #0
+	.endif
+	.if		(\length > 96)
+	move.4		96(\Ascratch), #0
+	.endif
+	.if		(\length > 128)
+	invalid_instruction				; maximum pre-fetch size is 4 cache lines
+	.endif
+	bset		MT_TRAP_EN, MT_TRAP_EN, #(\thread_num)
+.endm
+
+#else
+/*
+ * Same macro as above just in C inline asm
+ */
+asm ("								\n\
+.macro	pre_fetch_macro	thread_num, Ascratch, Aaddress length	\n\
+	bclr		MT_TRAP_EN, MT_TRAP_EN, #(\thread_num)	\n\
+	bset		\\Ascratch, \\Aaddress, #0	; force a miss-aligned address \n\
+	jmpt.t		.+4				; delay for both address setup and trap disable \n\
+	move.4		(\\Ascratch), #0			\n\
+	.if		(\\length > 32)				\n\
+	move.4		32(\\Ascratch), #0			\n\
+	.endif							\n\
+	.if		(\\length > 64)				\n\
+	move.4		64(\\Ascratch), #0			\n\
+	.endif							\n\
+	.if		(\\length > 96)				\n\
+	move.4		96(\\Ascratch), #0			\n\
+	.endif							\n\
+	.if		(\\length > 128)			\n\
+	invalid_instruction				; maximum pre-fetch size is 4 cache lines \n\
+	.endif							\n\
+	bset		MT_TRAP_EN, MT_TRAP_EN, #(\\thread_num)	\n\
+.endm								\n\
+");
+#endif
+
+#endif /* !defined(__LINKER__) */
+#endif /* defined _ASM_UBICOM32_IP5000_ASM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ip5000.h linux-2.6.28.10/arch/ubicom32/include/asm/ip5000.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ip5000.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ip5000.h	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,860 @@
+/*
+ * arch/ubicom32/include/asm/ip5000.h
+ *   Specific details for the Ubicom IP5000 processor.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_IP5000_H
+#define _ASM_UBICOM32_IP5000_H
+
+/*
+ * Inline assembly define
+ */
+#define S(arg) #arg
+#define D(arg) S(arg)
+
+/*
+ * Assembler include file
+ */
+#include <asm/ip5000-asm.h>
+
+/*
+ * Timing
+ */
+#define JMPT_PENALTY 3
+#define JMPF_PENALTY 7
+#define RET_PENALTY 7
+
+/*
+ * Threads
+ */
+#if defined(IP5000) || defined(IP5000_REV2)
+#define THREAD_COUNT 10
+#elif defined(IP7000) || defined(IP7000_REV2)
+#define THREAD_COUNT 12
+#else
+#error "Unknown IP5K silicon"
+#endif
+
+/*
+ * Arch
+ */
+#if defined(IP5000) || defined(IP5000_REV2)
+#define UBICOM32_ARCH_VERSION 3
+#elif defined(IP7000) || defined(IP7000_REV2)
+#define UBICOM32_ARCH_VERSION 4
+#else
+#error "Unknown IP5K silicon"
+#endif
+
+/*
+ * Memory Size
+ */
+#define OCM_SECTOR_SIZE	0x00008000		/* 32K */
+
+#if defined(IP5000) || defined(IP5000_REV2)
+#define OCMSIZE	0x00030000		/* 192K on-chip RAM for both program and data */
+#elif defined(IP7000) || defined(IP7000_REV2)
+#define OCMSIZE	0x0003C000		/* 240K on-chip RAM for both program and data */
+#else
+#error "Unknown IP5K silicon"
+#endif
+
+#define OCMSTART	0x3ffc0000		/* alias from 0x03000000 for easy jump to/from SDRAM */
+#define OCMEND		(OCMSTART + OCMSIZE)
+#define SDRAMSTART	0x40000000
+#define FLASHSTART	0x60000000
+
+/*
+ * Registers
+ */
+#define ROSR_INT (1 << 0)
+
+/* Interrupts */
+#define INT_CHIP(reg, bit) (((reg) << 5) | (bit))
+#define INT_REG(interrupt) (((interrupt) >> 5) * 4)
+#define INT_SET(interrupt) 0x0114 + INT_REG(interrupt)
+#define INT_CLR(interrupt) 0x0124 + INT_REG(interrupt)
+#define INT_STAT(interrupt) 0x0104 + INT_REG(interrupt)
+#define INT_MASK(interrupt) 0x00C0 + INT_REG(interrupt)
+#define INT_BIT(interrupt) ((interrupt) & 0x1F)
+#define INT_BIT_MASK(interrupt) (1 << INT_BIT(interrupt))
+
+/*
+ * The LOCK_INT and THREAD_INT are used to wake up corresponding thread. They are sharing
+ * the same set of SW interrupt resource.
+ *
+ * LOCK_INT(n): One SW INT per NRT thread that can participate lock operation.
+ *	The threads that can participate lock are application threads and DSR thread.
+ *	(Lock locks - numbers are hard-coded in lock.h)
+ * THREAD_INT(n):   One SW INT per HRT thread for wake up trigger.
+ */
+#define LOCK_INT(thread)	INT_CHIP(0, (thread))
+#define THREAD_INT(thread)	INT_CHIP(0, (thread))
+
+/*
+ * The SYSTEM_INT and DSR_INT are sharing the same set of SW interrupt resource.
+ *
+ * SYSTEM_INT(n): One SW INT per NRT threads (application threads) as system queue interrupt,
+ *	and for DSR as self-trigger interrupt.
+ *	(The application threads include at least thread 0)
+ * DSR_INT(n):    One SW INT per HRT thread to request DSR service.
+ */
+#define SYSTEM_INT(thread)	INT_CHIP(0, THREAD_COUNT + (thread))
+#define DSR_INT(thread)		INT_CHIP(0, THREAD_COUNT + (thread))
+
+/* GLOBAL_CTRL */
+#define GLOBAL_CTRL_TRAP_RST_EN (1 << 9)
+#define GLOBAL_CTRL_AERROR_RST_EN (1 << 8)
+#define GLOBAL_CTRL_MT_MIN_DELAY(x) ((x) << 3)
+#define GLOBAL_CTRL_HRT_BANK_SELECT (1 << 2)
+#define GLOBAL_CTRL_INT_EN (1 << 0)
+
+/*
+ * HRT Tables
+ */
+#define HRT_TABLE0_BASE 0x0800
+#define HRT_TABLE1_BASE 0x0900
+#define HRT_TABLE_SIZE 64
+
+/*
+ * Break Point Trap Register
+ */
+#define ASYNCERROR_INT INT_CHIP(0, 31)
+#define BREAKPOINT_INT INT_CHIP(1, 31)
+
+/*
+ * Port interrupts
+ *	The non-existing FIFO INTs are mapped to INT2 for the ports.
+ */
+#define IO_PORT_PTR_TO_NUM(port) (((port) & 0x0000ffff) >> 12)
+#define RX_FIFO_INT(port) \
+	((IO_PORT_PTR_TO_NUM(port) == 0) ? INT_CHIP(0, 25) : \
+	((IO_PORT_PTR_TO_NUM(port) == 1) ? INT_CHIP(0, 26) : \
+	((IO_PORT_PTR_TO_NUM(port) == 2) ? INT_CHIP(0, 29) : \
+	((IO_PORT_PTR_TO_NUM(port) == 3) ? INT_CHIP(1, 24) : \
+	((IO_PORT_PTR_TO_NUM(port) == 4) ? INT_CHIP(1, 27) : \
+	((IO_PORT_PTR_TO_NUM(port) == 5) ? INT_CHIP(1, 16) : \
+	((IO_PORT_PTR_TO_NUM(port) == 6) ? INT_CHIP(1, 19) : \
+	((IO_PORT_PTR_TO_NUM(port) == 7) ? INT_CHIP(1, 20) : \
+	((IO_PORT_PTR_TO_NUM(port) == 8) ? INT_CHIP(1, 21) : \
+	INT_CHIP(1, 15))))))))))
+#define TX_FIFO_INT(port) \
+	((IO_PORT_PTR_TO_NUM(port) == 0) ? INT_CHIP(0, 24) : \
+	((IO_PORT_PTR_TO_NUM(port) == 1) ? INT_CHIP(0, 27) : \
+	((IO_PORT_PTR_TO_NUM(port) == 2) ? INT_CHIP(0, 29) : \
+	((IO_PORT_PTR_TO_NUM(port) == 3) ? INT_CHIP(1, 25) : \
+	((IO_PORT_PTR_TO_NUM(port) == 4) ? INT_CHIP(1, 28) : \
+	((IO_PORT_PTR_TO_NUM(port) == 5) ? INT_CHIP(1, 17) : \
+	((IO_PORT_PTR_TO_NUM(port) == 6) ? INT_CHIP(1, 19) : \
+	((IO_PORT_PTR_TO_NUM(port) == 7) ? INT_CHIP(1, 20) : \
+	((IO_PORT_PTR_TO_NUM(port) == 8) ? INT_CHIP(1, 22) : \
+	INT_CHIP(1, 15))))))))))
+#define PORT_OTHER_INT(port) \
+	((IO_PORT_PTR_TO_NUM(port) == 0) ? INT_CHIP(0, 25) : \
+	((IO_PORT_PTR_TO_NUM(port) == 1) ? INT_CHIP(0, 28) : \
+	((IO_PORT_PTR_TO_NUM(port) == 2) ? INT_CHIP(0, 29) : \
+	((IO_PORT_PTR_TO_NUM(port) == 3) ? INT_CHIP(1, 26) : \
+	((IO_PORT_PTR_TO_NUM(port) == 4) ? INT_CHIP(1, 29) : \
+	((IO_PORT_PTR_TO_NUM(port) == 5) ? INT_CHIP(1, 18) : \
+	((IO_PORT_PTR_TO_NUM(port) == 6) ? INT_CHIP(1, 19) : \
+	((IO_PORT_PTR_TO_NUM(port) == 7) ? INT_CHIP(1, 20) : \
+	((IO_PORT_PTR_TO_NUM(port) == 8) ? INT_CHIP(1, 23) : \
+	INT_CHIP(1, 15))))))))))
+
+/*
+ * On Chip Peripherals Base.
+ */
+#define OCP_BASE	0x01000000
+#define OCP_GENERAL	0x000
+#define OCP_TIMERS	0x100
+#define OCP_TRNG	0x200	/* True Random Number Generator Control Reigsters */
+#define OCP_DEBUG	0x300
+#define OCP_SECURITY	0x400
+#define OCP_ICCR	0x500	/* I-Cache Control Registers */
+#define OCP_DCCR	0x600	/* D-Cache Control Registers */
+#define OCP_OCMC	0x700	/* On Chip Memory Control Registers */
+#define OCP_STATISTICS	0x800	/* Statistics Counters */
+#define OCP_MTEST	0x900	/* Memory Test Registers */
+#define OCP_MCFG	0xa00	/* Memory Configuration Registers -- IP7000 only */
+#define OCP_DEBUG_INST	0x000	/* Up to 16M */
+
+/*
+ * General Configuration Registers (PLL)
+ */
+#define GENERAL_CFG_BASE (OCP_BASE + OCP_GENERAL)
+#define GEN_CLK_CORE_CFG 0x00
+#define GEN_CLK_IO_CFG 0x04
+#define GEN_CLK_DDR_CFG 0x08
+#define GEN_CLK_DDRDS_CFG 0x0c
+#define GEN_CLK_SLIP_CLR 0x10
+#define GEN_CLK_SLIP_START 0x14
+#define GEN_CLK_SERDES_SEL 0x18	/* IP7000 only */
+#define GEN_CLK_DDR_CFG2 0x1c	/* IP7000 only */
+#define GEN_DDR_CAL_CTRL 0x30	/* IP5000 only */
+#define GEN_DDR_CAL_STAT 0x34	/* IP5000 only */
+#define GEN_USB_DFT_CTRL 0x38	/* IP5000 only */
+#define GEN_USB_DFT_STAT 0x3c	/* IP5000 only */
+#define GEN_USB_PHY_CFG 0x40	/* IP7000 only */
+#define GEN_USB_PHY_TEST 0x44	/* IP7000 only */
+#define GEN_USB_PHY_STAT 0x48	/* IP7000 only */
+#define GEN_SW_RESET 0x80
+#define GEN_RESET_REASON 0x84
+#define GEN_BOND_CFG 0x88
+#define GEN_IO_PU_CFG 0x8c
+#define GEN_MEM_RM_CFG 0x90
+#define GEN_IO_CONFIG 0x94
+
+#define GEN_CLK_PLL_SECURITY_BIT_NO 31
+#define GEN_CLK_PLL_SECURITY (1 << GEN_CLK_PLL_SECURITY_BIT_NO)
+#define GEN_CLK_PLL_ENSAT (1 << 30)
+#define GEN_CLK_PLL_FASTEN (1 << 29)
+#define GEN_CLK_PLL_NR(v) (((v) - 1) << 23)
+#define GEN_CLK_PLL_NF(v) (((v) - 1) << 11)
+#define GEN_CLK_PLL_OD(v) (((v) - 1) << 8)
+#define GEN_CLK_PLL_RESET (1 << 7)
+#define GEN_CLK_PLL_BYPASS (1 << 6)
+#define GEN_CLK_PLL_POWERDOWN (1 << 5)
+#define GEN_CLK_PLL_SELECT (1 << 4)
+
+#define GEN_GET_CLK_PLL_NR(v) ((((v) >> 23) & 0x003f) + 1)
+#define GEN_GET_CLK_PLL_NF(v) ((((v) >> 11) & 0x0fff) + 1)
+#define GEN_GET_CLK_PLL_OD(v) ((((v) >> 8) & 0x7) + 1)
+
+
+#define RESET_FLAG_DST_MEM_ERROR (1 << 18)
+#define RESET_FLAG_SRC1_MEM_ERROR (1 << 17)
+#define RESET_FLAG_WRITE_ADDR (1 << 16)
+#define RESET_FLAG_DST_SYNC_ERROR (1 << 15)
+#define RESET_FLAG_SRC1_SYNC_ERROR (1 << 14)
+#define RESET_FLAG_DST_ALGN_ERROR (1 << 13)
+#define RESET_FLAG_SRC1_ALGN_ERROR (1 << 12)
+#define RESET_FLAG_DST_ADDR_ERROR (1 << 11)
+#define RESET_FLAG_SRC1_ADDR_ERROR (1 << 10)
+#define RESET_FLAG_ILLEGAL_INST (1 << 9)
+#define RESET_FLAG_INST_SYNC_ERROR (1 << 8)
+#define RESET_FLAG_INST_ADDR_ERROR (1 << 7)
+#define RESET_FLAG_DATA_PORT_ERROR (1 << 6)
+#define RESET_FLAG_INST_PORT_ERROR (1 << 5)
+#define RESET_FLAG_SW_RESET (1 << 4)
+#define RESET_FLAG_DEBUG (1 << 3)
+#define RESET_FLAG_WATCHDOG (1 << 2)
+#define RESET_FLAG_POWER_ON (1 << 1)
+#define RESET_FLAG_EXTERNAL (1 << 0)
+
+/*
+ * Timer block
+ */
+#define TIMER_BASE (OCP_BASE + OCP_TIMERS)
+#define TIMER_MPTVAL 0x00
+#define TIMER_RTCOM 0x04
+#define TIMER_TKEY 0x08
+#define TIMER_WDCOM 0x0c
+#define TIMER_WDCFG 0x10
+#define TIMER_SYSVAL 0x14
+#define TIMER_SYSCOM(tmr) (0x18 + (tmr) * 4)
+#define TIMER_TRN_CFG 0x100
+#define TIMER_TRN 0x104
+
+#define TIMER_COUNT 10
+#define TIMER_INT(tmr) INT_CHIP(1, (tmr))
+#define TIMER_TKEYVAL 0xa1b2c3d4
+#define TIMER_WATCHDOG_DISABLE 0x4d3c2b1a
+#define TIMER_TRN_CFG_ENABLE_OSC 0x00000007
+
+#ifndef __ASSEMBLY__
+/*
+ * ubicom32_io_timer
+ */
+struct ubicom32_io_timer {
+	volatile u32_t mptval;
+	volatile u32_t rtcom;
+	volatile u32_t tkey;
+	volatile u32_t wdcom;
+	volatile u32_t wdcfg;
+	volatile u32_t sysval;
+	volatile u32_t syscom[TIMER_COUNT];
+	volatile u32_t reserved[64 - 6 - TIMER_COUNT];	// skip all the way to OCP-TRNG section
+	volatile u32_t rsgcfg;
+	volatile u32_t trn;
+};
+
+#define UBICOM32_IO_TIMER ((struct ubicom32_io_timer *)TIMER_BASE)
+#endif
+
+#define UBICOM32_VECTOR_TO_TIMER_INDEX(vector) (vector - TIMER_INT(0))
+
+/*
+ * OCP-Debug Module (Mailbox)
+ */
+#define ISD_MAILBOX_BASE (OCP_BASE + OCP_DEBUG)
+#define ISD_MAILBOX_IN 0x00
+#define ISD_MAILBOX_OUT 0x04
+#define ISD_MAILBOX_STATUS 0x08
+
+#define ISD_MAILBOX_INT INT_CHIP(1, 30)
+
+#define ISD_MAILBOX_STATUS_IN_FULL (1 << 31)
+#define ISD_MAILBOX_STATUS_IN_EMPTY (1 << 30)
+#define ISD_MAILBOX_STATUS_OUT_FULL (1 << 29)
+#define ISD_MAILBOX_STATUS_OUT_EMPTY (1 << 28)
+
+/*
+ * OCP-Security
+ */
+#define SECURITY_BASE (OCP_BASE + OCP_SECURITY)
+#define SECURITY_BASE_EFFECTIVE_ADDRESS (SECURITY_BASE >> 7) // To load the base address in a single instruction
+#define SECURITY_CTRL 0x00
+#define SECURITY_CTRL_BYTE_OFFSET(x) ((x) << 16)
+#define SECURITY_CTRL_KEY_SIZE(x) ((x) << 8)
+#define SECURITY_CTRL_HASH_ALG_NONE (0 << 4)
+#define SECURITY_CTRL_HASH_ALG_MD5 (1 << 4)
+#define SECURITY_CTRL_HASH_ALG_SHA1 (2 << 4)
+#define SECURITY_CTRL_CBC (1 << 3)
+#define SECURITY_CTRL_CIPHER_ALG_AES (0 << 1)
+#define SECURITY_CTRL_CIPHER_ALG_NONE (1 << 1)
+#define SECURITY_CTRL_CIPHER_ALG_DES (2 << 1)
+#define SECURITY_CTRL_CIPHER_ALG_3DES (3 << 1)
+#define SECURITY_CTRL_ENCIPHER (1 << 0)
+#define SECURITY_CTRL_DECIPHER (0 << 0)
+#define SECURITY_STAT 0x04
+#define SECURITY_STAT_BUSY (1 << 0)
+#define SECURITY_KEY_VALUE(x) (0x10 + (x) * 4)
+#define SECURITY_KEY_IN(x) (0x30 + (x) * 4)
+#define SECURITY_KEY_OUT(x) (0x50 + (x) * 4)
+#define SECURITY_KEY_HASH(x) (0x70 + (x) * 4)
+
+/*
+ * OCP-ICCR
+ */
+#define ICCR_BASE (OCP_BASE + OCP_ICCR)
+#define ICACHE_TOTAL_SIZE 16384			/* in bytes */
+
+/*
+ * OCP-DCCR
+ */
+#define DCCR_BASE (OCP_BASE + OCP_DCCR)
+#if defined(IP5000) || defined(IP5000_REV2)
+#define DCACHE_TOTAL_SIZE 8192			/* in bytes */
+#elif defined(IP7000) || defined(IP7000_REV2)
+#define DCACHE_TOTAL_SIZE 16384			/* in bytes */
+#endif
+
+#if defined(IP5000) || defined(IP5000_REV2) || defined(IP7000) || defined(IP7000_REV2)
+#define DCACHE_WRITE_QUEUE_LENGTH 6
+#else
+#error "Unknown IP5K silicon"
+#endif
+
+#define CACHE_LINE_SIZE 32			/* in bytes */
+
+#define CCR_ADDR 0x00
+#define CCR_RDD 0x04
+#define CCR_WRD 0x08
+#define CCR_STAT 0x0c
+#define CCR_CTRL 0x10
+
+#define CCR_STAT_MCBE 0
+#define CCR_STAT_WIDEL 1			/* D-cache only */
+
+#define CCR_CTRL_DONE 0
+#define CCR_CTRL_RESET 2
+#define CCR_CTRL_VALID 3
+#define CCR_CTRL_RD_DATA (1 << 4)
+#define CCR_CTRL_RD_TAG (2 << 4)
+#define CCR_CTRL_WR_DATA (3 << 4)
+#define CCR_CTRL_WR_TAG (4 << 4)
+#define CCR_CTRL_INV_INDEX (5 << 4)
+#define CCR_CTRL_INV_ADDR (6 << 4)
+#define CCR_CTRL_FLUSH_INDEX (7 << 4)		/* D-cache only */
+#define CCR_CTRL_FLUSH_INV_INDEX (8 << 4)	/* D-cache only */
+#define CCR_CTRL_FLUSH_ADDR (9 << 4)		/* D-cache only */
+#define CCR_CTRL_FLUSH_INV_ADDR (10 << 4)	/* D-cache only */
+
+/*
+ * OCP-OCMC
+ */
+#define OCMC_BASE (OCP_BASE + OCP_OCMC)
+#define OCMC_BANK_MASK 0x00
+#define OCMC_BIST_CNTL 0x04	/* IP5000 only */
+#define OCMC_BIST_STAT 0x08	/* IP5000 only */
+
+#define OCMC_BANK_PROG(n) ((1<<(n))-1)
+
+#define OCMC_BIST_WRCK (1 << 7)
+#define OCMC_BIST_RESET (1 << 5)
+#define OCMC_BIST_SMART (1 << 4)
+#define OCMC_BIST_RUN (1 << 3)
+#define OCMC_BIST_REPAIR (1 << 2)
+
+#define OCMC_BIST_READY (1 << 3)
+#define OCMC_BIST_FAIL (1 << 2)
+
+/*
+ * OCP-STATISTICS
+ */
+#define STATISTICS_BASE (OCP_BASE + OCP_STATISTICS)
+#define STAT_COUNTER_CTRL(n) ((n)*8)
+#define STAT_COUNTER(n) ((n)*8 + 4)
+
+#define STAT_EVENT_MP_INST 0
+#define STAT_EVENT_OCM_ACCESS 4
+#define STAT_EVENT_OCM_REQ 5
+#define STAT_EVENT_IC_REQ_INVAL 13
+#define STAT_EVENT_IC_MISS_INVAL 14
+#define STAT_EVENT_IC_REQ_INVAL_NACK 15
+#define STAT_EVENT_IC_REQ_VAL 16
+#define STAT_EVENT_IC_MISS_VAL 17
+#define STAT_EVENT_IC_REQ_VAL_NACK 18
+#define STAT_EVENT_IC_MISS_Q 19
+#define STAT_EVENT_DC_RD_REQ 20
+#define STAT_EVENT_DC_RD_MISS 21
+#define STAT_EVENT_DC_WR_REQ 22
+#define STAT_EVENT_DC_WR_MISS 23
+#define STAT_EVENT_DC_MISS_Q 24
+#define STAT_EVENT_DC_WB_FULL 25
+#define STAT_EVENT_DC_REQ_NACK 26
+#define STAT_EVENT_DC_CORE_REQ 27
+#define STAT_EVENT_DC_MISS 28
+#define STAT_EVENT_DC_EVICT 29
+#define STAT_EVENT_TRUE 30
+#define STAT_EVENT_FALSE 31
+
+/*
+ * OCP_MTEST
+ */
+#define MTEST_BASE (OCP_BASE + OCP_MTEST)
+#define MTEST_ADDR 0x00
+#define MTEST_WR 0x04
+#define MTEST_RD 0x08
+#define MTEST_CTRL 0x0c
+
+/*
+ * OCP_MCFG (IP7000 only)
+ */
+#define MCFG_BASE (OCP_BASE + OCP_MCFG)
+#define MCFG_CTRL 0x00
+#define MCFG_WCFG 0x04
+#define MCFG_RCFG 0x08
+
+/*
+ * Port registers
+ */
+#define IO_BASE 0x02000000
+#define RA (IO_BASE + 0x00000000)
+#define RB (IO_BASE + 0x00001000)
+#define RC (IO_BASE + 0x00002000)
+#define RD (IO_BASE + 0x00003000)
+#define RE (IO_BASE + 0x00004000)
+#define RF (IO_BASE + 0x00005000)
+#define RG (IO_BASE + 0x00006000)
+#define RH (IO_BASE + 0x00007000)
+#define RI (IO_BASE + 0x00008000)
+#define RJ (IO_BASE + 0x00009000)
+#define RLATCH (IO_BASE + 0x00ff0000)	// For latched output only
+#define IO_PORT_BR_OFFSET 0x00000800
+
+/*
+ * General I/O Register Map (per port)
+ */
+#define IO_FUNC 0x00
+#define IO_GPIO_CTL 0x04
+#define IO_GPIO_OUT 0x08
+#define IO_GPIO_IN 0x0C
+#define IO_INT_STATUS 0x10
+#define IO_INT_MASK 0x14
+#define IO_INT_SET 0x18
+#define IO_INT_CLR 0x1C
+#define IO_TX_FIFO 0x20
+#define IO_TX_FIFO_HI 0x24
+#define IO_RX_FIFO 0x28
+#define IO_RX_FIFO_HI 0x2c
+#define IO_CTL0 0x30
+#define IO_CTL1 0x34
+#define IO_CTL2 0x38
+#define IO_STATUS0 0x3c
+#define IO_STATUS1 0x40
+#define IO_STATUS2 0x44
+#define IO_FIFO_WATER 0x48
+#define IO_FIFO_LEVEL 0x4c
+#define IO_GPIO_MASK 0x50
+
+#define IO_FUNC_FUNCTION_RESET(func) ((1 << ((func) - 1)) << 4)	/* Function 0 doesn't need reset */
+#define IO_FUNC_RX_FIFO (1 << 3)
+#define IO_FUNC_SELECT(func) ((func) << 0)
+
+/*
+ * External interrupt pins.
+ */
+#define EXT_INT_IO_BIT(pin) ((pin) + 5)	// Interrupt pin number -> I/O INT bit
+#define EXT_INT_RISING_EDGE(pin) (0x2 << (2*(pin) + 7))
+#define EXT_INT_FALLING_EDGE(pin) (0x1 << (2*(pin) + 7))
+
+/*
+ * Flash
+ */
+#define IO_XFL_BASE RA
+
+#define IO_XFL_INT_START (1 << 16)
+#define IO_XFL_INT_ERR (1 << 8)
+#define IO_XFL_INT_DONE (1 << 0)
+
+#define IO_XFL_CTL0_MASK (0xffe07fff)
+#define IO_XFL_CTL0_RD_CMD(cmd) (((cmd) & 0xff) << 24)
+#define IO_XFL_CTL0_RD_DUMMY(n) (((n) & 0x7) << 21)
+#define IO_XFL_CTL0_CLK_WIDTH(core_cycles) ((((core_cycles) + 1) & 0x7e) << 8)	/* must be even number */
+#define IO_XFL_CTL0_CE_WAIT(spi_cycles) (((spi_cycles) & 0x3f) << 2)
+#define IO_XFL_CTL0_MCB_LOCK (1 << 1)
+#define IO_XFL_CTL0_ENABLE (1 << 0)
+#define IO_XFL_CTL0_FAST_VALUE(div, wait) (IO_XFL_CTL0_RD_CMD(0xb) | IO_XFL_CTL0_RD_DUMMY(1) | IO_XFL_CTL0_CLK_WIDTH(div) | IO_XFL_CTL0_CE_WAIT(wait) | IO_XFL_CTL0_ENABLE)
+#define IO_XFL_CTL0_VALUE(div, wait) (IO_XFL_CTL0_RD_CMD(3) | IO_XFL_CTL0_CLK_WIDTH(div) | IO_XFL_CTL0_CE_WAIT(wait) | IO_XFL_CTL0_ENABLE)
+
+#define IO_XFL_CTL1_MASK (0xc0003fff)
+#define IO_XFL_CTL1_FC_INST(inst) (((inst) & 0x3) << 30)
+#define IO_XFL_CTL1_FC_DATA(n) (((n) & 0x3ff) << 4)
+#define IO_XFL_CTL1_FC_DUMMY(n) (((n) & 0x7) << 1)
+#define IO_XFL_CTL1_FC_ADDR (1 << 0)
+
+#define IO_XFL_CTL2_FC_CMD(cmd) (((cmd) & 0xff) << 24)
+#define IO_XFL_CTL2_FC_ADDR(addr) ((addr) & 0x00ffffff)	/* Only up to 24 bits */
+
+#define IO_XFL_STATUS0_MCB_ACTIVE (1 << 0)
+#define IO_XFL_STATUS0_IOPCS_ACTIVE (1 << 1)
+
+/*
+ * SDRAM
+ */
+#define IO_SDRAM_DATA_BASE RG
+#define IO_SDRAM_CNTL_BASE RH
+
+#define IO_SDRAM_CTRL0_EN_REF (1 << 0)
+
+/*
+ * Port function code (common fucntion codes for all I/O ports)
+ */
+#define IO_PORTX_FUNC_GPIO 0x00
+#define IO_PORTX_FUNC_XFL 0x01
+#define IO_PORTX_FUNC_PCI 0x01
+#define IO_PORTX_FUNC_SERDES 0x01
+#define IO_PORTX_FUNC_GMII 0x01
+#define IO_PORTX_FUNC_DDR 0x01
+#define IO_PORTX_FUNC_PCIX 0x01
+#define IO_PORTX_FUNC_USB2_0 0x01
+#define IO_PORTX_FUNC_GPIO_INT_CLK 0x02
+#define IO_PORTX_FUNC_PLIO 0x02
+#define IO_PORTX_FUNC_GPIO_INT 0x03
+#define IO_PORTX_FUNC_MII 0x03
+
+/*
+ * Port 0
+ */
+#define IO_PORT0_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT0_FUNC_XFL_INT_CLK IO_PORTX_FUNC_XFL	// Default mode after reset
+#define IO_PORT0_FUNC_GPIO_INT_CLK IO_PORTX_FUNC_GPIO_INT_CLK
+#define IO_PORT0_FUNC_GPIO_INT IO_PORTX_FUNC_GPIO_INT
+
+/*
+ * Port 1
+ */
+#define IO_PORT1_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT1_FUNC_PCI IO_PORTX_FUNC_PCI		// PCI control
+#define IO_PORT1_FUNC_MII IO_PORTX_FUNC_MII		// port 4 MII extension
+
+/*
+ * Port 2
+ */
+#define IO_PORT2_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT2_FUNC_PCI IO_PORTX_FUNC_PCI		// PCI data I/O
+#define IO_PORT2_FUNC_PLIO IO_PORTX_FUNC_PLIO		// Extended LM
+
+/*
+ * Port 3
+ */
+#define IO_PORT3_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT3_FUNC_SERDES IO_PORTX_FUNC_SERDES
+#define IO_PORT3_FUNC_PLIO IO_PORTX_FUNC_PLIO
+
+/*
+ * Port 4
+ */
+#define IO_PORT4_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT4_FUNC_SERDES IO_PORTX_FUNC_SERDES
+#define IO_PORT4_FUNC_PLIO IO_PORTX_FUNC_PLIO		// Extended LM
+#define IO_PORT4_FUNC_MII IO_PORTX_FUNC_MII
+
+/*
+ * Port 5
+ */
+#define IO_PORT5_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT5_FUNC_GMII IO_PORTX_FUNC_GMII
+
+/*
+ * Port 6
+ */
+#define IO_PORT6_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT6_FUNC_DDR IO_PORTX_FUNC_DDR
+
+/*
+ * Port 7
+ */
+#define IO_PORT7_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT7_FUNC_DDR IO_PORTX_FUNC_DDR
+
+/*
+ * Port 8
+ */
+#define IO_PORT8_FUNC_GPIO IO_PORTX_FUNC_GPIO
+#define IO_PORT8_FUNC_PCIX IO_PORTX_FUNC_PCIX
+#define IO_PORT8_FUNC_PLIO IO_PORTX_FUNC_PLIO		// Extended LM
+#define IO_PORT8_FUNC_MII IO_PORTX_FUNC_MII		// port 4 MII extension
+
+/*
+ * Port 9
+ */
+#define IO_PORT9_FUNC_USB2_0 IO_PORTX_FUNC_USB2_0
+
+/*
+ * FIFO
+ */
+#define IO_PORTX_INT_FIFO_TX_RESET (1 << 31)
+#define IO_PORTX_INT_FIFO_RX_RESET (1 << 30)
+#define IO_PORTX_INT_FIFO_TX_UF (1 << 15)
+#define IO_PORTX_INT_FIFO_TX_WM (1 << 14)
+#define IO_PORTX_INT_FIFO_RX_OF (1 << 13)
+#define IO_PORTX_INT_FIFO_RX_WM (1 << 12)
+
+#define IO_PORTX_FUNC_FIFO_TX_WM(n) ((n) << 16)
+#define IO_PORTX_FUNC_FIFO_RX_WM(n) ((n) << 0)
+
+/*
+ * MII
+ */
+#define IO_PORTX_INT_MII_TX_ERR_SEND (1 << 18)
+#define IO_PORTX_INT_MII_TX_HALT (1 << 17)
+#define IO_PORTX_INT_MII_TX_START (1 << 16)
+#define IO_PORTX_INT_MII_THRESHOLD (1 << 8)
+#define IO_PORTX_INT_MII_RX_EOP (1 << 7)
+#define IO_PORTX_INT_MII_RX_SFD (1 << 6)
+#define IO_PORTX_INT_MII_RX_ERR (1 << 5)
+#define IO_PORTX_INT_MII_TX_EOP (1 << 4)
+#define IO_PORTX_INT_MII_COL (1 << 3)
+#define IO_PORTX_INT_MII_CRS (1 << 2)
+#define IO_PORTX_INT_MII_ODD_NIB_ERR (1 << 1)
+#define IO_PORTX_INT_MII_FALSE_CARRIER (1 << 0)
+
+/*
+ * SerDes
+ */
+#define IO_PORTX_INT_SERDES_TXBUF_VALID (1 << 16)
+#define IO_PORTX_INT_SERDES_RXERR (1 << 7)
+#define IO_PORTX_INT_SERDES_RXEOP (1 << 6)
+#define IO_PORTX_INT_SERDES_SYND (1 << 5)
+#define IO_PORTX_INT_SERDES_TXBE (1 << 4)
+#define IO_PORTX_INT_SERDES_TXEOP (1 << 3)
+#define IO_PORTX_INT_SERDES_SXLP (1 << 2)
+#define IO_PORTX_INT_SERDES_RXBF (1 << 1)
+#define IO_PORTX_INT_SERDES_RXCRS (1 << 0)
+
+#ifndef __ASSEMBLY__
+struct ubicom32_io_port {
+	volatile u32_t function;
+	volatile u32_t gpio_ctl;
+	volatile u32_t gpio_out;
+	volatile u32_t gpio_in;
+	volatile u32_t int_status;
+	volatile u32_t int_mask;
+	volatile u32_t int_set;
+	volatile u32_t int_clr;
+	volatile u32_t tx_fifo;
+	volatile u32_t tx_fifo_hi;
+	volatile u32_t rx_fifo;
+	volatile u32_t rx_fifo_hi;
+	volatile u32_t ctl0;
+	volatile u32_t ctl1;
+	volatile u32_t ctl2;
+	volatile u32_t status0;
+	volatile u32_t status1;
+	volatile u32_t status2;
+	volatile u32_t fifo_watermark;
+	volatile u32_t fifo_level;
+	volatile u32_t gpio_mask;
+};
+
+#define UBICOM32_IO_PORT(port) ((struct ubicom32_io_port *)((port)))
+#endif
+
+#ifndef __ASSEMBLY__
+/*
+ * ubicom32_set_interrupt()
+ */
+extern inline void ubicom32_set_interrupt(u8_t interrupt)
+{
+	u32_t ibit = INT_BIT_MASK(interrupt);
+
+	if (INT_REG(interrupt) == INT_REG(INT_CHIP(0, 0))) {
+		asm volatile (
+			"move.4		"D(INT_SET(INT_CHIP(0, 0)))", %0\n\t"
+			:
+			: "r" (ibit)
+		);
+
+		return;
+	}
+
+	asm volatile (
+		"move.4		"D(INT_SET(INT_CHIP(1, 0)))", %0\n\t"
+		:
+		: "r" (ibit)
+	);
+}
+
+/*
+ * ubicom32_clear_interrupt()
+ */
+extern inline void ubicom32_clear_interrupt(u8_t interrupt)
+{
+	u32_t ibit = INT_BIT_MASK(interrupt);
+
+	if (INT_REG(interrupt) == INT_REG(INT_CHIP(0, 0))) {
+		asm volatile (
+			"move.4		"D(INT_CLR(INT_CHIP(0, 0)))", %0\n\t"
+			:
+			: "r" (ibit)
+		);
+
+		return;
+	}
+
+	asm volatile (
+		"move.4		"D(INT_CLR(INT_CHIP(1, 0)))", %0\n\t"
+		:
+		: "r" (ibit)
+	);
+}
+
+/*
+ * ubicom32_enable_interrupt()
+ */
+extern inline void ubicom32_enable_interrupt(u8_t interrupt)
+{
+	u32_t ibit = INT_BIT_MASK(interrupt);
+
+	if (INT_REG(interrupt) == INT_REG(INT_CHIP(0, 0))) {
+		asm volatile (
+			"or.4		"D(INT_MASK(INT_CHIP(0, 0)))", "D(INT_MASK(INT_CHIP(0, 0)))", %0\n\t"
+			:
+			: "d" (ibit)
+		);
+
+		return;
+	}
+
+	asm volatile (
+		"or.4		"D(INT_MASK(INT_CHIP(1, 0)))", "D(INT_MASK(INT_CHIP(1, 0)))", %0\n\t"
+		:
+		: "d" (ibit)
+	);
+}
+
+/*
+ * ubicom32_disable_interrupt()
+ */
+extern inline void ubicom32_disable_interrupt(u8_t interrupt)
+{
+	u32_t ibit = ~INT_BIT_MASK(interrupt);
+
+	if (INT_REG(interrupt) == INT_REG(INT_CHIP(0, 0))) {
+		asm volatile (
+			"and.4		"D(INT_MASK(INT_CHIP(0, 0)))", "D(INT_MASK(INT_CHIP(0, 0)))", %0\n\t"
+			:
+			: "d" (ibit)
+		);
+
+		return;
+	}
+
+	asm volatile (
+		"and.4		"D(INT_MASK(INT_CHIP(1, 0)))", "D(INT_MASK(INT_CHIP(1, 0)))", %0\n\t"
+		:
+		: "d" (ibit)
+	);
+}
+
+/*
+ * ubicom32_enable_global_interrupts()
+ */
+extern inline void ubicom32_enable_global_interrupts(void)
+{
+	asm volatile(
+		"bset		GLOBAL_CTRL, GLOBAL_CTRL, #%bit("D(GLOBAL_CTRL_INT_EN)")"
+	);
+}
+
+/*
+ * ubicom32_disable_global_interrupts()
+ */
+extern inline void ubicom32_disable_global_interrupts(void)
+{
+	asm volatile(
+		"bclr		GLOBAL_CTRL, GLOBAL_CTRL, #%bit("D(GLOBAL_CTRL_INT_EN)")"
+	);
+}
+
+/*
+ * ubicom32_get_reset_reason()
+ */
+extern inline u32_t ubicom32_get_reset_reason(void)
+{
+	return *(u32_t *)(GENERAL_CFG_BASE + GEN_RESET_REASON);
+}
+
+/*
+ * ubicom32_read_reg()
+ */
+extern inline u32_t ubicom32_read_reg(volatile void *reg)
+{
+	u32_t v;
+	asm volatile (
+		"move.4		%[dest], %[src]	\n\t"
+		: [dest] "=r" (v)
+		: [src] "m" (*(u32_t *)reg)
+	);
+	return v;
+}
+
+/*
+ * ubicom32_write_reg()
+ */
+extern inline void ubicom32_write_reg(volatile void *reg, u32_t v)
+{
+	asm volatile (
+		"move.4		%[dest], %[src]	\n\t"
+		:
+		: [src] "r" (v), [dest] "m" (*(u32_t *)reg)
+	);
+}
+
+#endif /* __ASSEMBLY__ */
+#endif /* _ASM_UBICOM32_IP5000_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ipcbuf.h linux-2.6.28.10/arch/ubicom32/include/asm/ipcbuf.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ipcbuf.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ipcbuf.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,55 @@
+/*
+ * arch/ubicom32/include/asm/ipcbuf.h
+ *   Definition of ipc64_perm struct for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_IPCBUF_H
+#define _ASM_UBICOM32_IPCBUF_H
+
+/*
+ * The user_ipc_perm structure for m68k architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t and seq
+ * - 2 miscellaneous 32-bit values
+ */
+struct ipc64_perm
+{
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+	unsigned short		__pad1;
+	unsigned short		seq;
+	unsigned short		__pad2;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* _ASM_UBICOM32_IPCBUF_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/irqflags.h linux-2.6.28.10/arch/ubicom32/include/asm/irqflags.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/irqflags.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/irqflags.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,94 @@
+/*
+ * arch/ubicom32/include/asm/irqflags.h
+ *   Raw implementation of local IRQ functions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_IRQFLAGS_H
+#define _ASM_UBICOM32_IRQFLAGS_H
+
+#include <linux/thread_info.h>
+#include <asm/ubicom32-common.h>
+#include <asm/smp.h>
+#include <asm/ldsr.h>
+
+#if defined(CONFIG_PREEMPT)
+#error Not supported by Ubicom32 irq handling, yet!
+#endif
+
+/*
+ * raw_local_irq_enable()
+ *	Enable interrupts for this thread.
+ */
+static inline void raw_local_irq_enable(void)
+{
+	ldsr_local_irq_enable();
+}
+
+/*
+ * raw_local_irq_disable()
+ *	Disable interrupts for this thread.
+ */
+static inline void raw_local_irq_disable(void)
+{
+	ldsr_local_irq_disable();
+}
+
+/*
+ * raw_local_save_flags()
+ *	Get the current IRQ state.
+ */
+#define raw_local_save_flags(flags) 		\
+do {						\
+	(flags) = ldsr_local_irq_is_disabled();	\
+} while (0)
+
+/*
+ * raw_local_irq_save()
+ *	Save the current interrupt state and disable interrupts.
+ */
+#define raw_local_irq_save(flags)		\
+do {						\
+	(flags) = ldsr_local_irq_save();	\
+} while (0)
+
+/*
+ * raw_local_irq_restore()
+ *	Restore the IRQ state back to flags.
+ */
+static inline void raw_local_irq_restore(unsigned long flags)
+{
+	ldsr_local_irq_restore(flags);
+}
+
+/*
+ * raw_irqs_disabled_flags()
+ *	Return true if the flags indicate that IRQ(s) are disabled.
+ */
+static inline int raw_irqs_disabled_flags(unsigned long flags)
+{
+	return (flags);
+}
+
+#endif /* _ASM_UBICOM32_IRQFLAGS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/irq.h linux-2.6.28.10/arch/ubicom32/include/asm/irq.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/irq.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/irq.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,45 @@
+/*
+ * arch/ubicom32/include/asm/irq.h
+ *   IRQ definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_IRQ_H
+#define _ASM_UBICOM32_IRQ_H
+
+#include <asm/irqflags.h>
+
+/*
+ * We setup the IRQS to cover the full range of interrupt registers in
+ * processor.
+ */
+#define NR_IRQS		64
+
+#define irq_canonicalize(irq) (irq)
+
+extern int irq_soft_alloc(unsigned int *soft);
+extern void ack_bad_irq(unsigned int irq);
+extern void do_IRQ(int irq, struct pt_regs *fp);
+
+#endif /* _ASM_UBICOM32_IRQ_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/irq_regs.h linux-2.6.28.10/arch/ubicom32/include/asm/irq_regs.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/irq_regs.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/irq_regs.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/irq_regs.h
+ *   Generic irq_regs.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_IRQ_REGS_H
+#define _ASM_UBICOM32_IRQ_REGS_H
+
+#include <asm-generic/irq_regs.h>
+
+#endif /* _ASM_UBICOM32_IRQ_REGS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/Kbuild linux-2.6.28.10/arch/ubicom32/include/asm/Kbuild
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/Kbuild	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/Kbuild	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1 @@
+include include/asm-generic/Kbuild.asm
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/kdebug.h linux-2.6.28.10/arch/ubicom32/include/asm/kdebug.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/kdebug.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/kdebug.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/kdebug.h
+ *   Generic kdebug.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_KDEBUG_H
+#define _ASM_UBICOM32_KDEBUG_H
+
+#include <asm-generic/kdebug.h>
+
+#endif /* _ASM_UBICOM32_KDEBUG_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/kmap_types.h linux-2.6.28.10/arch/ubicom32/include/asm/kmap_types.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/kmap_types.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/kmap_types.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,48 @@
+/*
+ * arch/ubicom32/include/asm/kmap_types.h
+ *   Definition of km_type's for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_KMAP_TYPES_H
+#define _ASM_UBICOM32_KMAP_TYPES_H
+
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BIO_SRC_IRQ,
+	KM_BIO_DST_IRQ,
+	KM_PTE0,
+	KM_PTE1,
+	KM_IRQ0,
+	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#endif /* _ASM_UBICOM32_KMAP_TYPES_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ldsr.h linux-2.6.28.10/arch/ubicom32/include/asm/ldsr.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ldsr.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ldsr.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,186 @@
+/*
+ * arch/ubicom32/include/asm/ldsr.h
+ *   Ubicom32 LDSR interface definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_LDSR_H
+#define _ASM_UBICOM32_LDSR_H
+
+#include <asm/ubicom32-common.h>
+#include <asm/types.h>
+#include <asm/thread.h>
+
+extern unsigned int ldsr_soft_irq_mask;
+
+/*
+ * ldsr_local_irq_is_disabled()
+ *	Test if interrupts are disabled for this thread?
+ */
+static inline int ldsr_local_irq_is_disabled(void)
+{
+	int ret;
+	thread_t self = thread_get_self();
+	unsigned int mask = (1 << self);
+
+	asm volatile (
+	"	and.4	%0, scratchpad1, %1	\n\t"
+		: "=r" (ret)
+		: "d" (mask)
+		: "cc"
+	);
+
+	/*
+	 *  We return a simple 1 == disabled, 0 == enabled
+	 *  losing which tid this is for, because Linux
+	 *  can restore interrupts on a different thread.
+	 */
+	return ret >> self;
+}
+
+/*
+ * ldsr_local_irq_save()
+ *	Get the current interrupt state and disable interrupts.
+ */
+static inline unsigned int ldsr_local_irq_save(void)
+{
+	int ret;
+	thread_t self = thread_get_self();
+	unsigned int mask = (1 << self);
+
+	/*
+	 * Ensure the compiler can not optimize out the code
+	 * (volatile) and that it does not "cache" values around
+	 * the interrupt state change (memory).  This ensures
+	 * that interrupt changes are treated as a critical
+	 * section.
+	 */
+	asm volatile (
+	"	and.4	%0, scratchpad1, %1		\n\t"
+	"	or.4	scratchpad1, scratchpad1, %1	\n\t"
+		: "=&r" (ret)
+		: "d" (mask)
+		: "cc", "memory"
+	);
+
+	/*
+	 *  We return a simple 1 == disabled, 0 == enabled
+	 *  losing which tid this is for, because Linux
+	 *  can restore interrupts on a different thread.
+	 */
+	return ret >> self;
+}
+
+/*
+ * ldsr_local_irq_restore()
+ * 	Restore this cpu's interrupt enable/disable state.
+ *
+ * Note: flags is either 0 or 1.
+ */
+static inline void ldsr_local_irq_restore(unsigned int flags)
+{
+	unsigned int temp;
+	thread_t self = thread_get_self();
+	unsigned int mask = (1 << self);
+	flags = (flags << self);
+
+	/*
+	 * Ensure the compiler can not optimize out the code
+	 * (volatile) and that it does not "cache" values around
+	 * the interrupt state change (memory).  This ensures
+	 * that interrupt changes are treated as a critical
+	 * section.
+	 *
+	 * Atomic change to our bit in scratchpad1 without
+	 * causing any temporary glitch in the value and
+	 * without effecting other values.  Also this uses
+	 * no branches so no penalties.
+	 */
+	asm volatile (
+	"	xor.4	%0, scratchpad1, %1		\n\t"
+	"	and.4	%0, %2, %0			\n\t"
+	"	xor.4	scratchpad1, scratchpad1, %0	\n\t"
+	"	move.4	int_set0, %3			\n\t"
+		: "=&d"(temp)
+		: "d"(flags), "r"(mask), "r"(ldsr_soft_irq_mask)
+		: "cc", "memory"
+	);
+}
+
+/*
+ * ldsr_local_irq_disable_interrupt()
+ * 	Disable ints for this thread.
+ */
+static inline void ldsr_local_irq_disable(void)
+{
+	unsigned int mask = (1 << thread_get_self());
+
+	/*
+	 * Ensure the compiler can not optimize out the code
+	 * (volatile) and that it does not "cache" values around
+	 * the interrupt state change (memory).  This ensures
+	 * that interrupt changes are treated as a critical
+	 * section.
+	 */
+	asm  volatile (
+	"	or.4	scratchpad1, scratchpad1, %0	\n\t"
+		:
+		: "d" (mask)
+		: "cc", "memory"
+	);
+}
+
+/*
+ * ldsr_local_irq_enable_interrupt
+ * 	Enable ints for this thread.
+ */
+static inline void ldsr_local_irq_enable(void)
+{
+	unsigned int mask = (1 << thread_get_self());
+
+	/*
+	 * Ensure the compiler can not optimize out the code
+	 * (volatile) and that it does not "cache" values around
+	 * the interrupt state change (memory).  This ensures
+	 * that interrupt changes are treated as a critical
+	 * section.
+	 */
+	asm volatile (
+	"	and.4	scratchpad1, scratchpad1, %0	\n\t"
+	"	move.4	int_set0, %1			\n\t"
+		:
+		: "d" (~mask), "r" (ldsr_soft_irq_mask)
+		: "cc", "memory"
+	);
+}
+
+extern void ldsr_init(void);
+extern void ldsr_set_trap_irq(unsigned int irq);
+extern void ldsr_mask_vector(unsigned int vector);
+extern void ldsr_unmask_vector(unsigned int vector);
+extern void ldsr_enable_vector(unsigned int vector);
+extern void ldsr_disable_vector(unsigned int vector);
+extern thread_t ldsr_get_threadid(void);
+
+#endif /* _ASM_UBICOM32_LDSR_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/linkage.h linux-2.6.28.10/arch/ubicom32/include/asm/linkage.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/linkage.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/linkage.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * arch/ubicom32/include/asm/linkage.h
+ *   Definition of Ubicom32 architecture specific linkage types.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_LINKAGE_H
+#define _ASM_UBICOM32_LINKAGE_H
+
+#define __ocm_text __section(.ocm_text)
+#define __ocm_data __section(.ocm_data)
+
+#endif	/* _ASM_UBICOM32_LINKAGE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/local.h linux-2.6.28.10/arch/ubicom32/include/asm/local.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/local.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/local.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/local.h
+ *   Generic local.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_LOCAL_H
+#define _ASM_UBICOM32_LOCAL_H
+
+#include <asm-generic/local.h>
+
+#endif /* _ASM_UBICOM32_LOCAL_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/machdep.h linux-2.6.28.10/arch/ubicom32/include/asm/machdep.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/machdep.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/machdep.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,43 @@
+/*
+ * arch/ubicom32/include/asm/machdep.h
+ *   Machine dependent utility routines.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_MACHDEP_H
+#define _ASM_UBICOM32_MACHDEP_H
+
+#include <linux/interrupt.h>
+
+/* Hardware clock functions */
+extern unsigned long hw_timer_offset(void);
+
+/* machine dependent power off functions */
+extern void (*mach_reset)(void);
+extern void (*mach_halt)(void);
+extern void (*mach_power_off)(void);
+
+extern void config_BSP(char *command, int len);
+
+#endif /* _ASM_UBICOM32_MACHDEP_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/mc146818rtc.h linux-2.6.28.10/arch/ubicom32/include/asm/mc146818rtc.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/mc146818rtc.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/mc146818rtc.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,36 @@
+/*
+ * arch/ubicom32/include/asm/mc146818rtc.h
+ *   Generic mc146818rtc.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+/*
+ * Machine dependent access functions for RTC registers.
+ */
+#ifndef _ASM_UBICOM32_MC146818RTC_H
+#define _ASM_UBICOM32_MC146818RTC_H
+
+/* empty include file to satisfy the include in genrtc.c/ide-geometry.c */
+
+#endif /* _ASM_UBICOM32_MC146818RTC_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/mman.h linux-2.6.28.10/arch/ubicom32/include/asm/mman.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/mman.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/mman.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * arch/ubicom32/include/asm/mman.h
+ *   Memory mapping definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_MMAN_H
+#define _ASM_UBICOM32_MMAN_H
+
+#include <asm-generic/mman.h>
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+#define MAP_NORESERVE	0x4000		/* don't check for reservations */
+#define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x10000		/* do not block on IO */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#endif /* _ASM_UBICOM32_MMAN_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/mmu_context.h linux-2.6.28.10/arch/ubicom32/include/asm/mmu_context.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/mmu_context.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/mmu_context.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,60 @@
+/*
+ * arch/ubicom32/include/asm/mmu_context.h
+ *   MMU context definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2004, Microtronix Datacom Ltd., All rights reserved.          
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_MMU_CONTEXT_H
+#define _ASM_UBICOM32_MMU_CONTEXT_H
+
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+extern inline int
+init_new_context(struct task_struct *tsk, struct mm_struct *mm)
+{
+	// mm->context = virt_to_phys(mm->pgd);
+	return(0);
+}
+
+#define destroy_context(mm)		do { } while(0)
+
+static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk)
+{
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+
+extern inline void activate_mm(struct mm_struct *prev_mm, struct mm_struct *next_mm)
+{
+}
+
+#endif /* _ASM_UBICOM32_MMU_CONTEXT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/mmu.h linux-2.6.28.10/arch/ubicom32/include/asm/mmu.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/mmu.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/mmu.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,41 @@
+/*
+ * arch/ubicom32/include/asm/mmu.h
+ *   Definition of mm_context_t struct for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2002, David McCullough <davidm@snapgear.com>
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_MMU_H
+#define _ASM_UBICOM32_MMU_H
+
+typedef struct {
+	struct vm_list_struct	*vmlist;
+	unsigned long		end_brk;
+#ifdef CONFIG_BINFMT_ELF_FDPIC
+	unsigned long	exec_fdpic_loadmap;
+	unsigned long	interp_fdpic_loadmap;
+#endif
+} mm_context_t;
+
+#endif /* _ASM_UBICOM32_MMU_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/module.h linux-2.6.28.10/arch/ubicom32/include/asm/module.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/module.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/module.h	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * arch/ubicom32/include/asm/module.h
+ *   Ubicom32 architecture specific module definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_MODULE_H
+#define _ASM_UBICOM32_MODULE_H
+
+struct mod_arch_specific {
+	void *ocm_inst;
+	int ocm_inst_size;
+};
+
+#define Elf_Shdr Elf32_Shdr
+#define Elf_Sym Elf32_Sym
+#define Elf_Ehdr Elf32_Ehdr
+
+#define ARCH_PROC_MODULES_EXTRA(m,mod) \
+	seq_printf(m, " OCM(%d bytes @ 0x%p)", \
+		   (mod)->arch.ocm_inst_size, (mod)->arch.ocm_inst)
+
+#endif /* _ASM_UBICOM32_MODULE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/msgbuf.h linux-2.6.28.10/arch/ubicom32/include/asm/msgbuf.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/msgbuf.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/msgbuf.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,58 @@
+/*
+ * arch/ubicom32/include/asm/msgbuf.h
+ *   Definition of msqid64_ds struct for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_MSGBUF_H
+#define _ASM_UBICOM32_MSGBUF_H
+
+/*
+ * The msqid64_ds structure for ubicom32 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long	__unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long	__unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long	__unused3;
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif /* _ASM_UBICOM32_MSGBUF_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/mutex.h linux-2.6.28.10/arch/ubicom32/include/asm/mutex.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/mutex.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/mutex.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,41 @@
+/*
+ * arch/ubicom32/include/asm/mutex.h
+ *   Generic mutex.h for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+/*
+ * Pull in the generic implementation for the mutex fastpath.
+ *
+ * TODO: implement optimized primitives instead, or leave the generic
+ * implementation in place, or pick the atomic_xchg() based generic
+ * implementation. (see asm-generic/mutex-xchg.h for details)
+ */
+
+#ifndef _ASM_UBICOM32_MUTEX_H
+#define _ASM_UBICOM32_MUTEX_H
+
+#include <asm-generic/mutex-dec.h>
+
+#endif /* _ASM_UBICOM32_MUTEX_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/namei.h linux-2.6.28.10/arch/ubicom32/include/asm/namei.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/namei.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/namei.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,38 @@
+/*
+ * arch/ubicom32/include/asm/namei.h
+ *   Definition of __emul_prefix() for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_NAMEI_H
+#define _ASM_UBICOM32_NAMEI_H
+
+/* This dummy routine maybe changed to something useful
+ * for /usr/gnemul/ emulation stuff.
+ * Look at asm-sparc/namei.h for details.
+ */
+
+#define __emul_prefix() NULL
+
+#endif /* _ASM_UBICOM32_NAMEI_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ocm-alloc.h linux-2.6.28.10/arch/ubicom32/include/asm/ocm-alloc.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ocm-alloc.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ocm-alloc.h	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,36 @@
+/*
+ * arch/ubicom32/include/asm/ocm-alloc.h
+ *   Ubicom32 architecture specific ocm definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_OCM_ALLOC_H
+#define _ASM_UBICOM32_OCM_ALLOC_H
+
+
+extern void *ocm_inst_alloc(size_t size, pid_t pid);
+extern int ocm_free(const void *ptr);
+extern int ocm_inst_free(const void *ptr);
+
+#endif /* _ASM_UBICOM32_OCM_ALLOC_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ocm_size.h linux-2.6.28.10/arch/ubicom32/include/asm/ocm_size.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ocm_size.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ocm_size.h	2009-08-06 11:15:34.000000000 +0300
@@ -0,0 +1,2 @@
+#define APP_OCM_CODE_SIZE (0x3ffc2e00-0x3ffc0000)
+#define APP_OCM_DATA_SIZE (0x3ffd3500-0x3ffc8000)
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ocm_text.lds.inc linux-2.6.28.10/arch/ubicom32/include/asm/ocm_text.lds.inc
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ocm_text.lds.inc	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ocm_text.lds.inc	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,175 @@
+/*
+ * arch/ubicom32/include/asm/ocm_text.lds.inc
+ *	<TODO: Replace with short file description>
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+*(.text.do_csum)
+*(.text.tcp_packet)
+*(.text.ipt_do_table)
+*(.text.nf_conntrack_in)
+*(.text.ip_forward)
+*(.text.dev_queue_xmit)
+*(.text.netif_receive_skb)
+*(.text.ip_route_input)
+*(.text.ip_finish_output)
+*(.text.nf_iterate)
+*(.text.__hash_conntrack)
+*(.text.memset)
+*(.text.memcpy)
+*(.text.ip_rcv)
+*(.text.__nf_conntrack_find)
+*(.text.dev_hard_start_xmit)
+*(.text.vlan_dev_hard_start_xmit)
+*(.text.vlan_dev_hard_header)
+*(.text.__nf_ct_refresh_acct)
+*(.text.tcp_error)
+*(.text.pfifo_fast_enqueue)
+*(.text.ipv4_confirm)
+*(.text.ip_output)
+*(.text.neigh_connected_output)
+*(.text.nf_hook_slow)
+*(.text.nf_nat_packet)
+*(.text.local_bh_enable)
+*(.text.pfifo_fast_dequeue)
+*(.text.ubi32_eth_receive)
+*(.text.nf_nat_fn)
+*(.text.skb_checksum)
+*(.text.memmove)
+*(.text.ubi32_eth_tx_done)
+*(.text.eth_header)
+*(.text.skb_release_data)
+*(.text.nf_conntrack_find_get)
+*(.text.process_backlog)
+*(.text.vlan_skb_recv)
+*(.text.ip_rcv_finish)
+*(.text.__qdisc_run)
+*(.text.skb_push)
+*(.text.eth_type_trans)
+*(.text.__alloc_skb)
+*(.text.netif_rx)
+*(.text.nf_ip_checksum)
+*(.text.__skb_checksum_complete_head)
+*(.text.ipv4_conntrack_defrag)
+*(.text.tcp_pkt_to_tuple)
+*(.text.kfree)
+*(.text.tcp_manip_pkt)
+*(.text.skb_put)
+*(.text.nf_ct_get_tuple)
+*(.text.__kmalloc)
+*(.text.ubi32_eth_start_xmit)
+*(.text.free_block)
+*(.text.ipt_hook)
+*(.text.kmem_cache_free)
+*(.text.skb_pull_rcsum)
+*(.text.cache_alloc_refill)
+*(.text.skb_release_head_state)
+*(.text.manip_pkt)
+*(.text.ip_sabotage_in)
+*(.text.ip_forward_finish)
+*(.text.kmem_cache_alloc)
+*(.text.local_bh_disable)
+*(.text.ipv4_pkt_to_tuple)
+*(.text.inet_proto_csum_replace4)
+*(.text.__nf_ct_l4proto_find)
+*(.text.csum_partial)
+*(.text.neigh_resolve_output)
+*(.text.__kfree_skb)
+*(.text.kfree_skb)
+*(.text.__find_vlan_dev)
+*(.text.ldsr_ctxsw_thread)
+*(.text.__do_IRQ)
+*(.text.skb_pull)
+*(.text.ipv4_invert_tuple)
+*(.text.nf_ct_invert_tuplepr)
+*(.text.skb_make_writable)
+*(.text.ipv4_get_l4proto)
+*(.text.handle_IRQ_event)
+*(.text.net_rx_action)
+*(.text.__do_softirq)
+*(.text.nf_nat_in)
+*(.text.note_interrupt)
+*(.text.ipv4_conntrack_in)
+*(.text.dst_release)
+*(.text.tasklet_action)
+*(.text.nf_nat_out)
+*(.text.nf_ct_invert_tuple)
+*(.text.do_IRQ)
+*(.text.__tasklet_schedule)
+*(.text.__skb_checksum_complete)
+*(.text.ubi32_eth_interrupt)
+*(.text.dev_kfree_skb_any)
+*(.text.ret_from_interrupt_to_kernel)
+*(.text.preemptive_context_save)
+*(.text.irq_ack_vector)
+*(.text.update_wall_time)
+*(.text.ldsr_thread)
+*(.text.irq_exit)
+*(.text.ubi32_eth_do_tasklet)
+*(.text.__napi_schedule)
+*(.text.idle_cpu)
+*(.text.run_timer_softirq)
+*(.text.ldsr_mask_vector)
+*(.text.irq_enter)
+*(.text.ldsr_get_lsb)
+*(.text.ldsr_unmask_vector)
+*(.text.ip_fast_csum)
+*(.text.hrtimer_run_queues)
+*(.text.tcp_invert_tuple)
+*(.text.T___705)
+*(.text.run_posix_cpu_timers)
+*(.text.free_hot_cold_page)
+*(.text.lock_timer_base)
+*(.text.calc_delta_mine)
+*(.text.slab_destroy)
+*(.text.rcu_pending)
+*(.text.scheduler_tick)
+*(.text.hrtimer_run_pending)
+*(.text.do_softirq)
+*(.text.del_timer)
+*(.text.irq_end_vector)
+*(.text.pci_read_u32)
+*(.text.udivmodsi4)
+*(.text.memcmp)
+*(.text.memset)
+*(.text.__slab_alloc)
+*(.text.br_handle_frame)
+*(.text.br_fdb_update)
+*(.text.__br_fdb_get)
+*(.text.br_forward)
+*(.text.br_handle_frame_finish)
+*(.text.pci_write_u32)
+*(.text.kmem_freepages)
+*(.text.br_dev_queue_push_xmit)
+*(.text.ioread32)
+*(.text.next_zones_zonelist)
+*(.text.ubi32_pci_read_u32)
+*(.text.zone_watermark_ok)
+*(.text.__rmqueue_smallest)
+*(.text.ubi32_eth_napi_poll)
+*(.text.ubi32_pci_write_u32)
+*(.text.ubi32_pci_read_u32)
+*(.text._local_bh_enable)
+*(.text._local_bh_disable)
+*(.text.get_slab)
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/page.h linux-2.6.28.10/arch/ubicom32/include/asm/page.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/page.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/page.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,106 @@
+/*
+ * arch/ubicom32/include/asm/page.h
+ *   Memory page related operations and definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_PAGE_H
+#define _ASM_UBICOM32_PAGE_H
+
+/* PAGE_SHIFT determines the page size */
+
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(1 << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#include <asm/setup.h>
+
+#ifndef __ASSEMBLY__
+
+#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
+#define free_user_page(page, addr)	free_page(addr)
+
+#define clear_page(page)	memset((page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((to), (from), PAGE_SIZE)
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+#define __alloc_zeroed_user_highpage(movableflags, vma, vaddr) \
+	alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd[16]; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+typedef struct page *pgtable_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((&x)->pmd[0])
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) } )
+#define __pmd(x)	((pmd_t) { (x) } )
+#define __pgd(x)	((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+#endif /* !__ASSEMBLY__ */
+
+#include <asm/page_offset.h>
+
+#define PAGE_OFFSET		(PAGE_OFFSET_RAW)
+
+#ifndef __ASSEMBLY__
+
+#define __pa(vaddr)		virt_to_phys((void *)(vaddr))
+#define __va(paddr)		phys_to_virt((unsigned long)(paddr))
+
+#define virt_to_pfn(kaddr)	(__pa(kaddr) >> PAGE_SHIFT)
+#define pfn_to_virt(pfn)	__va((pfn) << PAGE_SHIFT)
+
+#define virt_to_page(addr)	(mem_map + (((unsigned long)(addr)-PAGE_OFFSET) >> PAGE_SHIFT))
+#define page_to_virt(page)	((((page) - mem_map) << PAGE_SHIFT) + PAGE_OFFSET)
+
+#define pfn_to_page(pfn)	virt_to_page(pfn_to_virt(pfn))
+#define page_to_pfn(page)	virt_to_pfn(page_to_virt(page))
+#define pfn_valid(pfn)	        ((pfn) < max_mapnr)
+
+#define	virt_addr_valid(kaddr)	(((void *)(kaddr) >= (void *)PAGE_OFFSET) && \
+				((void *)(kaddr) < (void *)memory_end))
+
+#endif /* __ASSEMBLY__ */
+
+#ifdef __KERNEL__
+#include <asm-generic/page.h>
+#endif
+
+#endif /* _ASM_UBICOM32_PAGE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/page_offset.h linux-2.6.28.10/arch/ubicom32/include/asm/page_offset.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/page_offset.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/page_offset.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,35 @@
+/*
+ * arch/ubicom32/include/asm/page_offset.h
+ *   Definition of PAGE_OFFSET_RAW for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_PAGE_OFFSET_H
+#define _ASM_UBICOM32_PAGE_OFFSET_H
+
+/* This handles the memory map.. */
+#define	PAGE_OFFSET_RAW		0x3ffc0000
+
+#endif /* _ASM_UBICOM32_PAGE_OFFSET_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/param.h linux-2.6.28.10/arch/ubicom32/include/asm/param.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/param.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/param.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,49 @@
+/*
+ * arch/ubicom32/include/asm/param.h
+ *   Definition of miscellaneous constants, including HZ.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_PARAM_H
+#define _ASM_UBICOM32_PARAM_H
+
+#ifdef __KERNEL__
+#define HZ CONFIG_HZ
+#define	USER_HZ		HZ
+#define	CLOCKS_PER_SEC	(USER_HZ)
+#endif
+
+#ifndef HZ
+#define HZ	100
+#endif
+
+#define EXEC_PAGESIZE	4096
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* _ASM_UBICOM32_PARAM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/pci.h linux-2.6.28.10/arch/ubicom32/include/asm/pci.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/pci.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/pci.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,210 @@
+/*
+ * arch/ubicom32/include/asm/pci.h
+ *   Definitions of PCI operations for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_PCI_H
+#define _ASM_UBICOM32_PCI_H
+
+#include <asm/io.h>
+
+/* The PCI address space does equal the physical memory
+ * address space.  The networking and block device layers use
+ * this boolean for bounce buffer decisions.
+ */
+#define PCI_DMA_BUS_IS_PHYS	(1)
+
+
+
+/*
+ * Perform a master read/write to the PCI bus.
+ * These functions return a PCI_RESP_xxx code.
+ */
+extern u8 pci_read_u32(u8 pci_cmd, u32 address, u32 *data);
+extern u8 pci_write_u32(u8 pci_cmd, u32 address, u32 data);
+extern u8 pci_read_u16(u8 pci_cmd, u32 address, u16 *data);
+extern u8 pci_write_u16(u8 pci_cmd, u32 address, u16 data);
+extern u8 pci_read_u8(u8 pci_cmd, u32 address, u8 *data);
+extern u8 pci_write_u8(u8 pci_cmd, u32 address, u8 data);
+
+
+#define PCIBIOS_MIN_IO          0x100
+#define PCIBIOS_MIN_MEM         0x10000000
+
+#define pcibios_assign_all_busses()	0
+#define pcibios_scan_all_fns(a, b)	0
+extern void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+	struct resource *res);
+
+extern void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+	struct pci_bus_region *region);
+
+struct pci_sys_data;
+struct pci_bus;
+
+struct hw_pci {
+        struct list_head buses;
+        int             nr_controllers;
+        int             (*setup)(int nr, struct pci_sys_data *);
+        struct pci_bus *(*scan)(int nr, struct pci_sys_data *);
+        void            (*preinit)(void);
+        void            (*postinit)(void);
+        u8              (*swizzle)(struct pci_dev *dev, u8 *pin);
+        int             (*map_irq)(struct pci_dev *dev, u8 slot, u8 pin);
+};
+
+/*
+ * Per-controller structure
+ */
+struct pci_sys_data {
+        struct list_head node;
+        int             busnr;          /* primary bus number                   */
+        u64             mem_offset;     /* bus->cpu memory mapping offset       */
+        unsigned long   io_offset;      /* bus->cpu IO mapping offset           */
+        struct pci_bus  *bus;           /* PCI bus                              */
+        struct resource *resource[3];   /* Primary PCI bus resources            */
+                                        /* Bridge swizzling                     */
+        u8              (*swizzle)(struct pci_dev *, u8 *);
+                                        /* IRQ mapping                          */
+        int             (*map_irq)(struct pci_dev *, u8, u8);
+        struct hw_pci   *hw;
+};
+
+static  inline struct resource *
+pcibios_select_root(struct pci_dev *pdev, struct resource *res)
+{
+        struct resource *root = NULL;
+
+        if (res->flags & IORESOURCE_IO)
+                root = &ioport_resource;
+        if (res->flags & IORESOURCE_MEM)
+                root = &iomem_resource;
+
+        return root;
+}
+
+static inline void pcibios_set_master(struct pci_dev *dev)
+{
+        /* No special bus mastering setup handling */
+}
+#define HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_SIZE 1
+#define HAVE_ARCH_PCI_SET_DMA_SEGMENT_BOUNDARY 1
+
+#ifdef CONFIG_PCI
+static inline void * pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
+                     dma_addr_t *dma_handle)
+{
+    void *vaddr = kmalloc(size, GFP_KERNEL);
+    if(vaddr != NULL) {
+        *dma_handle = virt_to_phys(vaddr);
+    }
+    return vaddr;
+}
+
+static  inline int pci_dma_supported(struct pci_dev *hwdev, dma_addr_t mask)
+{
+ 	return 1;
+}
+
+static  inline void pci_free_consistent(struct pci_dev *hwdev, size_t size,
+	void *cpu_addr, dma_addr_t dma_handle)
+{ 
+	kfree(cpu_addr);
+	return;
+}
+
+static inline dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr,
+	size_t size, int direction)
+{
+	 return virt_to_phys(ptr);
+}
+
+static inline void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr,
+	size_t size, int direction)
+{
+	 return;
+}
+
+static inline dma_addr_t
+pci_map_page(struct pci_dev *hwdev, struct page *page,
+             unsigned long offset, size_t size, int direction)
+{
+	 return pci_map_single(hwdev, page_address(page) + offset, size, (int)direction);
+}
+
+static inline void
+pci_unmap_page(struct pci_dev *hwdev, dma_addr_t dma_address,
+               size_t size, int direction)
+{
+	pci_unmap_single(hwdev, dma_address, size, direction);
+}
+
+static inline int
+pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
+           int nents, int direction)
+{
+        return nents; 
+}
+
+static inline void
+pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
+             int nents, int direction)
+{
+}
+
+static inline void
+pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev, struct scatterlist *sg,
+                int nelems, int direction)
+{
+}
+
+static inline void
+pci_dma_sync_sg_for_device(struct pci_dev *hwdev, struct scatterlist *sg,
+                int nelems, int direction)
+{
+}
+
+static inline void
+pci_dma_sync_single_for_cpu(struct pci_dev *hwdev, dma_addr_t dma_handle,
+                    size_t size, int direction)
+{
+}
+
+static inline void
+pci_dma_sync_single_for_device(struct pci_dev *hwdev, dma_addr_t dma_handle,
+                    size_t size, int direction)
+{
+}
+
+static inline int
+pci_dma_mapping_error(struct pci_dev *hwdev, dma_addr_t dma_addr)
+{
+        return dma_addr == 0;
+}
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+#endif
+
+#endif /* _ASM_UBICOM32_PCI_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/percpu.h linux-2.6.28.10/arch/ubicom32/include/asm/percpu.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/percpu.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/percpu.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/percpu.h
+ *   Generic percpu.h for the Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_PERCPU_H
+#define _ASM_UBICOM32_PERCPU_H
+
+#include <asm-generic/percpu.h>
+
+#endif /* _ASM_UBICOM32_PERCPU_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/pgalloc.h linux-2.6.28.10/arch/ubicom32/include/asm/pgalloc.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/pgalloc.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/pgalloc.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,36 @@
+/*
+ * arch/ubicom32/include/asm/pgalloc.h
+ *   Page table allocation definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_PGALLOC_H
+#define _ASM_UBICOM32_PGALLOC_H
+
+#include <linux/mm.h>
+#include <asm/setup.h>
+
+#define check_pgt_cache()	do { } while (0)
+
+#endif /* _ASM_UBICOM32_PGALLOC_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/pgtable.h linux-2.6.28.10/arch/ubicom32/include/asm/pgtable.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/pgtable.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/pgtable.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,124 @@
+/*
+ * arch/ubicom32/include/asm/pgtable.h
+ *   Ubicom32 pseudo page table definitions and operations.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2004   Microtronix Datacom Ltd
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ *   and various works, Alpha, ix86, M68K, Sparc, ...et al
+ */
+#ifndef _ASM_UBICOM32_PGTABLE_H
+#define _ASM_UBICOM32_PGTABLE_H
+
+#include <asm-generic/4level-fixup.h>
+
+//vic - this bit copied from m68knommu version
+#include <asm/setup.h>
+#include <asm/io.h>
+#include <linux/sched.h>
+
+typedef pte_t *pte_addr_t;
+
+#define pgd_present(pgd)     	(1)       /* pages are always present on NO_MM */
+#define pgd_none(pgd)		(0)
+#define pgd_bad(pgd)		(0)
+#define pgd_clear(pgdp)
+#define kern_addr_valid(addr) 	(1)
+#define	pmd_offset(a, b)	((void *)0)
+
+#define PAGE_NONE		__pgprot(0)    /* these mean nothing to NO_MM */
+#define PAGE_SHARED		__pgprot(0)    /* these mean nothing to NO_MM */
+#define PAGE_COPY		__pgprot(0)    /* these mean nothing to NO_MM */
+#define PAGE_READONLY		__pgprot(0)    /* these mean nothing to NO_MM */
+#define PAGE_KERNEL		__pgprot(0)    /* these mean nothing to NO_MM */
+//vic - this bit copied from m68knommu version
+
+extern void paging_init(void);
+#define swapper_pg_dir ((pgd_t *) 0)
+
+#define __swp_type(x)		(0)
+#define __swp_offset(x)		(0)
+#define __swp_entry(typ,off)	((swp_entry_t) { ((typ) | ((off) << 7)) })
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+/*
+ * pgprot_noncached() is only for infiniband pci support, and a real
+ * implementation for RAM would be more complicated.
+ */
+#define pgprot_noncached(prot)	(prot)
+
+static inline int pte_file(pte_t pte) { return 0; }
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+#define ZERO_PAGE(vaddr)	(virt_to_page(0))
+
+extern unsigned int kobjsize(const void *objp);
+extern int is_in_rom(unsigned long);
+
+/*
+ * No page table caches to initialise
+ */
+#define pgtable_cache_init()   do { } while (0)
+
+#define io_remap_pfn_range(vma, vaddr, pfn, size, prot)		\
+		remap_pfn_range(vma, vaddr, pfn, size, prot)
+
+extern inline void flush_cache_mm(struct mm_struct *mm)
+{
+}
+
+extern inline void flush_cache_range(struct mm_struct *mm,
+				     unsigned long start,
+				     unsigned long end)
+{
+}
+
+/* Push the page at kernel virtual address and clear the icache */
+extern inline void flush_page_to_ram (unsigned long address)
+{
+}
+
+/* Push n pages at kernel virtual address and clear the icache */
+extern inline void flush_pages_to_ram (unsigned long address, int n)
+{
+}
+
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
+#define arch_enter_lazy_mmu_mode()	do {} while (0)
+#define arch_leave_lazy_mmu_mode()	do {} while (0)
+#define arch_flush_lazy_mmu_mode()	do {} while (0)
+#define arch_enter_lazy_cpu_mode()	do {} while (0)
+#define arch_leave_lazy_cpu_mode()	do {} while (0)
+#define arch_flush_lazy_cpu_mode()	do {} while (0)
+
+#endif /* _ASM_UBICOM32_PGTABLE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/poll.h linux-2.6.28.10/arch/ubicom32/include/asm/poll.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/poll.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/poll.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,36 @@
+/*
+ * arch/ubicom32/include/asm/poll.h
+ *   Ubicom32 specific poll() related flags definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_POLL_H
+#define _ASM_UBICOM32_POLL_H
+
+#define POLLWRNORM	POLLOUT
+#define POLLWRBAND	0x0100
+
+#include <asm-generic/poll.h>
+
+#endif /* _ASM_UBICOM32_POLL_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/posix_types.h linux-2.6.28.10/arch/ubicom32/include/asm/posix_types.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/posix_types.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/posix_types.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,93 @@
+/*
+ * arch/ubicom32/include/asm/posix_types.h
+ *   Ubicom32 architecture posix types.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2004   Microtronix Datacom Ltd
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef __ARCH_UBICOM32_POSIX_TYPES_H
+#define __ARCH_UBICOM32_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int	val[2];
+#else /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int	__val[2];
+#endif /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
+
+#undef	__FD_CLR
+#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
+
+#undef	__FD_ISSET
+#define	__FD_ISSET(d, set)	((set)->fds_bits[__FDELT(d)] & __FDMASK(d))
+
+#undef	__FD_ZERO
+#define __FD_ZERO(fdsetp) (memset (fdsetp, 0, sizeof(*(fd_set *)fdsetp)))
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/processor.h linux-2.6.28.10/arch/ubicom32/include/asm/processor.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/processor.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/processor.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,163 @@
+/*
+ * arch/ubicom32/include/asm/processor.h
+ *   Thread related definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 1995 Hamish Macdonald
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_PROCESSOR_H
+#define _ASM_UBICOM32_PROCESSOR_H
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+#include <linux/compiler.h>
+#include <linux/threads.h>
+#include <asm/types.h>
+#include <asm/segment.h>
+#include <asm/fpu.h>
+#include <asm/ptrace.h>
+#include <asm/current.h>
+#include <asm/thread_info.h>
+
+#if defined(CONFIG_UBICOM32_V3)
+	#define	CPU "IP5K"
+#endif
+#if defined(CONFIG_UBICOM32_V4)
+	#define	CPU "IP7K"
+#endif
+#ifndef CPU
+	#define	CPU "UNKNOWN"
+#endif
+
+/*
+ * User space process size: 1st byte beyond user address space.
+ */
+extern unsigned long memory_end;
+#define TASK_SIZE	(memory_end)
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's. We won't be using it
+ */
+#define TASK_UNMAPPED_BASE	0
+
+/*
+ * This is the structure where we are going to save callee-saved registers.
+ * A5 is the return address, A7 is the stack pointer, A6 is the frame
+ * pointer.  This is the frame that is created because of switch_to. This
+ * is not the frame due to interrupt preemption or because of syscall entry.
+ */
+
+struct thread_struct {
+	unsigned long  d10;		/* D10  */
+	unsigned long  d11;		/* D11  */
+	unsigned long  d12;		/* D12  */
+	unsigned long  d13;		/* D13  */
+	unsigned long  a1;		/* A1  */
+	unsigned long  a2;		/* A2  */
+	unsigned long  a5;		/* A5 return address. */
+	unsigned long  a6;		/* A6 */
+	unsigned long  sp;		/* A7 kernel stack pointer. */
+};
+
+#define INIT_THREAD  { \
+	0, 0, 0, 0, 0, 0, 0, 0, \
+	sizeof(init_stack) + (unsigned long) init_stack - 8, \
+}
+
+/*
+ * Do necessary setup to start up a newly executed thread.
+ *
+ * pass the data segment into user programs if it exists,
+ * it can't hurt anything as far as I can tell
+ */
+/*
+ * Do necessary setup to start up a newly executed thread.
+ */
+#define start_thread(regs, new_pc, new_sp)	 \
+	do {					 \
+		regs->pc = new_pc & ~3;		 \
+		regs->an[5] = new_pc & ~3;	 \
+		regs->an[7] = new_sp;		 \
+		regs->nesting_level = -1;	 \
+		regs->frame_type = UBICOM32_FRAME_TYPE_NEW_THREAD; \
+		regs->thread_type = NORMAL_THREAD; \
+	} while(0)
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+
+/* Free all resources held by a thread. */
+static inline void release_thread(struct task_struct *dead_task)
+{
+}
+
+/* Prepare to copy thread state - unlazy all lazy status */
+#define prepare_to_copy(tsk)	do { } while (0)
+
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/*
+ * Free current thread data structures etc..
+ */
+static inline void exit_thread(void)
+{
+}
+
+unsigned long thread_saved_pc(struct task_struct *tsk);
+unsigned long get_wchan(struct task_struct *p);
+
+#define	KSTK_EIP(tsk)	(tsk->thread.a5)
+#define	KSTK_ESP(tsk)	(tsk->thread.sp)
+
+#define cpu_relax()    barrier()
+
+extern void processor_init(void);
+extern unsigned int processor_timers(void);
+extern unsigned int processor_threads(void);
+extern unsigned int processor_frequency(void);
+extern int processor_interrupts(unsigned int *int0, unsigned int *int1);
+extern int processor_ocm(void **socm, void **eocm);
+extern int processor_dram(void **sdram, void **edram);
+
+#define THREAD_SIZE_LONGS      (THREAD_SIZE/sizeof(unsigned long))
+#define KSTK_TOP(info)                                                 \
+({                                                                     \
+       unsigned long *__ptr = (unsigned long *)(info);                 \
+       (unsigned long)(&__ptr[THREAD_SIZE_LONGS]);                     \
+})
+
+#define task_pt_regs(task)                                             \
+({                                                                     \
+       struct pt_regs *__regs__;                                       \
+       __regs__ = (struct pt_regs *)(KSTK_TOP(task_stack_page(task))-8); \
+       __regs__ - 1;                                                   \
+})
+
+#endif	/* _ASM_UBICOM32_PROCESSOR_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ptrace.h linux-2.6.28.10/arch/ubicom32/include/asm/ptrace.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ptrace.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ptrace.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,177 @@
+/*
+ * arch/ubicom32/include/asm/ptrace.h
+ *   Ubicom32 architecture ptrace support.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_PTRACE_H
+#define _ASM_UBICOM32_PTRACE_H
+
+#ifndef __ASSEMBLY__
+
+/*
+ * We use hard coded constants because this is shared with user
+ * space and the values are NOT allowed to change.  Only fields
+ * that are intended to be exposed get values.
+ */
+#define PT_D0           0
+#define PT_D1           4
+#define PT_D2           8
+#define PT_D3           12
+#define PT_D4           16
+#define PT_D5           20
+#define PT_D6           24
+#define PT_D7           28
+#define PT_D8           32
+#define PT_D9           36
+#define PT_D10          40
+#define PT_D11          44
+#define PT_D12          48
+#define PT_D13          52
+#define PT_D14          56
+#define PT_D15          60
+#define PT_A0           64
+#define PT_A1           68
+#define PT_A2           72
+#define PT_A3           76
+#define PT_A4           80
+#define PT_A5           84
+#define PT_A6           88
+#define PT_A7           92
+#define PT_SP           92
+#define PT_ACC0HI       96
+#define PT_ACC0LO       100
+#define PT_MAC_RC16     104
+#define PT_ACC1HI       108
+#define PT_ACC1LO       112
+#define PT_SOURCE3      116
+#define PT_INST_CNT     120
+#define PT_CSR          124
+#define PT_DUMMY_UNUSED 128
+#define PT_INT_MASK0    132
+#define PT_INT_MASK1    136
+#define PT_TRAP_CAUSE   140
+#define PT_PC           144
+#define PT_ORIGINAL_D0  148
+#define PT_FRAME_TYPE   152
+
+/*
+ * The following 'registers' are not registers at all but are used
+ * locate the relocated sections.
+ */
+#define PT_TEXT_ADDR		200
+#define PT_TEXT_END_ADDR	204
+#define PT_DATA_ADDR		208
+#define PT_EXEC_FDPIC_LOADMAP	212
+#define PT_INTERP_FDPIC_LOADMAP	216
+
+/*
+ * This struct defines the way the registers are stored on the
+ * stack during a system call.
+ */
+enum thread_type {
+	NORMAL_THREAD,
+	KERNEL_THREAD,
+};
+
+#define UBICOM32_FRAME_TYPE_SYSCALL	-1 /* System call frame */
+#define UBICOM32_FRAME_TYPE_INVALID	0 /* Invalid frame, no longer in use */
+#define UBICOM32_FRAME_TYPE_INTERRUPT	1 /* Interrupt frame */
+#define UBICOM32_FRAME_TYPE_TRAP	2 /* Trap frame */
+#define UBICOM32_FRAME_TYPE_SIGTRAMP	3 /* Signal trampoline frame. */
+#define UBICOM32_FRAME_TYPE_NEW_THREAD	4 /* New Thread. */
+
+struct pt_regs {
+	/*
+	 * Data Registers
+	 */
+	unsigned long dn[16];
+
+	/*
+	 * Address Registers
+	 */
+	unsigned long an[8];
+
+	/*
+	 * Per thread misc registers.
+	 */
+	unsigned long acc0[2];
+	unsigned long mac_rc16;
+	unsigned long acc1[2];
+	unsigned long source3;
+	unsigned long inst_cnt;
+	unsigned long csr;
+	unsigned long dummy_unused;
+	unsigned long int_mask0;
+	unsigned long int_mask1;
+	unsigned long trap_cause;
+	unsigned long pc;
+	unsigned long original_dn_0;
+
+	/*
+	 * Frame type. Syscall frames are -1. For other types look above.
+	 */
+	unsigned long frame_type;
+
+	/*
+	 * These fields are not exposed to ptrace.
+	 */
+	unsigned long previous_pc;
+	long nesting_level;		/* When the kernel in in user space this
+					 * will be -1. */
+	unsigned long thread_type;	/* This indicates if this is a kernel
+					 * thread. */
+};
+
+/*
+ * This is the extended stack used by signal handlers and the context
+ * switcher: it's pushed after the normal "struct pt_regs".
+ */
+struct switch_stack {
+	unsigned long  dummy;
+};
+
+#ifdef __KERNEL__
+
+/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+
+#ifndef PS_S
+#define PS_S  (0x2000)
+#define PS_M  (0x1000)
+#endif
+
+extern  int __user_mode(unsigned long sp);
+
+#define user_mode(regs) (__user_mode((regs->an[7])))
+#define user_stack(regs) ((regs)->an[7])
+#define instruction_pointer(regs) ((regs)->pc)
+#define profile_pc(regs) instruction_pointer(regs)
+extern void show_regs(struct pt_regs *);
+#endif /* __KERNEL__ */
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_UBICOM32_PTRACE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/range-protect-asm.h linux-2.6.28.10/arch/ubicom32/include/asm/range-protect-asm.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/range-protect-asm.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/range-protect-asm.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,91 @@
+/*
+ * arch/ubicom32/include/asm/range-protect-asm.h
+ *   Assembly macros for enabling memory protection.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_RANGE_PROTECT_ASM_H
+#define _ASM_UBICOM32_RANGE_PROTECT_ASM_H
+
+#if defined(__ASSEMBLY__)
+
+#include <asm/thread-asm.h>
+
+/*
+ * You should only use the enable/disable ranges when you have the atomic lock,
+ * if you do not there will be problems.
+ */
+
+/*
+ * enable_kernel_ranges
+ *	Enable the kernel ranges (disabling protection) for thread,
+ *	where thread == (1 << thread number)
+ */
+.macro	enable_kernel_ranges thread
+#ifdef CONFIG_PROTECT_KERNEL
+	or.4	I_RANGE0_EN, I_RANGE0_EN, \thread	 /* Enable Range Register */
+	or.4	D_RANGE0_EN, D_RANGE0_EN, \thread
+	or.4	D_RANGE1_EN, D_RANGE1_EN, \thread
+#endif
+.endm
+
+/*
+ * enable_kernel_ranges_for_current
+ *	Enable the kernel ranges (disabling protection) for this thread
+ */
+.macro	enable_kernel_ranges_for_current scratch_reg
+#ifdef CONFIG_PROTECT_KERNEL
+	thread_get_self_mask \scratch_reg
+	enable_kernel_ranges \scratch_reg
+#endif
+.endm
+
+/*
+ * disable_kernel_ranges
+ *	Disables the kernel ranges (enabling protection) for thread
+ *	where thread == (1 << thread number)
+ */
+.macro	disable_kernel_ranges thread
+#ifdef CONFIG_PROTECT_KERNEL
+	not.4	\thread, \thread
+	and.4	I_RANGE0_EN, I_RANGE0_EN, \thread	 /* Disable Range Register */
+	and.4	D_RANGE0_EN, D_RANGE0_EN, \thread
+	and.4	D_RANGE1_EN, D_RANGE1_EN, \thread
+#endif
+.endm
+
+/*
+ * disable_kernel_ranges_for_current
+ *	Disable kernel ranges (enabling protection) for this thread
+ */
+.macro	disable_kernel_ranges_for_current scratch_reg
+#ifdef CONFIG_PROTECT_KERNEL
+	thread_get_self_mask \scratch_reg
+	disable_kernel_ranges \scratch_reg
+#endif
+.endm
+#endif
+
+#endif  /* _ASM_UBICOM32_RANGE_PROTECT_ASM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/range-protect.h linux-2.6.28.10/arch/ubicom32/include/asm/range-protect.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/range-protect.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/range-protect.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,62 @@
+/*
+ * arch/ubicom32/include/asm/range-protect.h
+ *   Assembly macros declared in C for enabling memory protection.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_RANGE_PROTECT_H
+#define _ASM_UBICOM32_RANGE_PROTECT_H
+
+#if !defined(__ASSEMBLY__)
+#include <asm/thread.h>
+/*
+ * The following macros should be the identical to the ones in
+ * range-protect-asm.h
+ *
+ * You should only use the enable/disable ranges when you have the atomic lock,
+ * if you do not there will be problems.
+ */
+
+/*
+ * enable_kernel_ranges
+ *	Enable the kernel ranges (disabling protection) for thread,
+ *	where thread == (1 << thread number)
+ */
+asm (
+	".macro	enable_kernel_ranges thread			\n\t"
+#ifdef CONFIG_PROTECT_KERNEL
+	"	or.4	I_RANGE0_EN, I_RANGE0_EN, \\thread	\n\t" /* Enable Range Register */
+	"	or.4	D_RANGE0_EN, D_RANGE0_EN, \\thread	\n\t"
+	"	or.4	D_RANGE1_EN, D_RANGE1_EN, \\thread	\n\t"
+#endif
+	".endm							\n\t"
+);
+
+#else /* __ASSEMBLY__ */
+
+#include <asm/range-protect-asm.h>
+
+#endif
+#endif  /* _ASM_UBICOM32_RANGE_PROTECT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/resource.h linux-2.6.28.10/arch/ubicom32/include/asm/resource.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/resource.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/resource.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/resource.h
+ *   Generic definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_RESOURCE_H
+#define _ASM_UBICOM32_RESOURCE_H
+
+#include <asm-generic/resource.h>
+
+#endif /* _ASM_UBICOM32_RESOURCE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ring_tio.h linux-2.6.28.10/arch/ubicom32/include/asm/ring_tio.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ring_tio.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ring_tio.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,42 @@
+/*
+ * arch/ubicom32/include/asm/ring_tio.h
+ *   Ubicom32 architecture Ring TIO definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _ASM_UBICOM32_RING_TIO_H
+#define _ASM_UBICOM32_RING_TIO_H
+
+#include <asm/devtree.h>
+
+#define RING_TIO_NODE_VERSION	2
+
+/*
+ * Devtree node for ring
+ */
+struct ring_tio_node {
+	struct devtree_node	dn;
+
+	u32_t			version;
+	void			*regs;
+};
+
+extern void ring_tio_init(const char *node_name);
+
+#endif /* _ASM_UBICOM32_RING_TIO_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/scatterlist.h linux-2.6.28.10/arch/ubicom32/include/asm/scatterlist.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/scatterlist.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/scatterlist.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,49 @@
+/*
+ * arch/ubicom32/include/asm/scatterlist.h
+ *   Definitions of struct scatterlist for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SCATTERLIST_H
+#define _ASM_UBICOM32_SCATTERLIST_H
+
+#include <linux/mm.h>
+#include <asm/types.h>
+
+struct scatterlist {
+#ifdef CONFIG_DEBUG_SG
+	unsigned long	sg_magic;
+#endif
+	unsigned long	page_link;
+	unsigned int	offset;
+	dma_addr_t	dma_address;
+	unsigned int	length;
+};
+
+#define sg_dma_address(sg)      ((sg)->dma_address)
+#define sg_dma_len(sg)          ((sg)->length)
+
+#define ISA_DMA_THRESHOLD	(0xffffffff)
+
+#endif /* _ASM_UBICOM32_SCATTERLIST_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/sections.h linux-2.6.28.10/arch/ubicom32/include/asm/sections.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/sections.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/sections.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/sections.h
+ *   Generic sections.h definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SECTIONS_H
+#define _ASM_UBICOM32_SECTIONS_H
+
+#include <asm-generic/sections.h>
+
+#endif /* _ASM_UBICOM32_SECTIONS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/segment.h linux-2.6.28.10/arch/ubicom32/include/asm/segment.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/segment.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/segment.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,78 @@
+/*
+ * arch/ubicom32/include/asm/segment.h
+ *   Memory segment definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SEGMENT_H
+#define _ASM_UBICOM32_SEGMENT_H
+
+/* define constants */
+/* Address spaces (FC0-FC2) */
+#define USER_DATA     (1)
+#ifndef __USER_DS
+#define __USER_DS     (USER_DATA)
+#endif
+#define USER_PROGRAM  (2)
+#define SUPER_DATA    (5)
+#ifndef __KERNEL_DS
+#define __KERNEL_DS   (SUPER_DATA)
+#endif
+#define SUPER_PROGRAM (6)
+#define CPU_SPACE     (7)
+
+#ifndef __ASSEMBLY__
+
+typedef struct {
+	unsigned long seg;
+} mm_segment_t;
+
+#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
+#define USER_DS		MAKE_MM_SEG(__USER_DS)
+#define KERNEL_DS	MAKE_MM_SEG(__KERNEL_DS)
+
+/*
+ * Get/set the SFC/DFC registers for MOVES instructions
+ */
+
+static inline mm_segment_t get_fs(void)
+{
+    return USER_DS;
+}
+
+static inline mm_segment_t get_ds(void)
+{
+    /* return the supervisor data space code */
+    return KERNEL_DS;
+}
+
+static inline void set_fs(mm_segment_t val)
+{
+}
+
+#define segment_eq(a,b)	((a).seg == (b).seg)
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_UBICOM32_SEGMENT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/semaphore.h linux-2.6.28.10/arch/ubicom32/include/asm/semaphore.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/semaphore.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/semaphore.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,140 @@
+/*
+ * arch/ubicom32/include/asm/semaphore.h
+ *   Interrupt-safe semaphores for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * (C) Copyright 1996 Linus Torvalds
+ * m68k version by Andreas Schwab
+ * Copyright (C) 2004   Microtronix Datacom Ltd
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SEMAPHORE_H
+#define _ASM_UBICOM32_SEMAPHORE_H
+
+#define RW_LOCK_BIAS		 0x01000000
+
+#ifndef __ASSEMBLY__
+
+#include <linux/linkage.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/rwsem.h>
+
+#include <asm/system.h>
+#include <asm/atomic.h>
+
+struct semaphore {
+	atomic_t count;
+	atomic_t waking;
+	wait_queue_head_t wait;
+};
+
+#define __SEMAPHORE_INITIALIZER(name, n)				\
+{									\
+	.count		= ATOMIC_INIT(n),				\
+	.waking		= ATOMIC_INIT(0),				\
+	.wait		= __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)	\
+}
+
+#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
+
+#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+
+static inline void sema_init (struct semaphore *sem, int val)
+{
+	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER(*sem, val);
+}
+
+static inline void init_MUTEX (struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static inline void init_MUTEX_LOCKED (struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+asmlinkage void __down_failed(void /* special register calling convention */);
+asmlinkage int  __down_failed_interruptible(void  /* params in registers */);
+asmlinkage int  __down_failed_trylock(void  /* params in registers */);
+asmlinkage void __up_wakeup(void /* special register calling convention */);
+
+asmlinkage void __down(struct semaphore * sem);
+asmlinkage int  __down_interruptible(struct semaphore * sem);
+asmlinkage int  __down_trylock(struct semaphore * sem);
+asmlinkage void __up(struct semaphore * sem);
+
+extern spinlock_t semaphore_wake_lock;
+
+/*
+ * This is ugly, but we want the default case to fall through.
+ * "down_failed" is a special asm handler that calls the C
+ * routine that actually waits.
+ */
+static inline void down(struct semaphore * sem)
+{
+	might_sleep();
+
+	if (atomic_dec_return(&sem->count) < 0)
+		__down(sem);
+}
+
+static inline int down_interruptible(struct semaphore * sem)
+{
+	int ret = 0;
+
+
+	might_sleep();
+
+	if(atomic_dec_return(&sem->count) < 0)
+		ret = __down_interruptible(sem);
+	return ret;
+}
+
+static inline int down_trylock(struct semaphore * sem)
+{
+	int ret = 0;
+
+	if (atomic_dec_return (&sem->count) < 0)
+		ret = __down_trylock(sem);
+	return ret;
+}
+
+/*
+ * Note! This is subtle. We jump to wake people up only if
+ * the semaphore was negative (== somebody was waiting on it).
+ * The default case (no contention) will result in NO
+ * jumps for both down() and up().
+ */
+static inline void up(struct semaphore * sem)
+{
+	if (atomic_inc_return(&sem->count) <= 0)
+		__up(sem);
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_UBICOM32_SEMAPHORE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/semaphore-helper.h linux-2.6.28.10/arch/ubicom32/include/asm/semaphore-helper.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/semaphore-helper.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/semaphore-helper.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,109 @@
+/*
+ * arch/ubicom32/include/asm/semaphore-helper.h
+ *   Semaphore related definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SEMAPHORE_HELPER_H
+#define _ASM_UBICOM32_SEMAPHORE_HELPER_H
+
+/*
+ * SMP- and interrupt-safe semaphores helper functions.
+ *
+ * (C) Copyright 1996 Linus Torvalds
+ *
+ * m68k version by Andreas Schwab
+ */
+
+
+/*
+ * These two _must_ execute atomically wrt each other.
+ */
+static inline void wake_one_more(struct semaphore * sem)
+{
+	atomic_inc(&sem->waking);
+}
+
+static inline int waking_non_zero(struct semaphore *sem)
+{
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	ret = 0;
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 1;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+/*
+ * waking_non_zero_interruptible:
+ *	1	got the lock
+ *	0	go to sleep
+ *	-EINTR	interrupted
+ */
+static inline int waking_non_zero_interruptible(struct semaphore *sem,
+						struct task_struct *tsk)
+{
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	ret = 0;
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 1;
+	} else if (signal_pending(tsk)) {
+		atomic_inc(&sem->count);
+		ret = -EINTR;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+/*
+ * waking_non_zero_trylock:
+ *	1	failed to lock
+ *	0	got the lock
+ */
+static inline int waking_non_zero_trylock(struct semaphore *sem)
+{
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	ret = 1;
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 0;
+	} else
+		atomic_inc(&sem->count);
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+#endif /* _ASM_UBICOM32_SEMAPHORE_HELPER_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/sembuf.h linux-2.6.28.10/arch/ubicom32/include/asm/sembuf.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/sembuf.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/sembuf.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,52 @@
+/*
+ * arch/ubicom32/include/asm/sembuf.h
+ *   The semid64_ds structure for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SEMBUF_H
+#define _ASM_UBICOM32_SEMBUF_H
+
+/*
+ * The semid64_ds structure for ubicom32 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;		/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;		/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_UBICOM32_SEMBUF_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/setup.h linux-2.6.28.10/arch/ubicom32/include/asm/setup.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/setup.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/setup.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,35 @@
+/*
+ * arch/ubicom32/include/asm/setup.h
+ *   Kernel command line length definition.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2004, Microtronix Datacom Ltd., All rights reserved.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_SETUP_H
+#define _ASM_UBICOM32_SETUP_H
+
+#define COMMAND_LINE_SIZE 512
+
+#endif /* _ASM_UBICOM32_SETUP_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/shmbuf.h linux-2.6.28.10/arch/ubicom32/include/asm/shmbuf.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/shmbuf.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/shmbuf.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,69 @@
+/*
+ * arch/ubicom32/include/asm/shmbuf.h
+ *   The shmid64_ds structure for the Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SHMBUF_H
+#define _ASM_UBICOM32_SHMBUF_H
+
+/*
+ * The shmid64_ds structure for m68k architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	unsigned long		__unused1;
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	unsigned long		__unused2;
+	__kernel_time_t		shm_ctime;	/* last change time */
+	unsigned long		__unused3;
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_UBICOM32_SHMBUF_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/shmparam.h linux-2.6.28.10/arch/ubicom32/include/asm/shmparam.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/shmparam.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/shmparam.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,35 @@
+/*
+ * arch/ubicom32/include/asm/shmparam.h
+ *   Shared memory definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2004   Microtronix Datacom Ltd
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ *   Alpha, ix86, M68K, Sparc, ...et al
+ */
+#ifndef _ASM_UBICOM32_SHMPARAM_H
+#define _ASM_UBICOM32_SHMPARAM_H
+
+#define	SHMLBA		PAGE_SIZE	/* attach addr a multiple of this */
+
+#endif /* _ASM_UBICOM32_SHMPARAM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/sigcontext.h linux-2.6.28.10/arch/ubicom32/include/asm/sigcontext.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/sigcontext.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/sigcontext.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,37 @@
+/*
+ * arch/ubicom32/include/asm/sigcontext.h
+ *   Definition of sigcontext struct for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SIGCONTEXT_H
+#define _ASM_UBICOM32_SIGCONTEXT_H
+
+#include <asm/ptrace.h>
+
+struct sigcontext {
+	struct pt_regs sc_regs;
+};
+
+#endif /* _ASM_UBICOM32_SIGCONTEXT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/siginfo.h linux-2.6.28.10/arch/ubicom32/include/asm/siginfo.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/siginfo.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/siginfo.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/siginfo.h
+ *   Generic siginfo.h definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SIGINFO_H
+#define _ASM_UBICOM32_SIGINFO_H
+
+#include <asm-generic/siginfo.h>
+
+#endif /* _ASM_UBICOM32_SIGINFO_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/signal.h linux-2.6.28.10/arch/ubicom32/include/asm/signal.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/signal.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/signal.h	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,180 @@
+/*
+ * arch/ubicom32/include/asm/signal.h
+ *   Signal related definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SIGNAL_H
+#define _ASM_UBICOM32_SIGNAL_H
+
+#include <linux/types.h>
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+#ifdef __KERNEL__
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
+#define _NSIG		64
+#define _NSIG_BPW	32
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+typedef unsigned long old_sigset_t;		/* at least 32 bits */
+
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+#endif /* __KERNEL__ */
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001
+#define SA_NOCLDWAIT	0x00000002
+#define SA_SIGINFO	0x00000004
+#define SA_ONSTACK	0x08000000
+#define SA_RESTART	0x10000000
+#define SA_NODEFER	0x40000000
+#define SA_RESETHAND	0x80000000
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+/* 
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#include <asm-generic/signal.h>
+
+#ifdef __KERNEL__
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+};
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+struct sigaction {
+	union {
+	  __sighandler_t _sa_handler;
+	  void (*_sa_sigaction)(int, struct siginfo *, void *);
+	} _u;
+	sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+};
+
+#define sa_handler	_u._sa_handler
+#define sa_sigaction	_u._sa_sigaction
+
+#endif /* __KERNEL__ */
+
+typedef struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#ifdef __KERNEL__
+
+#include <asm/sigcontext.h>
+#undef __HAVE_ARCH_SIG_BITOPS
+
+#define ptrace_signal_deliver(regs, cookie) do { } while (0)
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_UBICOM32_SIGNAL_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/smp.h linux-2.6.28.10/arch/ubicom32/include/asm/smp.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/smp.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/smp.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,83 @@
+/*
+ * arch/ubicom32/include/asm/smp.h
+ *   SMP definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SMP_H
+#define _ASM_UBICOM32_SMP_H
+
+#ifndef ASSEMBLY
+#include <linux/bitops.h>
+#include <linux/threads.h>
+#include <linux/cpumask.h>
+#include <asm/ip5000.h>
+
+typedef unsigned long address_t;
+extern cpumask_t cpu_online_map;
+extern unsigned int smp_ipi_irq;
+
+/*
+ * This magic constant controls our willingness to transfer
+ * a process across CPUs.
+ *
+ * Such a transfer incurs cache and tlb
+ * misses. The current value is inherited from i386. Still needs
+ * to be tuned for parisc.
+ */
+#define PROC_CHANGE_PENALTY	15		/* Schedule penalty */
+#define NO_PROC_ID		0xFF		/* No processor magic marker */
+#define ANY_PROC_ID		0xFF		/* Any processor magic marker */
+
+#ifdef CONFIG_SMP
+#define raw_smp_processor_id()	(current_thread_info()->cpu)
+#endif /* CONFIG_SMP */
+
+static inline int __cpu_disable (void)
+{
+  return 0;
+}
+
+static inline void __cpu_die (unsigned int cpu)
+{
+	while(1) {
+	};
+}
+
+extern int __cpu_up(unsigned int cpu);
+extern void smp_send_timer_all(void);
+extern void smp_timer_broadcast(cpumask_t mask);
+extern void smp_set_affinity(unsigned int irq, cpumask_t dest);
+extern void arch_send_call_function_single_ipi(int cpu);
+extern void arch_send_call_function_ipi(cpumask_t mask);
+
+/*
+ * TODO: Once these are fully tested, we should turn them into
+ * inline macros for performance.
+ */
+extern unsigned long smp_get_affinity(unsigned int irq, int *all);
+extern void smp_reset_ipi(unsigned long mask);
+
+#endif /* !ASSEMBLY */
+#endif /*  _ASM_UBICOM32_SMP_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/socket.h linux-2.6.28.10/arch/ubicom32/include/asm/socket.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/socket.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/socket.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,84 @@
+/*
+ * arch/ubicom32/include/asm/socket.h
+ *   Socket options definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SOCKET_H
+#define _ASM_UBICOM32_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockopt(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME             28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+
+#define SO_PEERSEC              31
+#define SO_PASSSEC		34
+#define SO_TIMESTAMPNS		35
+#define SCM_TIMESTAMPNS		SO_TIMESTAMPNS
+
+#define SO_MARK			36
+
+#endif /* _ASM_UBICOM32_SOCKET_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/sockios.h linux-2.6.28.10/arch/ubicom32/include/asm/sockios.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/sockios.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/sockios.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,40 @@
+/*
+ * arch/ubicom32/include/asm/sockios.h
+ *   Socket-level ioctl definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SOCKIOS_H
+#define _ASM_UBICOM32_SOCKIOS_H
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906		/* Get stamp (timeval) */
+#define SIOCGSTAMPNS	0x8907		/* Get stamp (timespec) */
+
+#endif /* _ASM_UBICOM32_SOCKIOS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/spinlock.h linux-2.6.28.10/arch/ubicom32/include/asm/spinlock.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/spinlock.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/spinlock.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,293 @@
+/*
+ * arch/ubicom32/include/asm/spinlock.h
+ *   Spinlock related definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SPINLOCK_H
+#define _ASM_UBICOM32_SPINLOCK_H
+
+#include <asm/system.h>
+#include <asm/processor.h>
+#include <asm/spinlock_types.h>
+
+/*
+ * __raw_spin_lock()
+ *	Lock the lock.
+ */
+static inline void __raw_spin_lock(raw_spinlock_t *x)
+{
+	asm volatile (
+	"1:	bset	%0, %0, #0	\n\t"
+	"	jmpne.f	1b		\n\t"
+		: "+U4" (x->lock)
+		:
+		: "memory", "cc"
+	);
+}
+
+/*
+ * __raw_spin_unlock()
+ *	Unlock the lock.
+ */
+static inline void __raw_spin_unlock(raw_spinlock_t *x)
+{
+	asm volatile (
+	"	bclr	%0, %0, #0	\n\t"
+		: "+U4" (x->lock)
+		:
+		: "memory", "cc"
+	);
+}
+
+/*
+ * __raw_spin_is_locked()
+ *	Test if the lock is locked.
+ */
+static inline int __raw_spin_is_locked(raw_spinlock_t *x)
+{
+	return x->lock;
+}
+
+/*
+ * __raw_spin_unlock_wait()
+ *	Wait for the lock to be unlocked.
+ *
+ * Note: the caller has not guarantee that the lock will not
+ * be acquired before they get to it.
+ */
+static inline void __raw_spin_unlock_wait(raw_spinlock_t *x)
+{
+	do { 
+		cpu_relax(); 
+	} while (__raw_spin_is_locked(x));
+}
+
+/*
+ * __raw_spin_trylock()
+ *	Try the lock, return 0 on failure, 1 on success.
+ */
+static inline int __raw_spin_trylock(raw_spinlock_t *x)
+{
+	int ret = 0;
+
+	asm volatile (
+	"	bset	%1, %1, #0	\n\t"
+	"	jmpne.f	1f		\n\t"
+	"	move.4	%0, #1		\n\t"
+	"1:				\n\t"
+		: "+r" (ret), "+U4" (x->lock)
+		:
+		: "memory", "cc"
+	);
+
+	return ret;
+}
+
+/*
+ * __raw_spin_lock_flags()
+ *	Spin waiting for the lock (enabling IRQ(s))
+ */
+static inline void __raw_spin_lock_flags(raw_spinlock_t *x, unsigned long flags)
+{
+	mb();
+	while (!__raw_spin_trylock(x)) {
+		/*
+		 * If the flags from the IRQ are set, interrupts are disabled and we 
+		 * need to re-enable them.
+		 */
+		if (!flags) {
+			cpu_relax();
+		} else {
+			raw_local_irq_enable();
+			cpu_relax();
+			raw_local_irq_disable();
+		}
+	}
+	mb();
+}
+
+/*
+ * Read-write spinlocks, allowing multiple readers but only one writer.
+ * Linux rwlocks are unfair to writers; they can be starved for an indefinite
+ * time by readers.  With care, they can also be taken in interrupt context.
+ *
+ * In Ubicom32 architecture implementation, we have a spinlock and a counter.
+ * Readers use the lock to serialise their access to the counter (which
+ * records how many readers currently hold the lock).
+ * Writers hold the spinlock, preventing any readers or other writers from
+ * grabbing the rwlock.
+ */
+
+/*
+ * __raw_read_lock()
+ *	Increment the counter in the rwlock.
+ *
+ * Note that we have to ensure interrupts are disabled in case we're
+ * interrupted by some other code that wants to grab the same read lock 
+ */
+static inline void __raw_read_lock(raw_rwlock_t *rw)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	__raw_spin_lock_flags(&rw->lock, flags);
+	rw->counter++;
+	__raw_spin_unlock(&rw->lock);
+	raw_local_irq_restore(flags);
+}
+
+/*
+ * __raw_read_unlock()
+ *	Decrement the counter.
+ *
+ * Note that we have to ensure interrupts are disabled in case we're
+ * interrupted by some other code that wants to grab the same read lock 
+ */
+static inline void __raw_read_unlock(raw_rwlock_t *rw)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	__raw_spin_lock_flags(&rw->lock, flags);
+	rw->counter--;
+	__raw_spin_unlock(&rw->lock);
+	raw_local_irq_restore(flags);
+}
+
+/* 
+ * __raw_read_trylock()
+ *	Increment the counter if we can.
+ *
+ * Note that we have to ensure interrupts are disabled in case we're
+ * interrupted by some other code that wants to grab the same read lock 
+ */
+static inline int __raw_read_trylock(raw_rwlock_t *rw)
+{
+	unsigned long flags;
+ retry:
+	raw_local_irq_save(flags);
+	if (__raw_spin_trylock(&rw->lock)) {
+		rw->counter++;
+		__raw_spin_unlock(&rw->lock);
+		raw_local_irq_restore(flags);
+		return 1;
+	}
+
+	raw_local_irq_restore(flags);
+
+	/* 
+	 * If write-locked, we fail to acquire the lock 
+	 */
+	if (rw->counter < 0) {
+		return 0;
+	}
+
+	/* 
+	 * Wait until we have a realistic chance at the lock 
+	 */
+	while (__raw_spin_is_locked(&rw->lock) && rw->counter >= 0) {
+		cpu_relax();
+	}
+
+	goto retry;
+}
+
+/*
+ * __raw_write_lock()
+ *	
+ * Note that we have to ensure interrupts are disabled in case we're
+ * interrupted by some other code that wants to read_trylock() this lock 
+ */
+static inline void __raw_write_lock(raw_rwlock_t *rw)
+{
+	unsigned long flags;
+retry:
+	raw_local_irq_save(flags);
+	__raw_spin_lock_flags(&rw->lock, flags);
+
+	if (rw->counter != 0) {
+		__raw_spin_unlock(&rw->lock);
+		raw_local_irq_restore(flags);
+
+		while (rw->counter != 0)
+			cpu_relax();
+
+		goto retry;
+	}
+
+	rw->counter = -1; /* mark as write-locked */
+	mb();
+	raw_local_irq_restore(flags);
+}
+
+static inline void __raw_write_unlock(raw_rwlock_t *rw)
+{
+	rw->counter = 0;
+	__raw_spin_unlock(&rw->lock);
+}
+
+/* Note that we have to ensure interrupts are disabled in case we're
+ * interrupted by some other code that wants to read_trylock() this lock */
+static inline int __raw_write_trylock(raw_rwlock_t *rw)
+{
+	unsigned long flags;
+	int result = 0;
+
+	raw_local_irq_save(flags);
+	if (__raw_spin_trylock(&rw->lock)) {
+		if (rw->counter == 0) {
+			rw->counter = -1;
+			result = 1;
+		} else {
+			/* Read-locked.  Oh well. */
+			__raw_spin_unlock(&rw->lock);
+		}
+	}
+	raw_local_irq_restore(flags);
+
+	return result;
+}
+
+/*
+ * read_can_lock - would read_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+static inline int __raw_read_can_lock(raw_rwlock_t *rw)
+{
+	return rw->counter >= 0;
+}
+
+/*
+ * write_can_lock - would write_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+static inline int __raw_write_can_lock(raw_rwlock_t *rw)
+{
+	return !rw->counter;
+}
+
+#define _raw_spin_relax(lock)	cpu_relax()
+#define _raw_read_relax(lock)	cpu_relax()
+#define _raw_write_relax(lock)	cpu_relax()
+
+#endif /* _ASM_UBICOM32_SPINLOCK_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/spinlock_types.h linux-2.6.28.10/arch/ubicom32/include/asm/spinlock_types.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/spinlock_types.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/spinlock_types.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,43 @@
+/*
+ * arch/ubicom32/include/asm/spinlock_types.h
+ *   Spinlock related structure definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SPINLOCK_TYPES_H
+#define _ASM_UBICOM32_SPINLOCK_TYPES_H
+
+typedef struct {
+	volatile unsigned int lock;
+} raw_spinlock_t;
+
+typedef struct {
+	raw_spinlock_t lock;
+	volatile int counter;
+} raw_rwlock_t;
+
+#define __RAW_SPIN_LOCK_UNLOCKED	{ 0 }
+#define __RAW_RW_LOCK_UNLOCKED		{ __RAW_SPIN_LOCK_UNLOCKED, 0 }
+
+#endif /* _ASM_UBICOM32_SPINLOCK_TYPES_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/stacktrace.h linux-2.6.28.10/arch/ubicom32/include/asm/stacktrace.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/stacktrace.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/stacktrace.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,72 @@
+/*
+ * arch/ubicom32/include/asm/stacktrace.h
+ *   Stacktrace functions for the Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_STACKTRACE_H
+#define _ASM_UBICOM32_STACKTRACE_H
+
+#define between(a, b, c)	(( \
+			((unsigned long) a) >= ((unsigned long) b)) && \
+			(((unsigned long)a) <= ((unsigned long)c)))
+
+/*
+ * These symbols are filled in by the linker.
+ */
+extern unsigned long _stext;
+extern unsigned long _etext;
+
+/* OCM text goes from __ocm_text_run_begin to __data_begin */
+extern unsigned long __ocm_text_run_begin;
+extern unsigned long __data_begin;
+
+/* Account for OCM case - see stacktrace.c maybe combine(also trap.c) */
+/*
+ * ubicom32_is_kernel()
+ *
+ * 	Check to see if the given address belongs to the kernel.
+ * NOMMU does not permit any other means.
+ */
+static inline int ubicom32_is_kernel(unsigned long addr)
+{
+	int is_kernel = between(addr, &_stext, &_etext) || \
+			between(addr, &__ocm_text_run_begin, &__data_begin);
+
+#ifdef CONFIG_MODULES
+	if (!is_kernel)
+		is_kernel = is_module_address(addr);
+#endif
+	return is_kernel;
+}
+
+extern unsigned long stacktrace_iterate(
+				unsigned long **trace, 
+				unsigned long stext, unsigned long etext,
+				unsigned long ocm_stext, unsigned long ocm_etext, 
+				unsigned long sstack, unsigned long estack);
+#ifdef CONFIG_STACKTRACE
+void stacktrace_save_entries(struct task_struct *tsk, struct stack_trace *trace, unsigned long sp);
+#endif
+#endif /* _ASM_UBICOM32_STACKTRACE_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/statfs.h linux-2.6.28.10/arch/ubicom32/include/asm/statfs.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/statfs.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/statfs.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/statfs.h
+ *   Generic statfs.h definitions
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_STATFS_H
+#define _ASM_UBICOM32_STATFS_H
+
+#include <asm-generic/statfs.h>
+
+#endif /* _ASM_UBICOM32_STATFS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/stat.h linux-2.6.28.10/arch/ubicom32/include/asm/stat.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/stat.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/stat.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,104 @@
+/*
+ * arch/ubicom32/include/asm/stat.h
+ *   File status definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_STAT_H
+#define _ASM_UBICOM32_STAT_H
+
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned long  st_size;
+	unsigned long  st_atime;
+	unsigned long  st_mtime;
+	unsigned long  st_ctime;
+};
+
+struct stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long  st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+	unsigned long  __unused1;
+	unsigned long  st_mtime;
+	unsigned long  __unused2;
+	unsigned long  st_ctime;
+	unsigned long  __unused3;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned long long	st_dev;
+	unsigned char	__pad1[2];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned long	__st_ino;
+
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long	st_rdev;
+	unsigned char	__pad3[2];
+
+	long long	st_size;
+	unsigned long	st_blksize;
+
+	unsigned long long	st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long long	st_ino;
+};
+
+#endif /* _ASM_UBICOM32_STAT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/string.h linux-2.6.28.10/arch/ubicom32/include/asm/string.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/string.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/string.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,37 @@
+/*
+ * arch/ubicom32/include/asm/string.h
+ *   String operation definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_STRING_H
+#define _ASM_UBICOM32_STRING_H
+
+#define __HAVE_ARCH_MEMSET
+extern void *memset(void *b, int c, size_t len);
+
+#define __HAVE_ARCH_MEMCPY
+extern void *memcpy(void *to, const void *from, size_t len);
+
+#endif /* _ASM_UBICOM32_STRING_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/system.h linux-2.6.28.10/arch/ubicom32/include/asm/system.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/system.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/system.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,101 @@
+/*
+ * arch/ubicom32/include/asm/system.h
+ *   Low level switching definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_SYSTEM_H
+#define _ASM_UBICOM32_SYSTEM_H
+
+#include <linux/irqflags.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/entry.h>
+#include <asm/ldsr.h>
+#include <asm/irq.h>
+#include <asm/percpu.h>
+#include <asm/ubicom32-common.h>
+#include <asm/processor.h>
+
+/*
+ * switch_to(n) should switch tasks to task ptr, first checking that
+ * ptr isn't the current task, in which case it does nothing.
+ */
+asmlinkage void resume(void);
+extern void *__switch_to(struct task_struct *prev,
+		struct thread_struct *prev_switch,
+		struct thread_struct *next_switch);
+
+/*
+ * We will need a per linux thread sw_ksp for the switch_to macro to
+ * track the kernel stack pointer for the current thread on that linux thread.
+ */
+#define switch_to(prev,next,last)					\
+({									\
+	void *_last;							\
+	_last = (void *)						\
+		__switch_to(prev, &prev->thread, &next->thread);	\
+	(last) = _last;							\
+})
+
+/*
+ * Force strict CPU ordering.
+ * Not really required on ubicom32...
+ */
+#define nop()  asm volatile ("nop"::)
+#define mb()   asm volatile (""   : : :"memory")
+#define rmb()  asm volatile (""   : : :"memory")
+#define wmb()  asm volatile (""   : : :"memory")
+#define set_mb(var, value)	({ (var) = (value); wmb(); })
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#define smp_read_barrier_depends()	read_barrier_depends()
+#else
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#define smp_read_barrier_depends()	do { } while(0)
+#endif
+
+#define read_barrier_depends()  ((void)0)
+
+/*
+ * The following defines change how the scheduler calls the switch_to()
+ * macro.
+ *
+ * 1) The first causes the runqueue to be unlocked on entry to
+ * switch_to().  Since our ctx code does not play with the runqueue
+ * we do not need it unlocked.
+ *
+ * 2) The later turns interrupts on during a ctxsw to reduce the latency of
+ * interrupts during ctx.  At this point in the port, we believe that this
+ * latency is not a problem since we have very little code to perform a ctxsw.
+ */
+// #define __ARCH_WANT_UNLOCKED_CTXSW
+// #define __ARCH_WANT_INTERRUPTS_ON_CTXSW
+
+#endif /* _ASM_UBICOM32_SYSTEM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/termbits.h linux-2.6.28.10/arch/ubicom32/include/asm/termbits.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/termbits.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/termbits.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,227 @@
+/*
+ * arch/ubicom32/include/asm/termbits.h
+ *   Terminal/serial port definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_TERMBITS_H
+#define _ASM_UBICOM32_TERMBITS_H
+
+#include <linux/posix_types.h>
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+};
+
+struct termios2 {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+struct ktermios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8	0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    BOTHER 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000		/* input baud rate */
+#define CMSPAR	  010000000000		/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000		/* flow control */
+
+#define IBSHIFT	16			/* Shift from CBAUD to CIBAUD */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif /* _ASM_UBICOM32_TERMBITS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/termios.h linux-2.6.28.10/arch/ubicom32/include/asm/termios.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/termios.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/termios.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,119 @@
+/*
+ * arch/ubicom32/include/asm/termios.h
+ *   Ubicom32 termio definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_TERMIOS_H
+#define _ASM_UBICOM32_TERMIOS_H
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+#ifdef __KERNEL__
+/*	intr=^C		quit=^|		erase=del	kill=^U
+	eof=^D		vtime=\0	vmin=\1		sxtc=\0
+	start=^Q	stop=^S		susp=^Z		eol=\0
+	reprint=^R	discard=^U	werase=^W	lnext=^V
+	eol2=\0
+*/
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
+#endif
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+#ifdef __KERNEL__
+
+/*
+ * Translate a "termio" structure into a "termios". Ugh.
+ */
+#define user_termio_to_kernel_termios(termios, termio) \
+({ \
+	unsigned short tmp; \
+	get_user(tmp, &(termio)->c_iflag); \
+	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
+	get_user(tmp, &(termio)->c_oflag); \
+	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
+	get_user(tmp, &(termio)->c_cflag); \
+	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
+	get_user(tmp, &(termio)->c_lflag); \
+	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
+	get_user((termios)->c_line, &(termio)->c_line); \
+	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
+})
+
+/*
+ * Translate a "termios" structure into a "termio". Ugh.
+ */
+#define kernel_termios_to_user_termio(termio, termios) \
+({ \
+	put_user((termios)->c_iflag, &(termio)->c_iflag); \
+	put_user((termios)->c_oflag, &(termio)->c_oflag); \
+	put_user((termios)->c_cflag, &(termio)->c_cflag); \
+	put_user((termios)->c_lflag, &(termio)->c_lflag); \
+	put_user((termios)->c_line,  &(termio)->c_line); \
+	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
+})
+
+#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios2))
+#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios2))
+#define user_termios_to_kernel_termios_1(k, u) copy_from_user(k, u, sizeof(struct termios))
+#define kernel_termios_to_user_termios_1(u, k) copy_to_user(u, k, sizeof(struct termios))
+
+#endif	/* __KERNEL__ */
+
+#endif /* _ASM_UBICOM32_TERMIOS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/thread-asm.h linux-2.6.28.10/arch/ubicom32/include/asm/thread-asm.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/thread-asm.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/thread-asm.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,49 @@
+/*
+ * arch/ubicom32/include/asm/thread-asm.h
+ *   Ubicom32 architecture specific thread definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_THREAD_ASM_H
+#define _ASM_UBICOM32_THREAD_ASM_H
+
+/*
+ * thread_get_self
+ *	Read and shift the current thread into reg
+ */
+.macro	thread_get_self reg
+	lsr.4	\reg, ROSR, #2
+	and.4	\reg, #31, \reg	 /* Mask to get thread number into register */
+.endm
+
+/*
+ * thread_get_self_mask
+ *	Read and shift the current thread mask into reg
+ */
+.macro	thread_get_self_mask reg
+	lsr.4	\reg, ROSR, #2
+	lsl.4	\reg, #1, \reg	 /* Thread bit */
+.endm
+
+#endif /* _ASM_UBICOM32_THREAD_ASM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/thread.h linux-2.6.28.10/arch/ubicom32/include/asm/thread.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/thread.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/thread.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,313 @@
+/*
+ * arch/ubicom32/include/asm/thread.h
+ *   Ubicom32 architecture specific thread definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_THREAD_H
+#define _ASM_UBICOM32_THREAD_H
+
+#if !defined(__ASSEMBLY__)
+
+#include <asm/ptrace.h>
+#include <asm/ubicom32-common.h>
+
+typedef int thread_t;
+typedef unsigned char thread_type_t;
+typedef void (*thread_exec_fn_t)(void *arg);
+
+#define THREAD_NULL 0x40
+#define THREAD_TYPE_HRT (1 << 0)
+#define THREAD_TYPE_SPECIAL 0
+#define THREAD_TYPE_NORMAL 0
+#define THREAD_TYPE_BACKGROUND (1 << 1)
+
+/*
+ * This is the upper bound on the maximum hardware threads that one will find
+ * on a Ubicom processor. It is used to size per hardware thread data structures.
+ */
+#define THREAD_ARCHITECTURAL_MAX 16
+
+/*
+ * TODO: Rename this at some point to be thread_
+ */
+extern unsigned int sw_ksp[THREAD_ARCHITECTURAL_MAX];
+
+
+/*
+ * thread_get_self()
+ */
+static inline thread_t thread_get_self(void)
+{
+	thread_t result;
+	asm (
+		"lsr.4	%0, ROSR, #2	\n\t"
+		: "=d" (result)
+		:
+		: "cc"
+	);
+	return result & 31;
+}
+
+/*
+ * thread_suspend()
+ */
+static inline void thread_suspend(void)
+{
+	asm volatile (
+		"suspend\n\t"
+		:
+		:
+	);
+}
+
+/*
+ * thread_resume()
+ */
+static inline void thread_resume(thread_t thread)
+{
+	asm volatile (
+		"move.4		MT_ACTIVE_SET, %0	\n\t"
+		"pipe_flush	0			\n\t"
+		"pipe_flush	0			\n\t"
+		:
+		: "d" (1 << thread)
+	);
+}
+
+
+
+/*
+ * thread_enable_mask()
+ *	Enable all threads in the mask.
+ *
+ * All writes to MT_EN must be protected by the MT_EN_LOCK bit
+ */
+static inline void thread_enable_mask(unsigned int mask)
+{
+	/*
+	 * must flush the pipeline twice.
+	 * first pipe_flush is to ensure write to MT_EN is completed
+	 * second one is to ensure any new instructions from
+	 * the targeted thread (the one being disabled), that
+	 * are issued while the write to MT_EN is being executed,
+	 * are completed.
+	 */
+	UBICOM32_LOCK(MT_EN_LOCK_BIT);
+	asm volatile (
+		"or.4		MT_EN, MT_EN, %0	\n\t"
+		"pipe_flush	0			\n\t"
+		"pipe_flush	0			\n\t"
+		:
+		: "d" (mask)
+		: "cc"
+	);
+	UBICOM32_UNLOCK(MT_EN_LOCK_BIT);
+}
+
+/*
+ * thread_enable()
+ */
+static inline void thread_enable(thread_t thread)
+{
+	thread_enable_mask(1 << thread);
+}
+
+/*
+ * thread_disable_mask()
+ *	Disable all threads in the mask.
+ *
+ * All writes to MT_EN must be protected by the MT_EN_LOCK bit
+ */
+static inline void thread_disable_mask(unsigned int mask)
+{
+	/*
+	 * must flush the pipeline twice.
+	 * first pipe_flush is to ensure write to MT_EN is completed
+	 * second one is to ensure any new instructions from
+	 * the targeted thread (the one being disabled), that
+	 * are issued while the write to MT_EN is being executed,
+	 * are completed.
+	 */
+	UBICOM32_LOCK(MT_EN_LOCK_BIT);
+	asm volatile (
+		"and.4		MT_EN, MT_EN, %0	\n\t"
+		"pipe_flush	0			\n\t"
+		"pipe_flush	0			\n\t"
+		:
+		: "d" (~mask)
+		: "cc"
+	);
+	UBICOM32_UNLOCK(MT_EN_LOCK_BIT);
+}
+
+/*
+ * thread_disable()
+ */
+static inline void thread_disable(thread_t thread)
+{
+	thread_disable_mask(1 << thread);
+}
+
+/*
+ * thread_disable_others()
+ *	Disable all other threads
+ */
+static inline void thread_disable_others(void)
+{
+	thread_t self = thread_get_self();
+	thread_disable_mask(~(1 << self));
+}
+
+/*
+ * thread_is_trapped()
+ *	Is the specified tid trapped?
+ */
+static inline int thread_is_trapped(thread_t tid)
+{
+	int thread_mask = (1 << tid);
+	int trap_thread;
+
+	asm (
+		"move.4		%0, MT_TRAP		\n\t"
+		: "=d" (trap_thread)
+		:
+	);
+	return (trap_thread & thread_mask);
+}
+
+/*
+ * thread_is_enabled()
+ *	Is the specified tid enabled?
+ */
+static inline int thread_is_enabled(thread_t tid)
+{
+	int thread_mask = (1 << tid);
+	int enabled_threads;
+
+	asm (
+		"move.4		%0, MT_EN		\n\t"
+		: "=d" (enabled_threads)
+		:
+	);
+	return (enabled_threads & thread_mask);
+}
+
+/*
+ * thread_get_instruction_count()
+ */
+static inline unsigned int thread_get_instruction_count(void)
+{
+	unsigned int result;
+	asm (
+		"move.4		%0, INST_CNT		\n\t"
+		: "=r" (result)
+	);
+	return result;
+}
+
+/*
+ * thread_get_pc()
+ *	pc could point to a speculative and cancelled instruction unless thread is disabled
+ */
+static inline void *thread_get_pc(thread_t thread)
+{
+	void *result;
+	asm (
+		"move.4		csr, %1		\n\t"
+		"setcsr_flush	0		\n\t"
+		"move.4		%0, pc		\n\t"
+		"move.4		csr, #0		\n\t"
+		"setcsr_flush	0		\n\t"
+		: "=r" (result)
+		: "r" ((thread << 9) | (1 << 8))
+	);
+	return result;
+}
+
+/*
+ * thread_get_trap_cause()
+ *	This should be called only when the thread is not running
+ */
+static inline unsigned int thread_get_trap_cause(thread_t thread)
+{
+	unsigned int result;
+	asm (
+		"move.4		csr, %1		\n\t"
+		"setcsr_flush	0		\n\t"
+		"move.4		%0, trap_cause	\n\t"
+		"move.4		csr, #0		\n\t"
+		"setcsr_flush	0		\n\t"
+		: "=r" (result)
+		: "r" ((thread << 9) | (1 << 8))
+	);
+	return result;
+}
+
+/*
+ * THREAD_STALL macro.
+ */
+#define THREAD_STALL \
+		asm volatile ( \
+			"move.4	mt_dbg_active_clr, #-1	\n\t" \
+			"pipe_flush 0			\n\t" \
+			: \
+			: \
+		)
+
+extern unsigned int thread_get_mainline(void);
+extern void thread_set_mainline(thread_t tid);
+extern thread_t thread_alloc(void);
+extern thread_t thread_start(thread_t thread, thread_exec_fn_t exec, void *arg, unsigned int *sp_high, thread_type_t type);
+
+/*
+ * asm macros
+ */
+asm (
+/*
+ * thread_get_self
+ *	Read and shift the current thread into reg
+ */
+".macro	thread_get_self reg		\n\t"
+"	lsr.4	\\reg, ROSR, #2		\n\t"
+"	and.4	\\reg, #31, \\reg	\n\t"/* Mask to get thread number into
+					      * register */
+".endm					\n\t"
+
+/*
+ * thread_get_self_mask
+ *	Read and shift the current thread mask into reg
+ */
+".macro	thread_get_self_mask reg	\n\t"
+"	lsr.4	\\reg, ROSR, #2		\n\t"
+"	lsl.4	\\reg, #1, \\reg	\n\t"	 /* Thread bit */
+".endm					\n\t"
+	);
+
+#else /* __ASSEMBLY__ */
+
+#include <asm/thread-asm.h>
+
+#endif /* __ASSEMBLY__ */
+#endif /* _ASM_UBICOM32_THREAD_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/thread_info.h linux-2.6.28.10/arch/ubicom32/include/asm/thread_info.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/thread_info.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/thread_info.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,134 @@
+/*
+ * arch/ubicom32/include/asm/thread_info.h
+ *   Ubicom32 architecture low-level thread information.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Adapted from the i386 and PPC versions by Greg Ungerer (gerg@snapgear.com)
+ * Copyright (C) 2002  David Howells (dhowells@redhat.com)
+ * - Incorporating suggestions made by Linus Torvalds and Dave Miller
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_THREAD_INFO_H
+#define _ASM_UBICOM32_THREAD_INFO_H
+
+#include <asm/page.h>
+
+/*
+ * Size of kernel stack for each process. This must be a power of 2...
+ */
+#ifdef CONFIG_4KSTACKS
+#define THREAD_SIZE_ORDER (0)
+#else
+#define THREAD_SIZE_ORDER (1)
+#endif
+
+/*
+ * for asm files, THREAD_SIZE is now generated by asm-offsets.c
+ */
+#define THREAD_SIZE (PAGE_SIZE<<THREAD_SIZE_ORDER)
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+/*
+ * low level task data.
+ */
+struct thread_info {
+	struct task_struct *task;		/* main task structure */
+	struct exec_domain *exec_domain;	/* execution domain */
+	unsigned long	   flags;		/* low level flags */
+	int		   cpu;			/* cpu we're on */
+	int		   preempt_count;	/* 0 => preemptable, <0 => BUG */
+	int		   interrupt_nesting; 	/* Interrupt nesting level. */
+	struct restart_block restart_block;
+};
+
+/*
+ * macros/functions for gaining access to the thread information structure
+ */
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.task		= &tsk,			\
+	.exec_domain	= &default_exec_domain,	\
+	.flags		= 0,			\
+	.cpu		= 0,			\
+	.interrupt_nesting	= 0,		\
+	.restart_block	= {			\
+		.fn = do_no_restart_syscall,	\
+	},					\
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+
+/* how to get the thread information struct from C */
+static inline struct thread_info *current_thread_info(void)
+{
+	struct thread_info *ti;
+
+	asm (
+		"and.4	%0, sp, %1\n\t"
+		: "=&r" (ti)
+		: "d" (~(THREAD_SIZE-1))
+		: "cc"
+	);
+
+	return ti;
+}
+
+#define STACK_WARN (THREAD_SIZE / 8)
+
+#define __HAVE_ARCH_THREAD_INFO_ALLOCATOR 1
+
+/* thread information allocation */
+#define alloc_thread_info(tsk) ((struct thread_info *) \
+				__get_free_pages(GFP_KERNEL, THREAD_SIZE_ORDER))
+#define free_thread_info(ti)	free_pages((unsigned long) (ti), THREAD_SIZE_ORDER)
+#endif /* __ASSEMBLY__ */
+
+#define	PREEMPT_ACTIVE	0x4000000
+
+/*
+ * thread information flag bit numbers
+ */
+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
+#define TIF_SIGPENDING		1	/* signal pending */
+#define TIF_NEED_RESCHED	2	/* rescheduling necessary */
+#define TIF_POLLING_NRFLAG	3	/* true if poll_idle() is polling
+					   TIF_NEED_RESCHED */
+#define TIF_MEMDIE		4
+
+/* as above, but as bit values */
+#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
+#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+
+#define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_UBICOM32_THREAD_INFO_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/timex.h linux-2.6.28.10/arch/ubicom32/include/asm/timex.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/timex.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/timex.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,56 @@
+/*
+ * arch/ubicom32/include/asm/timex.h
+ *   Ubicom32 architecture timex specifications.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_TIMEX_H
+#define _ASM_UBICOM32_TIMEX_H
+
+#define CLOCK_TICK_RATE	266000000
+
+// #define ARCH_HAS_READ_CURRENT_TIMER
+
+typedef unsigned long cycles_t;
+
+static inline cycles_t get_cycles(void)
+{
+	return 0;
+}
+
+extern int timer_alloc(void);
+extern void timer_set(int timervector, unsigned int cycles);
+extern int timer_reset(int timervector, unsigned int cycles);
+extern void timer_tick_init(void);
+extern void timer_device_init(void);
+
+#if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)
+extern void local_timer_interrupt(void);
+#endif
+
+#if defined(CONFIG_LOCAL_TIMERS) || defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)
+extern int local_timer_setup(unsigned int cpu);
+#endif
+
+#endif /* _ASM_UBICOM32_TIMEX_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/tlbflush.h linux-2.6.28.10/arch/ubicom32/include/asm/tlbflush.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/tlbflush.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/tlbflush.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,79 @@
+/*
+ * arch/ubicom32/include/asm/tlbflush.h
+ *   TLB operations for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ * Copyright (C) 2000 Lineo, David McCullough <davidm@uclinux.org>
+ * Copyright (C) 2000-2002, Greg Ungerer <gerg@snapgear.com>
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_TLB_FLUSH_H
+#define _ASM_UBICOM32_TLB_FLUSH_H
+
+#include <asm/setup.h>
+
+/*
+ * flush all user-space atc entries.
+ */
+static inline void __flush_tlb(void)
+{
+	BUG();
+}
+
+static inline void __flush_tlb_one(unsigned long addr)
+{
+	BUG();
+}
+
+#define flush_tlb() __flush_tlb()
+
+/*
+ * flush all atc entries (both kernel and user-space entries).
+ */
+static inline void flush_tlb_all(void)
+{
+	BUG();
+}
+
+static inline void flush_tlb_mm(struct mm_struct *mm)
+{
+	BUG();
+}
+
+static inline void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)
+{
+	BUG();
+}
+
+static inline void flush_tlb_range(struct mm_struct *mm,
+				   unsigned long start, unsigned long end)
+{
+	BUG();
+}
+
+static inline void flush_tlb_kernel_page(unsigned long addr)
+{
+	BUG();
+}
+
+#endif /* _ASM_UBICOM32_TLB_FLUSH_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/tlb.h linux-2.6.28.10/arch/ubicom32/include/asm/tlb.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/tlb.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/tlb.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,47 @@
+/*
+ * arch/ubicom32/include/asm/tlb.h
+ *   Ubicom32 architecture TLB operations.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_TLB_H
+#define _ASM_UBICOM32_TLB_H
+
+/*
+ * ubicom32 doesn't need any special per-pte or
+ * per-vma handling..
+ */
+#define tlb_start_vma(tlb, vma)	do { } while (0)
+#define tlb_end_vma(tlb, vma)	do { } while (0)
+#define __tlb_remove_tlb_entry(tlb, ptep, address)	do { } while (0)
+
+/*
+ * .. because we flush the whole mm when it
+ * fills up.
+ */
+#define tlb_flush(tlb)
+
+#include <asm-generic/tlb.h>
+
+#endif /* _ASM_UBICOM32_TLB_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/topology.h linux-2.6.28.10/arch/ubicom32/include/asm/topology.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/topology.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/topology.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/topology.h
+ *   Generic topology.h definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_TOPOLOGY_H
+#define _ASM_UBICOM32_TOPOLOGY_H
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_UBICOM32_TOPOLOGY_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/traps.h linux-2.6.28.10/arch/ubicom32/include/asm/traps.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/traps.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/traps.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,55 @@
+/*
+ * arch/ubicom32/include/asm/traps.h
+ *   Trap related definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_TRAPS_H
+#define _ASM_UBICOM32_TRAPS_H
+
+/*
+ * Trap causes passed from ultra to Host OS
+ */
+#define TRAP_CAUSE_TOTAL		13
+#define TRAP_CAUSE_DST_RANGE_ERR	12
+#define TRAP_CAUSE_SRC1_RANGE_ERR	11
+#define TRAP_CAUSE_I_RANGE_ERR		10
+#define TRAP_CAUSE_DCAPT		9
+#define TRAP_CAUSE_DST_SERROR		8
+#define TRAP_CAUSE_SRC1_SERROR		7
+#define TRAP_CAUSE_DST_MISALIGNED	6
+#define TRAP_CAUSE_SRC1_MISALIGNED	5
+#define TRAP_CAUSE_DST_DECODE_ERR	4
+#define TRAP_CAUSE_SRC1_DECODE_ERR	3
+#define TRAP_CAUSE_ILLEGAL_INST		2
+#define TRAP_CAUSE_I_SERROR		1
+#define TRAP_CAUSE_I_DECODE_ERR		0
+
+extern void trap_handler(int irq, struct pt_regs *regs);
+extern void trap_init_interrupt(void);
+extern void unaligned_emulate(unsigned int thread);
+extern int unaligned_only(unsigned int cause);
+
+#endif /* _ASM_UBICOM32_TRAPS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/types.h linux-2.6.28.10/arch/ubicom32/include/asm/types.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/types.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/types.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,75 @@
+/*
+ * arch/ubicom32/include/asm/types.h
+ *   Date type definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_TYPES_H
+#define _ASM_UBICOM32_TYPES_H
+
+/*
+ * This file is never included by application software unless
+ * explicitly requested (e.g., via linux/types.h) in which case the
+ * application is Linux specific so (user-) name space pollution is
+ * not a major issue.  However, for interoperability, libraries still
+ * need to be careful to avoid a name clashes.
+ */
+
+#include <asm-generic/int-ll64.h>
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+/* DMA addresses are always 32-bits wide */
+
+typedef u32 dma_addr_t;
+typedef u32 dma64_addr_t;
+
+/*
+ * XXX These are "Ubicom style" typedefs. They should be removed in all files used by linux.
+ */
+typedef u32 u32_t;
+typedef s32 s32_t;
+typedef u16 u16_t;
+typedef s16 s16_t;
+typedef u8 u8_t;
+typedef s8 s8_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_UBICOM32_TYPES_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/uaccess.h linux-2.6.28.10/arch/ubicom32/include/asm/uaccess.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/uaccess.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/uaccess.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,347 @@
+/*
+ * arch/ubicom32/include/asm/uaccess.h
+ *   User space memory access functions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ *   arch/alpha
+ */
+#ifndef _ASM_UBICOM32_UACCESS_H
+#define _ASM_UBICOM32_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+
+#include <asm/segment.h>
+
+#define VERIFY_READ	0
+#define VERIFY_WRITE	1
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+/* 
+ * Ubicom32 does not currently support the exception table handling.
+ */
+extern unsigned long search_exception_table(unsigned long);
+
+
+#if defined(CONFIG_ACCESS_OK_CHECKS_ENABLED)
+extern int __access_ok(unsigned long addr, unsigned long size);
+#else
+static inline int __access_ok(unsigned long addr, unsigned long size)
+{
+	return 1;
+}
+#endif
+#define access_ok(type, addr, size) \
+	likely(__access_ok((unsigned long)(addr), (size)))
+
+/*
+ * The following functions do not exist.  They keep callers
+ * of put_user and get_user from passing unsupported argument
+ * types.  They result in a link time error.
+ */
+extern int __put_user_bad(void);
+extern int __get_user_bad(void);
+
+/*
+ * __put_user_no_check()
+ *	Put the requested data into the user space verifying the address
+ *
+ * Careful to not
+ * (a) re-use the arguments for side effects (sizeof/typeof is ok)
+ * (b) require any knowledge of processes at this stage
+ */
+#define __put_user_no_check(x, ptr, size)		\
+({							\
+	int __pu_err = 0;				\
+	__typeof__(*(ptr)) __user *__pu_addr = (ptr);	\
+	switch (size) {					\
+	case 1:						\
+	case 2:						\
+	case 4:						\
+	case 8:						\
+		*__pu_addr = (__typeof__(*(ptr)))x;	\
+		break;					\
+	default:					\
+		__pu_err = __put_user_bad();		\
+		break;					\
+	}						\
+	__pu_err;					\
+})
+
+/*
+ * __put_user_check()
+ *	Put the requested data into the user space verifying the address
+ *
+ * Careful to not
+ * (a) re-use the arguments for side effects (sizeof/typeof is ok)
+ * (b) require any knowledge of processes at this stage
+ *
+ * If requested, access_ok() will verify that ptr is a valid user
+ * pointer.
+ */
+#define __put_user_check(x, ptr, size)				\
+({								\
+	int __pu_err = -EFAULT;					\
+	__typeof__(*(ptr)) __user *__pu_addr = (ptr);		\
+	if (access_ok(VERIFY_WRITE, __pu_addr, size)) {		\
+		__pu_err = 0;					\
+		switch (size) {					\
+		case 1:						\
+		case 2:						\
+		case 4:						\
+		case 8:						\
+			*__pu_addr = (__typeof__(*(ptr)))x;	\
+			break;					\
+		default:					\
+			__pu_err = __put_user_bad();		\
+			break;					\
+		}						\
+	}							\
+	__pu_err;						\
+})
+
+/*
+ * __get_user_no_check()
+ *	Read the value at ptr into x.
+ *
+ * If requested, access_ok() will verify that ptr is a valid user
+ * pointer.  If the caller passes a modifying argument for ptr (e.g. x++)
+ * this macro will not work.
+ */
+#define __get_user_no_check(x, ptr, size)			\
+({								\
+	int __gu_err = 0;					\
+	__typeof__((x)) __gu_val = 0;				\
+	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);	\
+	switch (size) {						\
+	case 1:							\
+	case 2:							\
+	case 4:							\
+	case 8:							\
+		__gu_val = (__typeof__((x)))*(__gu_addr);	\
+		break;						\
+	default:						\
+		__gu_err = __get_user_bad();			\
+		(x) = 0;					\
+		break;						\
+	}							\
+	(x) = __gu_val;						\
+	__gu_err;						\
+})
+
+/*
+ * __get_user_check()
+ *	Read the value at ptr into x.
+ *
+ * If requested, access_ok() will verify that ptr is a valid user
+ * pointer.
+ */
+#define __get_user_check(x, ptr, size)					\
+({									\
+	int __gu_err = -EFAULT;						\
+	__typeof__(x) __gu_val = 0;					\
+	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);		\
+	if (access_ok(VERIFY_READ, __gu_addr, size)) {			\
+		__gu_err = 0;						\
+		switch (size) {						\
+		case 1:							\
+		case 2:							\
+		case 4:							\
+		case 8:							\
+			__gu_val = (__typeof__((x)))*(__gu_addr);	\
+			break;						\
+		default:						\
+			__gu_err = __get_user_bad();			\
+			(x) = 0;					\
+			break;						\
+		}							\
+	}								\
+	(x) = __gu_val;							\
+	__gu_err;							\
+})
+
+/*
+ * The "xxx" versions are allowed to perform some amount of address
+ * space checking.  See access_ok().
+ */
+#define put_user(x,ptr) \
+	__put_user_check((__typeof__(*(ptr)))(x),(ptr), sizeof(*(ptr)))
+#define get_user(x,ptr) \
+	__get_user_check((x), (ptr), sizeof(*(ptr)))
+
+/*
+ * The "__xxx" versions do not do address space checking, useful when
+ * doing multiple accesses to the same area (the programmer has to do the
+ * checks by hand with "access_ok()")
+ */
+#define __put_user(x,ptr) \
+	__put_user_no_check((__typeof__(*(ptr)))(x),(ptr), sizeof(*(ptr)))
+#define __get_user(x,ptr) \
+	__get_user_no_check((x), (ptr), sizeof(*(ptr)))
+
+/*
+ * __copy_tofrom_user_no_check()
+ *	Copy the data either to or from user space.
+ *
+ * Return the number of bytes NOT copied.
+ */
+static inline unsigned long
+__copy_tofrom_user_no_check(void *to, const void *from, unsigned long n)
+{
+	memcpy(to, from, n);
+	return 0;
+}
+
+/*
+ * copy_to_user()
+ * 	Copy the kernel data to user space.
+ *
+ * Return the number of bytes that were copied.
+ */
+static inline unsigned long 
+copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	if (!access_ok(VERIFY_WRITE, to, n)) {
+		return n;
+	}
+	return __copy_tofrom_user_no_check((__force void *)to, from, n);
+}
+
+/*
+ * copy_from_user()
+ * 	Copy the user data to kernel space.
+ *
+ * Return the number of bytes that were copied.  On error, we zero 
+ * out the destination.
+ */
+static inline unsigned long
+copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	if (!access_ok(VERIFY_READ, from, n)) {
+		return n;
+	}
+	return __copy_tofrom_user_no_check(to, (__force void *)from, n);
+}
+
+#define __copy_to_user(to, from, n) \
+	__copy_tofrom_user_no_check((__force void *)to, from, n)
+#define __copy_from_user(to, from, n) \
+	__copy_tofrom_user_no_check(to, (__force void *)from, n)
+#define __copy_to_user_inatomic(to, from, n) \
+	__copy_tofrom_user_no_check((__force void *)to, from, n)
+#define __copy_from_user_inatomic(to, from, n) \
+	__copy_tofrom_user_no_check(to, (__force void *)from, n)
+
+#define copy_to_user_ret(to, from, n, retval) \
+	({ if (copy_to_user(to, from, n)) return retval; })
+
+#define copy_from_user_ret(to, from, n, retval) \
+	({ if (copy_from_user(to, from, n)) return retval; })
+
+/*
+ * strncpy_from_user()
+ *	Copy a null terminated string from userspace.
+ *
+ * dst - Destination in kernel space.  The buffer must be at least count.
+ * src - Address of string in user space.
+ * count - Maximum number of bytes to copy (including the trailing NULL).
+ * 
+ * Returns the length of the string (not including the trailing NULL.  If 
+ * count is smaller than the length of the string, we copy count bytes
+ * and return count.
+ *
+ */
+static inline long strncpy_from_user(char *dst, const __user char *src, long count)
+{
+	char *tmp;
+	if (!access_ok(VERIFY_READ, src, 1)) {
+		return -EFAULT;
+	}
+
+	strncpy(dst, src, count);
+	for (tmp = dst; *tmp && count > 0; tmp++, count--) {
+		;
+	}
+	return(tmp - dst);
+}
+
+/*
+ * strnlen_user()
+ *	Return the size of a string (including the ending 0)
+ *
+ * Return -EFAULT on exception, a value greater than <n> if too long
+ */
+static inline long strnlen_user(const __user char *src, long n)
+{
+	if (!access_ok(VERIFY_READ, src, 1)) {
+		return -EFAULT;
+	}
+	return(strlen(src) + 1);
+}
+
+#define strlen_user(str) strnlen_user(str, 32767)
+
+/*
+ * __clear_user()
+ *	Zero Userspace
+ */
+static inline unsigned long __clear_user(__user void *to, unsigned long n)
+{
+	memset(to, 0, n);
+	return 0;
+}
+
+/*
+ * clear_user()
+ *	Zero user space (check for valid addresses)
+ */
+static inline unsigned long clear_user(__user void *to, unsigned long n)
+{
+	if (!access_ok(VERIFY_WRITE, to, n)) {
+		return -EFAULT;
+	}
+	return __clear_user(to, n);
+}
+
+#endif /* _ASM_UBICOM32_UACCESS_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ubicom32-common-asm.h linux-2.6.28.10/arch/ubicom32/include/asm/ubicom32-common-asm.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ubicom32-common-asm.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ubicom32-common-asm.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,49 @@
+/*
+ * arch/ubicom32/include/asm/ubicom32-common-asm.h
+ *   Ubicom32 atomic lock operations.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_UBICOM32_COMMON_ASM_H
+#define _ASM_UBICOM32_UBICOM32_COMMON_ASM_H
+
+/*
+ * atomic_lock_acquire macro
+ *	Equivalent to __atomic_lock_acquire()
+ */
+.macro atomic_lock_acquire
+	bset scratchpad1, scratchpad1, #ATOMIC_LOCK_BIT
+	jmpne.f	.-4
+.endm
+
+/*
+ * atomic_lock_release macro
+ *	Equivalent to __atomic_lock_release()
+ */
+.macro atomic_lock_release
+	bclr scratchpad1, scratchpad1, #ATOMIC_LOCK_BIT
+.endm
+
+#endif /* _ASM_UBICOM32_UBICOM32_COMMON_ASM_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ubicom32-common.h linux-2.6.28.10/arch/ubicom32/include/asm/ubicom32-common.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ubicom32-common.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ubicom32-common.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,124 @@
+/*
+ * arch/ubicom32/include/asm/ubicom32-common.h
+ *   Ubicom32 atomic lock operations.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+
+#ifndef _ASM_UBICOM32_UBICOM32_COMMON_H
+#define _ASM_UBICOM32_UBICOM32_COMMON_H
+
+#define S(arg) #arg
+#define D(arg) S(arg)
+/*
+ * scratchpad1 is owned by the LDSR.  
+ * 
+ * The upper bits provide 16 global spinlocks.  Acquiring one of these
+ * global spinlocks synchornizes across multiple threads and prevents 
+ * the LDSR from delivering any interrupts while the lock is held.
+ * Use these locks only when absolutely required.
+ *
+ * The lower 16 bits of scratchpad1 are used as per thread interrupt
+ * enable/disable bits.  These bits will prevent a thread from receiving
+ * any interrupts.
+ *
+ * Bit Usage:
+ * - MT_EN_LOCK_BIT   - Protects writes to MT_EN, so code can read current value
+ *			then write a new value atomically (profiler for example)
+ * - ATOMIC_LOCK_BIT - Used to provide general purpose atomic handling.
+ * - LDSR_LOCK_BIT   - Used by the LDSR exclusively to provide protection.
+ * - LSB 16 bits     - Used by the LDSR to represent thread enable/disable bits.
+ */
+#define MT_EN_LOCK_BIT	31
+#define ATOMIC_LOCK_BIT 30
+#define LDSR_LOCK_BIT   29
+#define PCI_LOCK_BIT	28
+
+#if !defined(__ASSEMBLY__)
+
+#define UBICOM32_TRYLOCK(bit) \
+	asm volatile (						      \
+	"	move.4 %0, #0					\n\t" \
+	"	bset scratchpad1, scratchpad1, #"D(bit)"	\n\t" \
+	"	jmpne.f	1f					\n\t" \
+	"	move.4 %0, #1					\n\t" \
+	"1:							\n\t" \
+		: "=r" (ret)					      \
+		:						      \
+		: "cc", "memory"				      \
+	);							      \
+
+#define UBICOM32_UNLOCK(bit) \
+	asm volatile (						      \
+	"	bclr scratchpad1, scratchpad1, #"D(bit)"	\n\t" \
+		:						      \
+		:						      \
+		: "cc", "memory"				      \
+	);							      \
+
+#define UBICOM32_LOCK(bit) \
+	asm volatile (						      \
+	"1:	bset scratchpad1, scratchpad1, #"D(bit)"	\n\t" \
+	"	jmpne.f	1b					\n\t" \
+		:						      \
+		:						      \
+		: "cc", "memory"				      \
+	);							      \
+
+/*
+ * __atomic_lock_trylock()
+ *	Attempt to acquire the lock, return TRUE if acquired.
+ */
+static inline int __atomic_lock_trylock(void)
+{
+	int ret;
+	UBICOM32_TRYLOCK(ATOMIC_LOCK_BIT);
+	return ret;
+}
+
+/*
+ * __atomic_lock_release()
+ *	Release the global atomic lock.
+ *
+ * Note: no one is suspended waiting since this lock is a spinning lock.
+ */
+static inline void __atomic_lock_release(void)
+{
+	UBICOM32_UNLOCK(ATOMIC_LOCK_BIT);
+}
+
+/*
+ * __atomic_lock_acquire()
+ *	Acquire the global atomic lock, spin if not available.
+ */
+static inline void __atomic_lock_acquire(void)
+{
+	UBICOM32_LOCK(ATOMIC_LOCK_BIT);
+}
+#else /* __ASSEMBLY__ */
+
+#include <asm/ubicom32-common-asm.h>
+
+#endif /* __ASSEMBLY__ */
+#endif /* _ASM_UBICOM32_UBICOM32_COMMON_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/ucontext.h linux-2.6.28.10/arch/ubicom32/include/asm/ucontext.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/ucontext.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/ucontext.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,39 @@
+/*
+ * arch/ubicom32/include/asm/ucontext.h
+ *   Definition of ucontext structure for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_UCONTEXT_H
+#define _ASM_UBICOM32_UCONTEXT_H
+
+struct ucontext {
+	unsigned long	  uc_flags;
+	struct ucontext  *uc_link;
+	stack_t		  uc_stack;
+	struct sigcontext	  uc_mcontext;
+	sigset_t	  uc_sigmask;	/* mask last for extensibility */
+};
+
+#endif /* _ASM_UBICOM32_UCONTEXT_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/unaligned.h linux-2.6.28.10/arch/ubicom32/include/asm/unaligned.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/unaligned.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/unaligned.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * arch/ubicom32/include/asm/unaligned.h
+ *   Ubicom32 architecture unaligned memory access definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ *
+ * TODO: This is a copy of arm unaligned handling that probably needs
+ * to be optimized for UBICOM32, but it works for now.
+ */
+
+#ifndef _ASM_UBICOM32_UNALIGNED_H
+#define _ASM_UBICOM32_UNALIGNED_H
+
+#include <asm/types.h>
+
+#include <linux/unaligned/le_byteshift.h>
+#include <linux/unaligned/be_byteshift.h>
+#include <linux/unaligned/generic.h>
+
+#define get_unaligned	__get_unaligned_be
+#define put_unaligned	__put_unaligned_be
+
+#endif /* _ASM_UBICOM32_UNALIGNED_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/unistd.h linux-2.6.28.10/arch/ubicom32/include/asm/unistd.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/unistd.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/unistd.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,400 @@
+/*
+ * arch/ubicom32/include/asm/unistd.h
+ *   Ubicom32 architecture syscall definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_UNISTD_H
+#define _ASM_UBICOM32_UNISTD_H
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_restart_syscall      0
+#define __NR_exit		  1
+#define __NR_fork		  2
+#define __NR_read		  3
+#define __NR_write		  4
+#define __NR_open		  5
+#define __NR_close		  6
+#define __NR_waitpid		  7
+#define __NR_creat		  8
+#define __NR_link		  9
+#define __NR_unlink		 10
+#define __NR_execve		 11
+#define __NR_chdir		 12
+#define __NR_time		 13
+#define __NR_mknod		 14
+#define __NR_chmod		 15
+#define __NR_chown		 16
+#define __NR_break		 17
+#define __NR_oldstat		 18
+#define __NR_lseek		 19
+#define __NR_getpid		 20
+#define __NR_mount		 21
+#define __NR_umount		 22
+#define __NR_setuid		 23
+#define __NR_getuid		 24
+#define __NR_stime		 25
+#define __NR_ptrace		 26
+#define __NR_alarm		 27
+#define __NR_oldfstat		 28
+#define __NR_pause		 29
+#define __NR_utime		 30
+#define __NR_stty		 31
+#define __NR_gtty		 32
+#define __NR_access		 33
+#define __NR_nice		 34
+#define __NR_ftime		 35
+#define __NR_sync		 36
+#define __NR_kill		 37
+#define __NR_rename		 38
+#define __NR_mkdir		 39
+#define __NR_rmdir		 40
+#define __NR_dup		 41
+#define __NR_pipe		 42
+#define __NR_times		 43
+#define __NR_prof		 44
+#define __NR_brk		 45
+#define __NR_setgid		 46
+#define __NR_getgid		 47
+#define __NR_signal		 48
+#define __NR_geteuid		 49
+#define __NR_getegid		 50
+#define __NR_acct		 51
+#define __NR_umount2		 52
+#define __NR_lock		 53
+#define __NR_ioctl		 54
+#define __NR_fcntl		 55
+#define __NR_mpx		 56
+#define __NR_setpgid		 57
+#define __NR_ulimit		 58
+#define __NR_oldolduname	 59
+#define __NR_umask		 60
+#define __NR_chroot		 61
+#define __NR_ustat		 62
+#define __NR_dup2		 63
+#define __NR_getppid		 64
+#define __NR_getpgrp		 65
+#define __NR_setsid		 66
+#define __NR_sigaction		 67
+#define __NR_sgetmask		 68
+#define __NR_ssetmask		 69
+#define __NR_setreuid		 70
+#define __NR_setregid		 71
+#define __NR_sigsuspend		 72
+#define __NR_sigpending		 73
+#define __NR_sethostname	 74
+#define __NR_setrlimit		 75
+#define __NR_getrlimit		 76
+#define __NR_getrusage		 77
+#define __NR_gettimeofday	 78
+#define __NR_settimeofday	 79
+#define __NR_getgroups		 80
+#define __NR_setgroups		 81
+#define __NR_select		 82
+#define __NR_symlink		 83
+#define __NR_oldlstat		 84
+#define __NR_readlink		 85
+#define __NR_uselib		 86
+#define __NR_swapon		 87
+#define __NR_reboot		 88
+#define __NR_readdir		 89
+#define __NR_mmap		 90
+#define __NR_munmap		 91
+#define __NR_truncate		 92
+#define __NR_ftruncate		 93
+#define __NR_fchmod		 94
+#define __NR_fchown		 95
+#define __NR_getpriority	 96
+#define __NR_setpriority	 97
+#define __NR_profil		 98
+#define __NR_statfs		 99
+#define __NR_fstatfs		100
+#define __NR_ioperm		101
+#define __NR_socketcall		102
+#define __NR_syslog		103
+#define __NR_setitimer		104
+#define __NR_getitimer		105
+#define __NR_stat		106
+#define __NR_lstat		107
+#define __NR_fstat		108
+#define __NR_olduname		109
+#define __NR_iopl		/* 110 */ not supported
+#define __NR_vhangup		111
+#define __NR_idle		/* 112 */ Obsolete
+#define __NR_vm86		/* 113 */ not supported
+#define __NR_wait4		114
+#define __NR_swapoff		115
+#define __NR_sysinfo		116
+#define __NR_ipc		117
+#define __NR_fsync		118
+#define __NR_sigreturn		119
+#define __NR_clone		120
+#define __NR_setdomainname	121
+#define __NR_uname		122
+#define __NR_cacheflush		123
+#define __NR_adjtimex		124
+#define __NR_mprotect		125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl		131
+#define __NR_getpgid		132
+#define __NR_fchdir		133
+#define __NR_bdflush		134
+#define __NR_sysfs		135
+#define __NR_personality	136
+#define __NR_afs_syscall	137 /* Syscall for Andrew File System */
+#define __NR_setfsuid		138
+#define __NR_setfsgid		139
+#define __NR__llseek		140
+#define __NR_getdents		141
+#define __NR__newselect		142
+#define __NR_flock		143
+#define __NR_msync		144
+#define __NR_readv		145
+#define __NR_writev		146
+#define __NR_getsid		147
+#define __NR_fdatasync		148
+#define __NR__sysctl		149
+#define __NR_mlock		150
+#define __NR_munlock		151
+#define __NR_mlockall		152
+#define __NR_munlockall		153
+#define __NR_sched_setparam		154
+#define __NR_sched_getparam		155
+#define __NR_sched_setscheduler		156
+#define __NR_sched_getscheduler		157
+#define __NR_sched_yield		158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep		162
+#define __NR_mremap		163
+#define __NR_setresuid		164
+#define __NR_getresuid		165
+#define __NR_getpagesize	166
+#define __NR_query_module	167
+#define __NR_poll		168
+#define __NR_nfsservctl		169
+#define __NR_setresgid		170
+#define __NR_getresgid		171
+#define __NR_prctl		172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread64		180
+#define __NR_pwrite64		181
+#define __NR_lchown		182
+#define __NR_getcwd		183
+#define __NR_capget		184
+#define __NR_capset		185
+#define __NR_sigaltstack	186
+#define __NR_sendfile		187
+#define __NR_getpmsg		188	/* some people actually want streams */
+#define __NR_putpmsg		189	/* some people actually want streams */
+#define __NR_vfork		190
+#define __NR_ugetrlimit		191
+#define __NR_mmap2		192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_chown32		198
+#define __NR_getuid32		199
+#define __NR_getgid32		200
+#define __NR_geteuid32		201
+#define __NR_getegid32		202
+#define __NR_setreuid32		203
+#define __NR_setregid32		204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32		207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_lchown32		212
+#define __NR_setuid32		213
+#define __NR_setgid32		214
+#define __NR_setfsuid32		215
+#define __NR_setfsgid32		216
+#define __NR_pivot_root		217
+#define __NR_getdents64		220
+#define __NR_gettid		221
+#define __NR_tkill		222
+#define __NR_setxattr		223
+#define __NR_lsetxattr		224
+#define __NR_fsetxattr		225
+#define __NR_getxattr		226
+#define __NR_lgetxattr		227
+#define __NR_fgetxattr		228
+#define __NR_listxattr		229
+#define __NR_llistxattr		230
+#define __NR_flistxattr		231
+#define __NR_removexattr	232
+#define __NR_lremovexattr	233
+#define __NR_fremovexattr	234
+#define __NR_futex		235
+#define __NR_sendfile64		236
+#define __NR_mincore		237
+#define __NR_madvise		238
+#define __NR_fcntl64		239
+#define __NR_readahead		240
+#define __NR_io_setup		241
+#define __NR_io_destroy		242
+#define __NR_io_getevents	243
+#define __NR_io_submit		244
+#define __NR_io_cancel		245
+#define __NR_fadvise64		246
+#define __NR_exit_group		247
+#define __NR_lookup_dcookie	248
+#define __NR_epoll_create	249
+#define __NR_epoll_ctl		250
+#define __NR_epoll_wait		251
+#define __NR_remap_file_pages	252
+#define __NR_set_tid_address	253
+#define __NR_timer_create	254
+#define __NR_timer_settime	255
+#define __NR_timer_gettime	256
+#define __NR_timer_getoverrun	257
+#define __NR_timer_delete	258
+#define __NR_clock_settime	259
+#define __NR_clock_gettime	260
+#define __NR_clock_getres	261
+#define __NR_clock_nanosleep	262
+#define __NR_statfs64		263
+#define __NR_fstatfs64		264
+#define __NR_tgkill		265
+#define __NR_utimes		266
+#define __NR_fadvise64_64	267
+#define __NR_mbind		268
+#define __NR_get_mempolicy	269
+#define __NR_set_mempolicy	270
+#define __NR_mq_open		271
+#define __NR_mq_unlink		272
+#define __NR_mq_timedsend	273
+#define __NR_mq_timedreceive	274
+#define __NR_mq_notify		275
+#define __NR_mq_getsetattr	276
+#define __NR_waitid		277
+#define __NR_vserver		278
+#define __NR_add_key		279
+#define __NR_request_key	280
+#define __NR_keyctl		281
+#define __NR_ioprio_set		282
+#define __NR_ioprio_get		283
+#define __NR_inotify_init	284
+#define __NR_inotify_add_watch	285
+#define __NR_inotify_rm_watch	286
+#define __NR_migrate_pages	287
+#define __NR_openat		288
+#define __NR_mkdirat		289
+#define __NR_mknodat		290
+#define __NR_fchownat		291
+#define __NR_futimesat		292
+#define __NR_fstatat64		293
+#define __NR_unlinkat		294
+#define __NR_renameat		295
+#define __NR_linkat		296
+#define __NR_symlinkat		297
+#define __NR_readlinkat		298
+#define __NR_fchmodat		299
+#define __NR_faccessat		300
+#define __NR_pselect6		301
+#define __NR_ppoll		302
+#define __NR_unshare		303
+#define __NR_set_robust_list	304
+#define __NR_get_robust_list	305
+#define __NR_splice		306
+#define __NR_sync_file_range	307
+#define __NR_tee		308
+#define __NR_vmsplice		309
+#define __NR_move_pages		310
+#define __NR_sched_setaffinity	311
+#define __NR_sched_getaffinity	312
+#define __NR_kexec_load		313
+#define __NR_getcpu		314
+#define __NR_epoll_pwait	315
+#define __NR_utimensat		316
+#define __NR_signalfd		317
+#define __NR_timerfd_create	318
+#define __NR_eventfd		319
+#define __NR_fallocate		320
+#define __NR_timerfd_settime	321
+#define __NR_timerfd_gettime	322
+#define __NR_signalfd4		323
+#define __NR_eventfd2		324
+#define __NR_epoll_create1	325
+#define __NR_dup3		326
+#define __NR_pipe2		327
+#define __NR_inotify_init1	328
+
+#ifdef __KERNEL__
+
+#define NR_syscalls		329
+
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_OLD_STAT
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_SGETMASK
+#define __ARCH_WANT_SYS_SIGNAL
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_WAITPID
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+//#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
+#define cond_syscall(x) long x(void)  __attribute__((weak,alias("sys_ni_syscall")))
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_UBICOM32_UNISTD_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/user.h linux-2.6.28.10/arch/ubicom32/include/asm/user.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/user.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/user.h	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,82 @@
+/*
+ * arch/ubicom32/include/asm/user.h
+ *   Ubicom32 architecture core file definitions.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_USER_H
+#define _ASM_UBICOM32_USER_H
+
+#include <asm/ptrace.h>
+#include <asm/page.h>
+/*
+ * Adapted from <asm-powerpc/user.h>
+ *
+ * Core file format: The core file is written in such a way that gdb
+ * can understand it and provide useful information to the user (under
+ * linux we use the `trad-core' bfd, NOT the osf-core).  The file contents
+ * are as follows:
+ *
+ *  upage: 1 page consisting of a user struct that tells gdb
+ *	what is present in the file.  Directly after this is a
+ *	copy of the task_struct, which is currently not used by gdb,
+ *	but it may come in handy at some point.  All of the registers
+ *	are stored as part of the upage.  The upage should always be
+ *	only one page long.
+ *  data: The data segment follows next.  We use current->end_text to
+ *	current->brk to pick up all of the user variables, plus any memory
+ *	that may have been sbrk'ed.  No attempt is made to determine if a
+ *	page is demand-zero or if a page is totally unused, we just cover
+ *	the entire range.  All of the addresses are rounded in such a way
+ *	that an integral number of pages is written.
+ *  stack: We need the stack information in order to get a meaningful
+ *	backtrace.  We need to write the data from usp to
+ *	current->start_stack, so we round each of these in order to be able
+ *	to write an integer number of pages.
+ */
+
+struct user_ubicom32fp_struct {
+};
+
+struct user {
+	struct pt_regs	regs;			/* entire machine state */
+	size_t		u_tsize;		/* text size (pages) */
+	size_t		u_dsize;		/* data size (pages) */
+	size_t		u_ssize;		/* stack size (pages) */
+	unsigned long	start_code;		/* text starting address */
+	unsigned long	start_data;		/* data starting address */
+	unsigned long	start_stack;		/* stack starting address */
+	long int	signal;			/* signal causing core dump */
+	unsigned long	u_ar0;			/* help gdb find registers */
+	unsigned long	magic;			/* identifies a core file */
+	char		u_comm[32];		/* user command name */
+};
+
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif	/* _ASM_UBICOM32_USER_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/include/asm/xor.h linux-2.6.28.10/arch/ubicom32/include/asm/xor.h
--- linux-2.6.28.10_o/arch/ubicom32/include/asm/xor.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/include/asm/xor.h	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * arch/ubicom32/include/asm/xor.h
+ *   Generic xor.h definitions for Ubicom32 architecture.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+#ifndef _ASM_UBICOM32_XOR_H
+#define _ASM_UBICOM32_XOR_H
+
+#include <asm-generic/xor.h>
+
+#endif /* _ASM_UBICOM32_XOR_H */
diff -ruN linux-2.6.28.10_o/arch/ubicom32/Kconfig linux-2.6.28.10/arch/ubicom32/Kconfig
--- linux-2.6.28.10_o/arch/ubicom32/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/Kconfig	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,457 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+mainmenu "uClinux/ubicom32 (w/o MMU) Kernel Configuration"
+
+config RAMBASE
+	hex
+	default "0x40000000"
+	help
+		Define the address that RAM starts at.
+
+config UBICOM32
+	bool
+	select HAVE_OPROFILE
+	default y
+
+config RAMKERNEL
+	bool
+	default y
+
+config CPU_BIG_ENDIAN
+	bool
+	default y
+
+config FORCE_MAX_ZONEORDER
+	int
+	default "14"
+
+config HAVE_CLK
+	bool
+	default y
+
+config MMU
+	bool
+	default n
+
+config FPU
+	bool
+	default n
+
+config ZONE_DMA
+	bool
+	default y
+
+config RWSEM_GENERIC_SPINLOCK
+	bool
+	default y
+
+config RWSEM_XCHGADD_ALGORITHM
+	bool
+	default n
+
+config ARCH_HAS_ILOG2_U32
+	bool
+	default n
+
+config ARCH_HAS_ILOG2_U64
+	bool
+	default n
+
+config GENERIC_FIND_NEXT_BIT
+	bool
+	default y
+
+config GENERIC_GPIO
+	bool
+	default y
+
+config GPIOLIB
+	bool
+	default y
+
+config GENERIC_HWEIGHT
+	bool
+	default y
+
+config GENERIC_HARDIRQS
+	bool
+	default y
+
+config STACKTRACE_SUPPORT
+	bool
+	default y
+
+config LOCKDEP_SUPPORT
+	bool
+	default y
+
+config GENERIC_CALIBRATE_DELAY
+	bool
+	default y
+
+config GENERIC_TIME
+	bool
+	default y
+
+config TIME_LOW_RES
+	bool
+	default y
+
+config GENERIC_CLOCKEVENTS
+	bool
+	default y
+
+config GENERIC_CLOCKEVENTS_BROADCAST
+	bool
+	depends on GENERIC_CLOCKEVENTS
+	default y if SMP && !LOCAL_TIMERS
+
+config NO_IOPORT
+	def_bool y
+
+config ARCH_SUPPORTS_AOUT
+	def_bool y
+
+config IRQ_PER_CPU
+	bool
+	default y
+
+config SCHED_NO_NO_OMIT_FRAME_POINTER
+	bool
+	default y
+
+menu "Processor type and features"
+
+config BRD_32MB
+	bool
+	depends on IP5160EVAL
+	help
+		Board has 32MB of RAM on it.  It is a hidden option used to select default for size of RAM
+	default n
+
+config BRD_64MB
+	bool
+	depends on IP7145DPF || IP7160RGW || IP7160BRINGUP || IP7160DPF || IP5170DPF || IP5160DEV
+	help
+		Board has 64MB of RAM on it.  It is a hidden option used to select default for size of RAM
+	default n
+
+config BRD_128MB
+	bool
+	depends on IP7500MODULE || IP7500AV || IP7500MEDIA
+	help
+		Board has 128MB of RAM on it.  It is a hidden option used to select default for size of RAM
+	default n
+
+comment "Processor type will be selected by Board"
+
+config UBICOM32_V3
+	bool
+	help
+	  Ubicom IP5xxx series processor support.
+
+config UBICOM32_V4
+	bool
+	help
+	  Ubicom IP7xxx series processor support.
+
+comment "Board"
+choice
+	prompt "Board type"
+	help
+		Select your board.
+
+config NOBOARD
+	bool "No board selected"
+	help
+		Default. Don't select any board specific config. Will not build unless you change!
+
+# Add your boards here
+source "arch/ubicom32/mach-ip5k/Kconfig"
+source "arch/ubicom32/mach-ip7k/Kconfig"
+
+endchoice
+
+comment "Kernel Options"
+config SMP
+	bool "Symmetric multi-processing support"
+	select USE_GENERIC_SMP_HELPERS
+	default n
+	help
+	  Enables multithreading support.  Enabling SMP support increases
+	  the size of system data structures.  SMP support can have either 
+	  positive or negative impact on performance depending on workloads. 
+
+	  If you do not know what to do here, say N.
+
+config NR_CPUS
+	int "Number of configured CPUs"
+	range 2 32
+	default 2
+	depends on SMP
+	help
+		Upper bound on the number of CPUs. Space is reserved 
+		at compile time for this many CPUs.
+		
+config LOCAL_TIMERS
+	bool "Use local timer interrupts"
+	depends on SMP
+	default y
+	help
+	  Enable support for local timers on SMP platforms, rather then the
+	  legacy IPI broadcast method.  Local timers allows the system
+	  accounting to be spread across the timer interval, preventing a
+	  "thundering herd" at every timer tick.  A physical timer is allocated
+	  per cpu.		
+
+config TIMER_EXTRA_ALLOC
+	int "Number of additional physical timer events to create"
+	depends on GENERIC_CLOCKEVENTS
+	default 0
+	help
+		The Ubicom32 processor has a number of event timers that can be wrapped
+		in Linux clock event structures (assuming that the timers are not being
+		used for another purpose).  Based on the value of LOCAL_TIMERS, either 
+		2 timers will be used or a timer will be used for every CPU.  This value
+		allows the programmer to select additional timers over that amount.
+			
+config IRQSTACKS
+	bool "Create separate stacks for interrupt handling"
+	default n
+	help
+		Selecting this causes interrupts to be created on a separate
+		stack instead of nesting the interrupts on the kernel stack.
+		
+config IRQSTACKS_USEOCM
+	bool "Use OCM for interrupt stacks"
+	default n
+	depends on IRQSTACKS
+	help
+		Selecting this cause the interrupt stacks to be placed in OCM
+		reducing cache misses at the expense of using the OCM for servicing
+		interrupts.
+
+menu "OCM Instruction Heap"
+
+config OCM_MODULES_RESERVATION
+	int "OCM Instruction heap reservation. 0-192 kB"
+	range 0 192
+	default "0"
+	help
+	  The minimum amount of OCM memory to reserve for kernel loadable module
+	  code. If you are not using this memory it cannot be used for anything
+	  else. Leave it as 0 if you have prebuilt modules that are compiled with
+	  OCM support.
+
+config OCM_MODULES_MAY_CONSUME_REMAINING_CODESPACE
+	bool "Give all unused ocm code space to the ocm instruction heap."
+	default n
+	help
+	  Allow the OCM instruction heap allocation to consume any remaining
+	  unused OCM code space.  The result of this is that you will not have
+	  and deterministic results, but you will not have any waste either.
+
+config OCM_MODULES_FALLBACK_TO_DDR
+	bool "Loadable Modules requiring OCM may fallback to use DDR."
+	default n
+	help
+	  If a module cannot get the OCM code it requires allow DDR to
+	  be used instead.
+endmenu
+
+config HZ
+	int "Frequency of 'jiffies' (for polling)"
+	default 1000
+	help
+		100 is common for embedded systems, but 1000 allows
+		you to do more drivers without actually having
+		interrupts working properly.
+
+comment "RAM configuration"
+
+if BRD_32MB
+
+config RAMSIZE
+	hex "Size of RAM (in bytes)"
+	range 0x00000000 0x02000000
+	default "0x02000000"
+	help
+		Define the size of the system RAM. If you select 0 then the
+		kernel will try to probe the RAM size at runtime. This is not
+		supported on all CPU types.
+
+endif
+
+if BRD_64MB
+
+config RAMSIZE
+	hex "Size of RAM (in bytes)"
+	range 0x00000000 0x04000000
+	default "0x04000000"
+	help
+		Define the size of the system RAM. If you select 0 then the
+		kernel will try to probe the RAM size at runtime. This is not
+		supported on all CPU types.
+
+endif
+
+if BRD_128MB
+
+config RAMSIZE
+	hex "Size of RAM (in bytes)"
+	range 0x00000000 0x08000000
+	default "0x08000000"
+	help
+		Define the size of the system RAM. If you select 0 then the
+		kernel will try to probe the RAM size at runtime. This is not
+		supported on all CPU types.
+
+endif
+
+config KERNELBASE
+	hex "Address of the base of kernel code"
+	default "0x40400000"
+	help
+		For the time being we are going to start the Kernel at a 4 meg offset.
+
+comment "Build options"
+config LINKER_RELAXATION
+	bool "Linker Relaxation"
+	default y
+	help
+	  Turns on linker relaxation that will produce smaller
+	  faster code. Increases link time.
+
+comment "Driver options"
+menu "PCI Bus"
+config PCI
+	bool "PCI bus"
+	default true
+	help
+	  Enable/Disable PCI bus
+	source "drivers/pci/Kconfig"
+
+
+config PCI_DEV0_IDSEL
+	hex "slot 0 address"
+	depends on PCI
+	default "0x01000000"
+	help
+	  Slot 0 address.  This address should correspond to the address line
+	  which the IDSEL bit for this slot is connected to.
+
+config PCI_DEV1_IDSEL
+	hex "slot 1 address"
+	depends on PCI
+	default "0x02000000"
+	help
+	  Slot 1 address.  This address should correspond to the address line
+	  which the IDSEL bit for this slot is connected to.
+endmenu
+# End PCI
+
+menu "Input devices"
+config UBICOM_INPUT
+	bool "Ubicom polled GPIO input driver"
+	select INPUT
+	select INPUT_POLLDEV
+	help
+		Polling input driver, much like the GPIO input driver, except that it doesn't
+		rely on interrupts.  It will report events via the input subsystem.
+	default n
+
+config UBICOM_INPUT_I2C
+	bool "Ubicom polled GPIO input driver over I2C"
+	select INPUT
+	select INPUT_POLLDEV
+	help
+		Polling input driver, much like the PCA953x driver, it can support a variety of
+		different I2C I/O expanders.  This device polls the I2C I/O expander for events
+		and reports them via the input subsystem.
+	default n
+endmenu
+# Input devices
+
+
+
+menu "Misc devices"
+config UBICOM_HID
+	bool "Ubicom HID driver"
+	select INPUT
+	select INPUT_POLLDEV
+	select LCD_CLASS_DEVICE
+	help
+		Driver for HID chip found on some Ubicom reference designs.  This chip handles
+		PWM, button input, and IR remote control.  It registers as an input device and
+		a backlight device.
+	default n
+endmenu
+# Misc devices
+
+config CMDLINE_BOOL
+	bool "Built-in kernel command line"
+	default n
+	help
+	  Allow for specifying boot arguments to the kernel at
+	  build time.  On some systems (e.g. embedded ones), it is
+	  necessary or convenient to provide some or all of the
+	  kernel boot arguments with the kernel itself (that is,
+	  to not rely on the boot loader to provide them.)
+
+	  To compile command line arguments into the kernel,
+	  set this option to 'Y', then fill in the
+	  the boot arguments in CONFIG_CMDLINE.
+
+	  Systems with fully functional boot loaders (i.e. non-embedded)
+	  should leave this option set to 'N'.
+
+config CMDLINE
+	string "Built-in kernel command string"
+	depends on CMDLINE_BOOL
+	default ""
+	help
+	  Enter arguments here that should be compiled into the kernel
+	  image and used at boot time.  If the boot loader provides a
+	  command line at boot time, it is appended to this string to
+	  form the full kernel command line, when the system boots.
+
+	  However, you can use the CONFIG_CMDLINE_OVERRIDE option to
+	  change this behavior.
+
+	  In most cases, the command line (whether built-in or provided
+	  by the boot loader) should specify the device for the root
+	  file system.
+
+config CMDLINE_OVERRIDE
+	bool "Built-in command line overrides boot loader arguments"
+	default n
+	depends on CMDLINE_BOOL
+	help
+	  Set this option to 'Y' to have the kernel ignore the boot loader
+	  command line, and use ONLY the built-in command line.
+
+	  This is used to work around broken boot loaders.  This should
+	  be set to 'N' under normal conditions.
+
+endmenu
+# End Processor type and features
+
+source "arch/ubicom32/Kconfig.debug"
+
+menu "Executable file formats"
+source "fs/Kconfig.binfmt"
+endmenu
+
+source "init/Kconfig"
+source "kernel/Kconfig.preempt"
+source "kernel/time/Kconfig"
+source "mm/Kconfig"
+source "net/Kconfig"
+source "drivers/Kconfig"
+source "fs/Kconfig"
+source "security/Kconfig"
+source "crypto/Kconfig"
+source "lib/Kconfig"
diff -ruN linux-2.6.28.10_o/arch/ubicom32/Kconfig.debug linux-2.6.28.10/arch/ubicom32/Kconfig.debug
--- linux-2.6.28.10_o/arch/ubicom32/Kconfig.debug	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/Kconfig.debug	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,117 @@
+menu "Kernel hacking"
+
+config TRACE_IRQFLAGS_SUPPORT
+	def_bool y
+	
+config PROTECT_KERNEL
+	default y
+	bool 'Enable Kernel range register Protection'
+	help
+	  Adds code to enable/disable range registers to protect static
+	  kernel code/data from userspace.  Currently the ranges covered
+	  do no protect kernel loadable modules or dynamically allocated
+	  kernel data.
+
+config NO_KERNEL_MSG
+	bool "Suppress Kernel BUG Messages"
+	help
+	  Do not output any debug BUG messages within the kernel.
+
+config EARLY_PRINTK
+	bool "Use the driver that you selected as console also for early printk (to debug kernel bootup)."
+	default n
+	help
+	  If you want to use the serdes driver (console=ttyUS0) for
+	  early printk, you must also supply an additional kernel boot
+	  parameter like this:
+
+		serdes=ioportaddr,irq,clockrate,baud
+
+	  For an IP7160RGW eval board, you could use this:
+
+		serdes=0x2004000,61,250000000,57600
+
+	  which will let you see early printk output at 57600 baud.
+
+config STOP_ON_TRAP
+	bool "Enable stopping at the LDSR for all traps"
+	default n
+	help
+	Cause the LDSR to stop all threads whenever a trap is about to be serviced
+	
+config STOP_ON_BUG
+	bool "Enable stopping on failed BUG_ON()"
+	default n
+	help
+	Cause all BUG_ON failures to stop all threads
+	
+config DEBUG_IRQMEASURE
+	bool "Enable IRQ handler measurements"
+	default n
+	help
+	When enabled each IRQ's min/avg/max times will be printed.  If the handler
+	re-enables interrupt, the times will show the full time including to service
+	nested interrupts.  See /proc/irq_measurements.
+	
+config DEBUG_PCIMEASURE
+	bool "Enable PCI transaction measurements"
+	default n
+	help
+	When enabled the system will measure the min/avg/max timer for each PCI transactions.
+	See /proc/pci_measurements.
+
+config ACCESS_OK_CHECKS_ENABLED
+	bool "Enable user space access checks"
+	default n
+	help
+	Enabling this check causes the kernel to verify that addresses passed
+	to the kernel by the user space code are within the processes 
+	address space.  On a no-mmu system, this is done by examining the
+	processes memory data structures (adversly affecting performance) but
+	ensuring that a process does not ask the kernel to violate another 
+	processes address space.  Sadly, the kernel uses access_ok() for 
+	address that are in the kernel which results in a large volume of 
+	false positives.
+
+choice
+	prompt "Unaligned Access Support"
+	default UNALIGNED_ACCESS_ENABLED
+	help
+		Kernel / Userspace unaligned access handling.
+
+config  UNALIGNED_ACCESS_ENABLED
+	bool "Kernel and Userspace"
+	help
+
+config  UNALIGNED_ACCESS_USERSPACE_ONLY
+	bool "Userspace Only"
+	help
+
+config  UNALIGNED_ACCESS_DISABLED
+	bool "Disabled"
+	help
+
+endchoice
+
+config DEBUG_STACKOVERFLOW
+	bool "Check for stack overflows"
+	default n
+	depends on DEBUG_KERNEL
+	help
+	  This option will cause messages to be printed if free kernel stack space
+	  drops below a certain limit (THREAD_SIZE /8).
+
+config DEBUG_STACK_USAGE
+	bool "Stack utilization instrumentation"
+	default n
+	depends on DEBUG_KERNEL
+	help
+	  Enables the display of the minimum amount of free kernel stack which each
+	  task has ever had available in the sysrq-T and sysrq-P debug output.
+
+	  This option will slow down process creation somewhat.
+
+source "lib/Kconfig.debug"
+
+endmenu
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/kernel/asm-offsets.c linux-2.6.28.10/arch/ubicom32/kernel/asm-offsets.c
--- linux-2.6.28.10_o/arch/ubicom32/kernel/asm-offsets.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/kernel/asm-offsets.c	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,162 @@
+/*
+ * arch/ubicom32/kernel/asm-offsets.c
+ *   Ubicom32 architecture definitions needed by assembly language modules.
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+/*
+ * This program is used to generate definitions needed by
+ * assembly language modules.
+ *
+ * We use the technique used in the OSF Mach kernel code:
+ * generate asm statements containing #defines,
+ * compile this file to assembler, and then extract the
+ * #defines from the assembly-language output.
+ */
+
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <linux/ptrace.h>
+#include <linux/hardirq.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/thread_info.h>
+
+#define DEFINE(sym, val) \
+        asm volatile("\n->" #sym " %0 " #val : : "i" (val))
+
+#define BLANK() asm volatile("\n->" : : )
+
+int main(void)
+{
+	/* offsets into the task struct */
+	DEFINE(TASK_STATE, offsetof(struct task_struct, state));
+	DEFINE(TASK_FLAGS, offsetof(struct task_struct, flags));
+	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
+	DEFINE(TASK_BLOCKED, offsetof(struct task_struct, blocked));
+	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
+	DEFINE(TASK_THREAD_INFO, offsetof(struct task_struct, stack));
+	DEFINE(TASK_MM, offsetof(struct task_struct, mm));
+	DEFINE(TASK_ACTIVE_MM, offsetof(struct task_struct, active_mm));
+
+	/* offsets into the kernel_stat struct */
+	DEFINE(STAT_IRQ, offsetof(struct kernel_stat, irqs));
+
+	/* offsets into the irq_cpustat_t struct */
+	DEFINE(CPUSTAT_SOFTIRQ_PENDING, offsetof(irq_cpustat_t, __softirq_pending));
+
+	/* offsets into the thread struct */
+	DEFINE(THREAD_D10, offsetof(struct thread_struct, d10));
+	DEFINE(THREAD_D11, offsetof(struct thread_struct, d11));
+	DEFINE(THREAD_D12, offsetof(struct thread_struct, d12));
+	DEFINE(THREAD_D13, offsetof(struct thread_struct, d13));
+	DEFINE(THREAD_A1, offsetof(struct thread_struct, a1));
+	DEFINE(THREAD_A2, offsetof(struct thread_struct, a2));
+	DEFINE(THREAD_A5, offsetof(struct thread_struct, a5));
+	DEFINE(THREAD_A6, offsetof(struct thread_struct, a6));
+	DEFINE(THREAD_SP, offsetof(struct thread_struct, sp));
+
+	/* offsets into the pt_regs */
+	DEFINE(PT_D0, offsetof(struct pt_regs, dn[0]));
+	DEFINE(PT_D1, offsetof(struct pt_regs, dn[1]));
+	DEFINE(PT_D2, offsetof(struct pt_regs, dn[2]));
+	DEFINE(PT_D3, offsetof(struct pt_regs, dn[3]));
+	DEFINE(PT_D4, offsetof(struct pt_regs, dn[4]));
+	DEFINE(PT_D5, offsetof(struct pt_regs, dn[5]));
+	DEFINE(PT_D6, offsetof(struct pt_regs, dn[6]));
+	DEFINE(PT_D7, offsetof(struct pt_regs, dn[7]));
+	DEFINE(PT_D8, offsetof(struct pt_regs, dn[8]));
+	DEFINE(PT_D9, offsetof(struct pt_regs, dn[9]));
+	DEFINE(PT_D10, offsetof(struct pt_regs, dn[10]));
+	DEFINE(PT_D11, offsetof(struct pt_regs, dn[11]));
+	DEFINE(PT_D12, offsetof(struct pt_regs, dn[12]));
+	DEFINE(PT_D13, offsetof(struct pt_regs, dn[13]));
+	DEFINE(PT_D14, offsetof(struct pt_regs, dn[14]));
+	DEFINE(PT_D15, offsetof(struct pt_regs, dn[15]));
+	DEFINE(PT_A0, offsetof(struct pt_regs, an[0]));
+	DEFINE(PT_A1, offsetof(struct pt_regs, an[1]));
+	DEFINE(PT_A2, offsetof(struct pt_regs, an[2]));
+	DEFINE(PT_A3, offsetof(struct pt_regs, an[3]));
+	DEFINE(PT_A4, offsetof(struct pt_regs, an[4]));
+	DEFINE(PT_A5, offsetof(struct pt_regs, an[5]));
+	DEFINE(PT_A6, offsetof(struct pt_regs, an[6]));
+	DEFINE(PT_A7, offsetof(struct pt_regs, an[7]));
+	DEFINE(PT_SP, offsetof(struct pt_regs, an[7]));
+
+	DEFINE(PT_ACC0HI, offsetof(struct pt_regs, acc0[0]));
+	DEFINE(PT_ACC0LO, offsetof(struct pt_regs, acc0[1]));
+	DEFINE(PT_MAC_RC16, offsetof(struct pt_regs, mac_rc16));
+
+	DEFINE(PT_ACC1HI, offsetof(struct pt_regs, acc1[0]));
+	DEFINE(PT_ACC1LO, offsetof(struct pt_regs, acc1[1]));
+
+	DEFINE(PT_SOURCE3, offsetof(struct pt_regs, source3));
+	DEFINE(PT_INST_CNT, offsetof(struct pt_regs, inst_cnt));
+	DEFINE(PT_CSR, offsetof(struct pt_regs, csr));
+	DEFINE(PT_DUMMY_UNUSED, offsetof(struct pt_regs, dummy_unused));
+
+	DEFINE(PT_INT_MASK0, offsetof(struct pt_regs, int_mask0));
+	DEFINE(PT_INT_MASK1, offsetof(struct pt_regs, int_mask1));
+
+	DEFINE(PT_PC, offsetof(struct pt_regs, pc));
+
+	DEFINE(PT_TRAP_CAUSE, offsetof(struct pt_regs, trap_cause));
+
+	DEFINE(PT_SIZE, sizeof(struct pt_regs));
+
+	DEFINE(PT_FRAME_TYPE, offsetof(struct pt_regs, frame_type));
+
+	DEFINE(PT_ORIGINAL_D0, offsetof(struct pt_regs, original_dn_0));
+	DEFINE(PT_PREVIOUS_PC, offsetof(struct pt_regs, previous_pc));
+
+	/* offsets into the kernel_stat struct */
+	DEFINE(STAT_IRQ, offsetof(struct kernel_stat, irqs));
+
+	/* signal defines */
+	DEFINE(SIGSEGV, SIGSEGV);
+	//DEFINE(SEGV_MAPERR, SEGV_MAPERR);
+	DEFINE(SIGTRAP, SIGTRAP);
+	//DEFINE(TRAP_TRACE, TRAP_TRACE);
+
+	DEFINE(PT_PTRACED, PT_PTRACED);
+	DEFINE(PT_DTRACE, PT_DTRACE);
+
+	DEFINE(ASM_THREAD_SIZE, THREAD_SIZE);
+
+	/* Offsets in thread_info structure */
+	DEFINE(TI_TASK, offsetof(struct thread_info, task));
+	DEFINE(TI_EXECDOMAIN, offsetof(struct thread_info, exec_domain));
+	DEFINE(TI_FLAGS, offsetof(struct thread_info, flags));
+	DEFINE(TI_PREEMPTCOUNT, offsetof(struct thread_info, preempt_count));
+	DEFINE(TI_CPU, offsetof(struct thread_info, cpu));
+	DEFINE(TI_INTR_NESTING, offsetof(struct thread_info, interrupt_nesting));
+	DEFINE(ASM_TIF_NEED_RESCHED, TIF_NEED_RESCHED);
+	DEFINE(ASM_TIF_SYSCALL_TRACE, TIF_SYSCALL_TRACE);
+	DEFINE(ASM_TIF_SIGPENDING, TIF_SIGPENDING);
+
+	DEFINE(ASM_RAM_END, (CONFIG_RAMBASE + CONFIG_RAMSIZE));
+	return 0;
+}
diff -ruN linux-2.6.28.10_o/arch/ubicom32/kernel/Makefile linux-2.6.28.10/arch/ubicom32/kernel/Makefile
--- linux-2.6.28.10_o/arch/ubicom32/kernel/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/kernel/Makefile	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,64 @@
+#
+# arch/ubicom32/kernel/Makefile
+#	Main Makefile for the Ubicom32 arch directory.
+#
+# (C) Copyright 2009, Ubicom, Inc.
+#
+# This file is part of the Ubicom32 Linux Kernel Port.
+#
+# The Ubicom32 Linux Kernel Port is free software: you can redistribute
+# it and/or modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation, either version 2 of the
+# License, or (at your option) any later version.
+#
+# The Ubicom32 Linux Kernel Port is distributed in the hope that it
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied
+# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with the Ubicom32 Linux Kernel Port.  If not, 
+# see <http://www.gnu.org/licenses/>.
+#
+# Ubicom32 implementation derived from (with many thanks):
+#   arch/m68knommu
+#   arch/blackfin
+#   arch/parisc
+#
+
+extra-y := head.o vmlinux.lds
+
+obj-y += \
+	devtree.o \
+	dma.o \
+	flat.o \
+	init_task.o \
+	irq.o \
+	ldsr.o \
+	os_node.o \
+	process.o \
+	processor.o \
+	ptrace.o \
+	setup.o \
+	signal.o \
+	stacktrace.o \
+	sys_ubicom32.o \
+	syscalltable.o \
+	thread.o \
+	time.o \
+	traps.o \
+	ubicom32_context_switch.o \
+	ubicom32_ksyms.o \
+	ubicom32_syscall.o \
+	unaligned_trap.o
+
+obj-$(CONFIG_MODULES)				+= module.o
+obj-$(CONFIG_COMEMPCI)				+= comempci.o
+obj-$(CONFIG_SMP)				+= smp.o topology.o
+obj-$(CONFIG_ACCESS_OK_CHECKS_ENABLED)		+= uaccess.o
+obj-$(CONFIG_GENERIC_CLOCKEVENTS)		+= timer_device.o
+obj-$(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)	+= timer_broadcast.o
+
+ifndef CONFIG_GENERIC_CLOCKEVENTS
+obj-y			+= timer_tick.o
+endif
diff -ruN linux-2.6.28.10_o/arch/ubicom32/kernel/syscalltable.S linux-2.6.28.10/arch/ubicom32/kernel/syscalltable.S
--- linux-2.6.28.10_o/arch/ubicom32/kernel/syscalltable.S	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/kernel/syscalltable.S	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,377 @@
+/*
+ * arch/ubicom32/kernel/syscalltable.S
+ *	<TODO: Replace with short file description>
+ *
+ * (C) Copyright 2009, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Linux Kernel Port.
+ *
+ * The Ubicom32 Linux Kernel Port is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Ubicom32 Linux Kernel Port is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Ubicom32 Linux Kernel Port.  If not, 
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   arch/m68knommu
+ *   arch/blackfin
+ *   arch/parisc
+ */
+/*
+ *
+ *  Copyright (C) 2002, Greg Ungerer (gerg@snapgear.com)
+ *  Copyright (C) 1998  D. Jeff Dionne <jeff@lineo.ca>, Kenneth Albanowski <kjahds@kjahds.com>,
+ *  Copyright (C) 2000  Lineo Inc. (www.lineo.com) 
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <linux/sys.h>
+#include <linux/linkage.h>
+#include <asm/unistd.h>
+
+.text
+ALIGN
+	.global sys_call_table
+sys_call_table:	
+	.long sys_ni_syscall	/* 0  -  old "setup()" system call*/
+	.long sys_exit
+	.long sys_fork
+	.long sys_read
+	.long sys_write
+	.long sys_open		/* 5 */
+	.long sys_close
+	.long sys_waitpid
+	.long sys_creat
+	.long sys_link
+	.long sys_unlink	/* 10 */
+	.long execve_intercept
+	.long sys_chdir
+	.long sys_time
+	.long sys_mknod
+	.long sys_chmod		/* 15 */
+	.long sys_chown16
+	.long sys_ni_syscall	/* old break syscall holder */
+	.long sys_stat
+	.long sys_lseek
+	.long sys_getpid	/* 20 */
+	.long sys_mount
+	.long sys_oldumount
+	.long sys_setuid16
+	.long sys_getuid16
+	.long sys_stime		/* 25 */
+	.long sys_ptrace
+	.long sys_alarm
+	.long sys_fstat
+	.long sys_pause
+	.long sys_utime		/* 30 */
+	.long sys_ni_syscall	/* old stty syscall holder */
+	.long sys_ni_syscall	/* old gtty syscall holder */
+	.long sys_access
+	.long sys_nice
+	.long sys_ni_syscall	/* 35 */ /* old ftime syscall holder */
+	.long sys_sync
+	.long sys_kill
+	.long sys_rename
+	.long sys_mkdir
+	.long sys_rmdir		/* 40 */
+	.long sys_dup
+	.long sys_pipe
+	.long sys_times
+	.long sys_ni_syscall	/* old prof syscall holder */
+	.long sys_brk		/* 45 */
+	.long sys_setgid16
+	.long sys_getgid16
+	.long sys_signal
+	.long sys_geteuid16
+	.long sys_getegid16	/* 50 */
+	.long sys_acct
+	.long sys_umount	/* recycled never used phys() */
+	.long sys_ni_syscall	/* old lock syscall holder */
+	.long sys_ioctl
+	.long sys_fcntl		/* 55 */
+	.long sys_ni_syscall	/* old mpx syscall holder */
+	.long sys_setpgid
+	.long sys_ni_syscall	/* old ulimit syscall holder */
+	.long sys_ni_syscall
+	.long sys_umask		/* 60 */
+	.long sys_chroot
+	.long sys_ustat
+	.long sys_dup2
+	.long sys_getppid
+	.long sys_getpgrp	/* 65 */
+	.long sys_setsid
+	.long sys_sigaction
+	.long sys_sgetmask
+	.long sys_ssetmask
+	.long sys_setreuid16	/* 70 */
+	.long sys_setregid16
+	.long sys_sigsuspend
+	.long sys_sigpending
+	.long sys_sethostname
+	.long sys_setrlimit	/* 75 */
+	.long sys_old_getrlimit
+	.long sys_getrusage
+	.long sys_gettimeofday
+	.long sys_settimeofday
+	.long sys_getgroups16	/* 80 */
+	.long sys_setgroups16
+	.long old_select
+	.long sys_symlink
+	.long sys_lstat
+	.long sys_readlink	/* 85 */
+	.long sys_uselib
+	.long sys_ni_syscall	/* _sys_swapon */
+	.long sys_reboot
+	.long sys_old_readdir
+	.long old_mmap		/* 90 */
+	.long sys_munmap
+	.long sys_truncate
+	.long sys_ftruncate
+	.long sys_fchmod
+	.long sys_fchown16	/* 95 */
+	.long sys_getpriority
+	.long sys_setpriority
+	.long sys_ni_syscall	/* old profil syscall holder */
+	.long sys_statfs
+	.long sys_fstatfs	/* 100 */
+	.long sys_ni_syscall	/* ioperm for i386 */
+	.long sys_socketcall
+	.long sys_syslog
+	.long sys_setitimer
+	.long sys_getitimer	/* 105 */
+	.long sys_newstat
+	.long sys_newlstat
+	.long sys_newfstat
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* iopl for i386 */ /* 110 */
+	.long sys_vhangup
+	.long sys_ni_syscall	/* obsolete idle() syscall */
+	.long sys_ni_syscall	/* vm86old for i386 */
+	.long sys_wait4
+	.long sys_ni_syscall	/* 115 */ /* _sys_swapoff */
+	.long sys_sysinfo
+	.long sys_ipc
+	.long sys_fsync
+	.long sys_sigreturn
+	.long clone_intercept	/* 120 */
+	.long sys_setdomainname
+	.long sys_newuname
+	.long sys_cacheflush	/* modify_ldt for i386 */
+	.long sys_adjtimex
+	.long sys_ni_syscall	/* 125 */ /* _sys_mprotect */
+	.long sys_sigprocmask
+	.long sys_ni_syscall	/* old "creat_module" */
+	.long sys_init_module
+	.long sys_delete_module
+	.long sys_ni_syscall	/* 130: old "get_kernel_syms" */
+	.long sys_quotactl
+	.long sys_getpgid
+	.long sys_fchdir
+	.long sys_bdflush
+	.long sys_sysfs		/* 135 */
+	.long sys_personality
+	.long sys_ni_syscall	/* for afs_syscall */
+	.long sys_setfsuid16
+	.long sys_setfsgid16
+	.long sys_llseek	/* 140 */
+	.long sys_getdents
+	.long sys_select
+	.long sys_flock
+	.long sys_ni_syscall	/* _sys_msync */
+	.long sys_readv		/* 145 */
+	.long sys_writev
+	.long sys_getsid
+	.long sys_fdatasync
+	.long sys_sysctl
+	.long sys_ni_syscall	/* 150 */ /* _sys_mlock */
+	.long sys_ni_syscall	/* _sys_munlock */
+	.long sys_ni_syscall	/* _sys_mlockall */
+	.long sys_ni_syscall	/* _sys_munlockall */
+	.long sys_sched_setparam
+	.long sys_sched_getparam /* 155 */
+	.long sys_sched_setscheduler
+	.long sys_sched_getscheduler
+	.long sys_sched_yield
+	.long sys_sched_get_priority_max
+	.long sys_sched_get_priority_min  /* 160 */
+	.long sys_sched_rr_get_interval
+	.long sys_nanosleep
+	.long sys_ni_syscall	/* _sys_mremap */
+	.long sys_setresuid16
+	.long sys_getresuid16	/* 165 */
+	.long sys_getpagesize	/* _sys_getpagesize */
+	.long sys_ni_syscall	/* old "query_module" */
+	.long sys_poll
+	.long sys_ni_syscall	/* _sys_nfsservctl */
+	.long sys_setresgid16	/* 170 */
+	.long sys_getresgid16
+	.long sys_prctl
+	.long sys_rt_sigreturn
+	.long sys_rt_sigaction
+	.long sys_rt_sigprocmask /* 175 */
+	.long sys_rt_sigpending
+	.long sys_rt_sigtimedwait
+	.long sys_rt_sigqueueinfo
+	.long sys_rt_sigsuspend
+	.long sys_pread64	/* 180 */
+	.long sys_pwrite64
+	.long sys_lchown16
+	.long sys_getcwd
+	.long sys_capget
+	.long sys_capset	/* 185 */
+	.long sys_sigaltstack
+	.long sys_sendfile
+	.long sys_ni_syscall	/* streams1 */
+	.long sys_ni_syscall	/* streams2 */
+	.long vfork_intercept		/* 190 */
+	.long sys_getrlimit
+	.long sys_mmap2
+	.long sys_truncate64
+	.long sys_ftruncate64
+	.long sys_stat64	/* 195 */
+	.long sys_lstat64
+	.long sys_fstat64
+	.long sys_chown
+	.long sys_getuid
+	.long sys_getgid	/* 200 */
+	.long sys_geteuid
+	.long sys_getegid
+	.long sys_setreuid
+	.long sys_setregid
+	.long sys_getgroups	/* 205 */
+	.long sys_setgroups
+	.long sys_fchown
+	.long sys_setresuid
+	.long sys_getresuid
+	.long sys_setresgid	/* 210 */
+	.long sys_getresgid
+	.long sys_lchown
+	.long sys_setuid
+	.long sys_setgid
+	.long sys_setfsuid	/* 215 */
+	.long sys_setfsgid
+	.long sys_pivot_root
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_getdents64	/* 220 */
+	.long sys_gettid
+	.long sys_tkill
+	.long sys_setxattr
+	.long sys_lsetxattr
+	.long sys_fsetxattr	/* 225 */
+	.long sys_getxattr
+	.long sys_lgetxattr
+	.long sys_fgetxattr
+	.long sys_listxattr
+	.long sys_llistxattr	/* 230 */
+	.long sys_flistxattr
+	.long sys_removexattr
+	.long sys_lremovexattr
+	.long sys_fremovexattr
+	.long sys_futex		/* 235 */
+	.long sys_sendfile64
+	.long sys_ni_syscall	/* _sys_mincore */
+	.long sys_ni_syscall	/* _sys_madvise */
+	.long sys_fcntl64
+	.long sys_readahead	/* 240 */
+	.long sys_io_setup
+	.long sys_io_destroy
+	.long sys_io_getevents
+	.long sys_io_submit
+	.long sys_io_cancel	/* 245 */
+	.long sys_fadvise64
+	.long sys_exit_group
+	.long sys_lookup_dcookie
+	.long sys_epoll_create
+	.long sys_epoll_ctl	/* 250 */
+	.long sys_epoll_wait
+	.long sys_ni_syscall	/* _sys_remap_file_pages */
+	.long sys_set_tid_address
+	.long sys_timer_create
+	.long sys_timer_settime	/* 255 */
+	.long sys_timer_gettime
+	.long sys_timer_getoverrun
+	.long sys_timer_delete
+	.long sys_clock_settime
+	.long sys_clock_gettime	/* 260 */
+	.long sys_clock_getres
+	.long sys_clock_nanosleep
+	.long sys_statfs64
+	.long sys_fstatfs64
+	.long sys_tgkill	/* 265 */
+	.long sys_utimes
+	.long sys_fadvise64_64
+	.long sys_mbind	
+	.long sys_get_mempolicy
+	.long sys_set_mempolicy	/* 270 */
+	.long sys_mq_open
+	.long sys_mq_unlink
+	.long sys_mq_timedsend
+	.long sys_mq_timedreceive
+	.long sys_mq_notify	/* 275 */
+	.long sys_mq_getsetattr
+	.long sys_waitid
+	.long sys_ni_syscall	/* for _sys_vserver */
+	.long sys_add_key
+	.long sys_request_key	/* 280 */
+	.long sys_keyctl
+	.long sys_ioprio_set
+	.long sys_ioprio_get
+	.long sys_inotify_init
+	.long sys_inotify_add_watch	/* 285 */
+	.long sys_inotify_rm_watch
+	.long sys_migrate_pages
+	.long sys_openat
+	.long sys_mkdirat
+	.long sys_mknodat		/* 290 */
+	.long sys_fchownat
+	.long sys_futimesat
+	.long sys_fstatat64
+	.long sys_unlinkat
+	.long sys_renameat		/* 295 */
+	.long sys_linkat
+	.long sys_symlinkat
+	.long sys_readlinkat
+	.long sys_fchmodat
+	.long sys_faccessat		/* 300 */
+	.long sys_ni_syscall		/* Reserved for pselect6 */
+	.long sys_ni_syscall		/* Reserved for ppoll */
+	.long sys_unshare
+	.long sys_set_robust_list
+	.long sys_get_robust_list	/* 305 */
+	.long sys_splice
+	.long sys_sync_file_range
+	.long sys_tee
+	.long sys_vmsplice
+	.long sys_move_pages		/* 310 */
+	.long sys_sched_setaffinity
+	.long sys_sched_getaffinity
+	.long sys_kexec_load
+	.long sys_getcpu
+	.long sys_epoll_pwait		/* 315 */
+	.long sys_utimensat
+	.long sys_signalfd
+	.long sys_timerfd_create
+	.long sys_eventfd
+	.long sys_fallocate		/* 320 */
+	.long sys_timerfd_settime
+	.long sys_timerfd_gettime
+	.long sys_ni_syscall		/* sys_signalfd4 */
+	.long sys_ni_syscall		/* sys_eventfd2 */
+	.long sys_ni_syscall		/* sys_epoll_create1 */
+					/* 325 */
+	.long sys_ni_syscall		/* sys_dup3 */
+	.long sys_ni_syscall		/* sys_pipe2 */
+	.long sys_ni_syscall		/* sys_inotify_init1 */
+	.rept NR_syscalls-(.-sys_call_table)/4
+		.long sys_ni_syscall
+	.endr
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/lib/Makefile linux-2.6.28.10/arch/ubicom32/lib/Makefile
--- linux-2.6.28.10_o/arch/ubicom32/lib/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/lib/Makefile	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,32 @@
+#
+# arch/ubicom32/lib/Makefile
+#	<TODO: Replace with short file description>
+#
+# (C) Copyright 2009, Ubicom, Inc.
+#
+# This file is part of the Ubicom32 Linux Kernel Port.
+#
+# The Ubicom32 Linux Kernel Port is free software: you can redistribute
+# it and/or modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation, either version 2 of the
+# License, or (at your option) any later version.
+#
+# The Ubicom32 Linux Kernel Port is distributed in the hope that it
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied
+# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with the Ubicom32 Linux Kernel Port.  If not, 
+# see <http://www.gnu.org/licenses/>.
+#
+# Ubicom32 implementation derived from (with many thanks):
+#   arch/m68knommu
+#   arch/blackfin
+#   arch/parisc
+#
+#
+# Makefile for m68knommu specific library files..
+#
+
+lib-y	:= checksum.o delay.o mem_ubicom32.o
diff -ruN linux-2.6.28.10_o/arch/ubicom32/mach-common/Makefile linux-2.6.28.10/arch/ubicom32/mach-common/Makefile
--- linux-2.6.28.10_o/arch/ubicom32/mach-common/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/mach-common/Makefile	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,40 @@
+#
+# arch/ubicom32/mach-common/Makefile
+#	Makefile for Ubicom32 generic drivers/code.
+#
+# (C) Copyright 2009, Ubicom, Inc.
+#
+# This file is part of the Ubicom32 Linux Kernel Port.
+#
+# The Ubicom32 Linux Kernel Port is free software: you can redistribute
+# it and/or modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation, either version 2 of the
+# License, or (at your option) any later version.
+#
+# The Ubicom32 Linux Kernel Port is distributed in the hope that it
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied
+# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with the Ubicom32 Linux Kernel Port.  If not, 
+# see <http://www.gnu.org/licenses/>.
+#
+# Ubicom32 implementation derived from (with many thanks):
+#   arch/m68knommu
+#   arch/blackfin
+#   arch/parisc
+#
+
+obj-y += cachectl.o common.o usb_tio.o usb.o ubi32-gpio.o board.o bootargs.o
+obj-$(CONFIG_PCI) += pci.o io.o
+
+obj-$(CONFIG_FB_UBICOM32) += vdc_tio.o
+obj-$(CONFIG_UBICOM_HID) += ubicom32hid.o
+obj-$(CONFIG_UBICOM_INPUT) += ubicom32input.o
+obj-$(CONFIG_UBICOM_INPUT_I2C) += ubicom32input_i2c.o
+obj-$(CONFIG_UBICOM_SWITCH) += switch-core.o
+obj-$(CONFIG_UBICOM_SWITCH_BCM539X) += switch-bcm539x.o
+obj-$(CONFIG_UIO_UBICOM32RING) += ring_tio.o
+obj-$(CONFIG_SND_UBI32) += audio_tio.o
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/mach-ip5k/Kconfig linux-2.6.28.10/arch/ubicom32/mach-ip5k/Kconfig
--- linux-2.6.28.10_o/arch/ubicom32/mach-ip5k/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/mach-ip5k/Kconfig	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,32 @@
+
+config IP5170DPF
+	bool "IP5170DPF"
+	select UBICOM32_V3
+	select I2C
+	select I2C_GPIO
+	select FB
+	select FB_UBICOM32
+	select BACKLIGHT_LCD_SUPPORT
+	select BACKLIGHT_CLASS_DEVICE
+	select UBICOM_HID
+	select NEW_LEDS
+	select LEDS_CLASS
+	select LEDS_GPIO
+	select BRD_64MB
+	help
+		IP5170 Digital Picture Frame board, 8005-1113, IP5K-BEV-0011-13 v1.3
+
+config IP5160DEV
+	bool "IP5160Dev_Ver1Dot1"
+	select UBICOM32_V3
+	select BRD_64MB
+	help
+		Ubicom StreamEngine 5000 Development Board, IP5K-BDV-0004-11 v1.1
+
+config IP5160EVAL
+	bool "IP5160RGWEval_Ver2Rev2"
+	select UBICOM32_V3
+	select BRD_32MB
+	help
+		Ubicom StreamEngine 5000 RGW Evaluation Board, IP5K-RGW-0004-11 v2.2
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/mach-ip5k/Makefile linux-2.6.28.10/arch/ubicom32/mach-ip5k/Makefile
--- linux-2.6.28.10_o/arch/ubicom32/mach-ip5k/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/mach-ip5k/Makefile	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,32 @@
+#
+# arch/ubicom32/mach-ip5k/Makefile
+#	Makefile for boards which have an ip5k on them.
+#
+# (C) Copyright 2009, Ubicom, Inc.
+#
+# This file is part of the Ubicom32 Linux Kernel Port.
+#
+# The Ubicom32 Linux Kernel Port is free software: you can redistribute
+# it and/or modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation, either version 2 of the
+# License, or (at your option) any later version.
+#
+# The Ubicom32 Linux Kernel Port is distributed in the hope that it
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied
+# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with the Ubicom32 Linux Kernel Port.  If not, 
+# see <http://www.gnu.org/licenses/>.
+#
+# Ubicom32 implementation derived from (with many thanks):
+#   arch/m68knommu
+#   arch/blackfin
+#   arch/parisc
+#
+
+obj-$(CONFIG_IP5170DPF)		+= board-ip5170dpf.o
+obj-$(CONFIG_IP5160DEV)		+= board-ip5160dev.o
+obj-$(CONFIG_IP5160EVAL)	+= board-ip5160rgw.o
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/mach-ip7k/Kconfig linux-2.6.28.10/arch/ubicom32/mach-ip7k/Kconfig
--- linux-2.6.28.10_o/arch/ubicom32/mach-ip7k/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/mach-ip7k/Kconfig	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,132 @@
+config IP7145DPF
+	bool "IP7145DPF"
+	select UBICOM32_V4
+	select UBICOM_INPUT
+	select UBICOM_INPUT_I2C
+	select RTC_CLASS
+	select RTC_DRV_S35390A
+	select I2C
+	select I2C_GPIO
+	select GPIO_PCA953X
+	select FB
+	select FB_UBICOM32
+	select BACKLIGHT_LCD_SUPPORT
+	select LCD_CLASS_DEVICE
+	select LCD_UBICOM32
+	select BACKLIGHT_CLASS_DEVICE
+	select BACKLIGHT_UBICOM32
+	select SND_UBI32
+	select MMC_UBICOM32
+	select MMC
+	select MMC_BLOCK
+	select BRD_64MB
+	help
+		IP7145 Digital Picture Frame reference design, supports:
+			8007-0410 v1.0
+
+config IP7160RGW
+	bool "IP7160RGW"
+	select UBICOM32_V4
+	select UBICOM_INPUT
+	select NEW_LEDS
+	select LEDS_CLASS
+	select LEDS_GPIO
+	select BRD_64MB
+	select SPI
+	select SPI_UBICOM32_GPIO
+	select VLAN_8021Q
+	select UBICOM_SWITCH
+	select UBICOM_SWITCH_BCM539X
+	help
+		Ubicom IP7160 RGW Eval, supports:
+			8007-0110 v1.0
+			8007-0111 v1.1
+			8007-0112 v1.2
+
+config IP7160BRINGUP
+	bool "IP7160BRINGUP"
+	select UBICOM32_V4
+	select NEW_LEDS
+	select LEDS_CLASS
+	select LEDS_GPIO
+	select BRD_64MB
+	help
+		Ubicom IP7160 Bringup, supports:
+			8007-0010 v1.0
+
+config IP7160DPF
+	bool "IP7160DPF"
+	select UBICOM32_V4
+	select I2C
+	select I2C_GPIO
+	select FB
+	select FB_UBICOM32
+	select BACKLIGHT_LCD_SUPPORT
+	select BACKLIGHT_CLASS_DEVICE
+	select SND_UBI32
+	select SND_UBI32_AUDIO_CS4350
+	select UBICOM_HID
+	select BRD_64MB
+	help
+		IP7160 Digital Picture Frame board, supports:
+			8007-0211 Rev 1.1
+
+config IP7500MODULE
+	bool "IP7500MODULE"
+	select UBICOM32_V4
+	select BRD_128MB
+	help
+		Ubicom IP7500 CPU Module board, supports:
+			8007-0510  v1.0
+			8007-0510A v1.0
+
+		Please see ip7500module.c for more details.
+
+config IP7500AV
+	bool "IP7500AV"
+	select UBICOM32_V4
+	select BRD_128MB
+	select I2C
+	select I2C_GPIO
+	select SND_UBI32
+	select SND_UBI32_AUDIO_CS4384
+	select FB
+	select FB_UBICOM32
+	help
+		Ubicom IP7500 Audio Video board, supports:
+			8007-0810  v1.0
+
+		With Ubicom IP7500 CPU Module board:
+			8007-0510  v1.0 -or-
+			8007-0510A v1.0
+
+		Please see ip7500av.c for more details.
+
+config IP7500MEDIA
+	bool "IP7500MEDIA"
+	select UBICOM32_V4
+	select UBICOM_INPUT_I2C
+	select RTC_CLASS
+	select RTC_DRV_S35390A
+	select I2C
+	select I2C_GPIO
+	select GPIO_PCA953X
+	select FB
+	select FB_UBICOM32
+	select BACKLIGHT_LCD_SUPPORT
+	select LCD_CLASS_DEVICE
+	select LCD_UBICOM32
+	select BACKLIGHT_CLASS_DEVICE
+	select BACKLIGHT_UBICOM32
+	select SND_UBI32
+	select SND_UBI32_AUDIO_CS4350
+	select MMC_UBICOM32
+	select MMC
+	select MMC_BLOCK
+	select BRD_128MB
+	help
+		IP7500 Media Board w/ IP7500 CPU Module board, supports:
+			8007-0610 v1.0 w/ 8007-0510 v1.0
+
+		Please see ip7500media.c for more details.
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/mach-ip7k/Makefile linux-2.6.28.10/arch/ubicom32/mach-ip7k/Makefile
--- linux-2.6.28.10_o/arch/ubicom32/mach-ip7k/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/mach-ip7k/Makefile	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,35 @@
+#
+# arch/ubicom32/mach-ip7k/Makefile
+#	Makefile for ip7k based boards.
+#
+# (C) Copyright 2009, Ubicom, Inc.
+#
+# This file is part of the Ubicom32 Linux Kernel Port.
+#
+# The Ubicom32 Linux Kernel Port is free software: you can redistribute
+# it and/or modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation, either version 2 of the
+# License, or (at your option) any later version.
+#
+# The Ubicom32 Linux Kernel Port is distributed in the hope that it
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied
+# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with the Ubicom32 Linux Kernel Port.  If not, 
+# see <http://www.gnu.org/licenses/>.
+#
+# Ubicom32 implementation derived from (with many thanks):
+#   arch/m68knommu
+#   arch/blackfin
+#   arch/parisc
+#
+
+obj-$(CONFIG_IP7145DPF)		+= board-ip7145dpf.o
+obj-$(CONFIG_IP7160RGW)		+= board-ip7160rgw.o
+obj-$(CONFIG_IP7160BRINGUP)	+= board-ip7160bringup.o
+obj-$(CONFIG_IP7160DPF)		+= board-ip7160dpf.o
+obj-$(CONFIG_IP7500MODULE)	+= board-ip7500module.o
+obj-$(CONFIG_IP7500MEDIA)	+= board-ip7500media.o
+obj-$(CONFIG_IP7500AV)		+= board-ip7500av.o
diff -ruN linux-2.6.28.10_o/arch/ubicom32/Makefile linux-2.6.28.10/arch/ubicom32/Makefile
--- linux-2.6.28.10_o/arch/ubicom32/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/Makefile	2009-08-06 10:31:02.000000000 +0300
@@ -0,0 +1,105 @@
+#
+# arch/ubicom32/Makefile
+#	<TODO: Replace with short file description>
+#
+# (C) Copyright 2009, Ubicom, Inc.
+#
+# This file is part of the Ubicom32 Linux Kernel Port.
+#
+# The Ubicom32 Linux Kernel Port is free software: you can redistribute
+# it and/or modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation, either version 2 of the
+# License, or (at your option) any later version.
+#
+# The Ubicom32 Linux Kernel Port is distributed in the hope that it
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied
+# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with the Ubicom32 Linux Kernel Port.  If not, 
+# see <http://www.gnu.org/licenses/>.
+#
+# Ubicom32 implementation derived from (with many thanks):
+#   arch/m68knommu
+#   arch/blackfin
+#   arch/parisc
+#
+
+KBUILD_DEFCONFIG := 
+
+# setup the machine name and machine dependent settings
+machine-$(CONFIG_UBICOM32_V3)	:= ip5k
+machine-$(CONFIG_UBICOM32_V4)	:= ip7k
+MACHINE := $(machine-y)
+export MACHINE
+
+model-$(CONFIG_RAMKERNEL)	:= ram
+model-$(CONFIG_ROMKERNEL)	:= rom
+MODEL := $(model-y)
+export MODEL
+
+CPUCLASS := $(cpuclass-y)
+
+export CPUCLASS
+
+#
+# We want the core kernel built using the fastcall ABI but modules need
+# to be built using the slower calling convention because they could be
+# loaded out of range for fast calls.
+#
+CFLAGS_KERNEL    += -mfastcall
+CFLAGS_MODULE    += -mno-fastcall
+
+#
+# Some CFLAG additions based on specific CPU type.
+#
+cflags-$(CONFIG_UBICOM32_V3)		:= -march=ubicom32v3 -DIP5000
+cflags-$(CONFIG_UBICOM32_V4)		:= -march=ubicom32v4 -DIP7000
+
+ldflags-$(CONFIG_LINKER_RELAXATION)	:= --relax
+LDFLAGS_vmlinux := $(ldflags-y)
+
+GCCLIBDIR := $(dir $(shell $(CC) $(cflags-y) -print-libgcc-file-name))
+GCC_LIBS := $(GCCLIBDIR)/libgcc.a
+
+KBUILD_CFLAGS += $(cflags-y) -ffunction-sections
+KBUILD_AFLAGS += $(cflags-y)
+
+KBUILD_CFLAGS += -D__linux__ -Dlinux
+KBUILD_CFLAGS += -DUTS_SYSNAME=\"uClinux\"
+
+# include any machine specific directory
+ifneq ($(machine-y),)
+core-y += arch/$(ARCH)/mach-$(MACHINE)/
+endif
+
+head-y := arch/$(ARCH)/kernel/head.o
+
+core-y	+= arch/$(ARCH)/kernel/ \
+	   arch/$(ARCH)/mm/ \
+	   arch/$(ARCH)/crypto/ \
+	   arch/$(ARCH)/mach-common/
+
+drivers-$(CONFIG_OPROFILE)	+= arch/ubicom32/oprofile/
+
+libs-y	+= arch/$(ARCH)/lib/
+libs-y	+= $(GCC_LIBS)
+
+archclean:
+
+# make sure developer has selected a valid board
+ifeq ($(CONFIG_NOBOARD),y)
+# $(error have to select a valid board file $(CONFIG_NOBOARD), please run kernel config again)
+_all: config_board_error
+endif
+
+config_board_error:
+	@echo "*************************************************"
+	@echo "You have not selected a proper board."
+	@echo "Please run menuconfig (or config) against your"
+	@echo "kernel and choose your board under Processor"
+	@echo "options"
+	@echo "*************************************************"
+	@exit 1
+
diff -ruN linux-2.6.28.10_o/arch/ubicom32/mm/Makefile linux-2.6.28.10/arch/ubicom32/mm/Makefile
--- linux-2.6.28.10_o/arch/ubicom32/mm/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.28.10/arch/ubicom32/mm/Makefile	2009-08-12 13:08:37.000000000 +0300
@@ -0,0 +1,32 @@
+#
+# arch/ubicom32/mm/Makefile
+#	<TODO: Replace with short file description>
+#
+# (C) Copyright 2009, Ubicom, Inc.
+#
+# This file is part of the Ubicom32 Linux Kernel Port.
+#
+# The Ubicom32 Linux Kernel Port is free software: you can redistribute
+# it and/or modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation, either version 2 of the
+# License, or (at your option) any later version.
+#
+# The Ubicom32 Linux Kernel Port is distributed in the hope that it
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied
+# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with the Ubicom32 Linux Kernel Port.  If not, 
+# see <http://www.gnu.org/licenses/>.
+#
+# Ubicom32 implementation derived from (with many thanks):
+#   arch/m68knommu
+#   arch/blackfin
+#   arch/parisc
+#
+#
+# Makefile for the linux m68knommu specific parts of the memory manager.
+#
+
+obj-y += init.o fault.o memory.o kmap.o ocm-alloc.o
diff -ruN linux-2.6.28.10_o/include/linux/elf-em.h linux-2.6.28.10/include/linux/elf-em.h
--- linux-2.6.28.10_o/include/linux/elf-em.h	2009-05-02 21:54:43.000000000 +0300
+++ linux-2.6.28.10/include/linux/elf-em.h	2009-08-06 10:31:10.000000000 +0300
@@ -41,6 +41,7 @@
  * up with a final number.
  */
 #define EM_ALPHA	0x9026
+#define EM_UBICOM32 	        0xde3d	/* Ubicom32; no ABI */
 
 /* Bogus old v850 magic number, used by old tools. */
 #define EM_CYGNUS_V850	0x9080
diff -ruN linux-2.6.28.10_o/lib/Kconfig.debug linux-2.6.28.10/lib/Kconfig.debug
--- linux-2.6.28.10_o/lib/Kconfig.debug	2009-05-02 21:54:43.000000000 +0300
+++ linux-2.6.28.10/lib/Kconfig.debug	2009-08-06 10:31:11.000000000 +0300
@@ -549,7 +549,7 @@
 	bool "Compile the kernel with frame pointers"
 	depends on DEBUG_KERNEL && \
 		(X86 || CRIS || M68K || M68KNOMMU || FRV || UML || S390 || \
-		 AVR32 || SUPERH || BLACKFIN || MN10300)
+		 AVR32 || SUPERH || BLACKFIN || MN10300 || UBICOM32)
 	default y if DEBUG_INFO && UML
 	help
 	  If you say Y here the resulting kernel image will be slightly larger
diff -ruN linux-2.6.28.10_o/scripts/mod/file2alias.c linux-2.6.28.10/scripts/mod/file2alias.c
--- linux-2.6.28.10_o/scripts/mod/file2alias.c	2009-05-02 21:54:43.000000000 +0300
+++ linux-2.6.28.10/scripts/mod/file2alias.c	2009-08-06 10:31:12.000000000 +0300
@@ -753,6 +753,15 @@
 			+ sym->st_value;
 	}
 
+	/*
+ 	 * somehow our gcc is not generating st_size correctly and set 0 for some symbols.
+ 	 * and 0 size will break do_table since it adjust size to (size - id_size)
+ 	 * this is to make sure st_size fall in range.
+ 	 */
+	if (sym->st_size == 0 || sym->st_size > info->sechdrs[sym->st_shndx].sh_size) {
+		sym->st_size = info->sechdrs[sym->st_shndx].sh_size;
+	}
+
 	if (sym_is(symname, "__mod_pci_device_table"))
 		do_table(symval, sym->st_size,
 			 sizeof(struct pci_device_id), "pci",

